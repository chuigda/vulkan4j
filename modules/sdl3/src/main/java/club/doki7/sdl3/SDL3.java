package club.doki7.sdl3;

import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.util.Objects;

import org.jetbrains.annotations.Nullable;
import club.doki7.ffm.NativeLayout;
import club.doki7.ffm.RawFunctionLoader;
import club.doki7.ffm.annotation.*;
import club.doki7.ffm.ptr.*;
import club.doki7.sdl3.bitmask.*;
import club.doki7.sdl3.datatype.*;
import club.doki7.sdl3.enumtype.*;
import club.doki7.sdl3.handle.*;

public final class SDL3 implements SDL3Constants {
    public SDL3(RawFunctionLoader loader) {
        SEGMENT$SDL_malloc = loader.apply("SDL_malloc");
        HANDLE$SDL_malloc = RawFunctionLoader.link(SEGMENT$SDL_malloc, Descriptors.DESCRIPTOR$SDL_malloc);
        SEGMENT$SDL_calloc = loader.apply("SDL_calloc");
        HANDLE$SDL_calloc = RawFunctionLoader.link(SEGMENT$SDL_calloc, Descriptors.DESCRIPTOR$SDL_calloc);
        SEGMENT$SDL_realloc = loader.apply("SDL_realloc");
        HANDLE$SDL_realloc = RawFunctionLoader.link(SEGMENT$SDL_realloc, Descriptors.DESCRIPTOR$SDL_realloc);
        SEGMENT$SDL_free = loader.apply("SDL_free");
        HANDLE$SDL_free = RawFunctionLoader.link(SEGMENT$SDL_free, Descriptors.DESCRIPTOR$SDL_free);
        SEGMENT$SDL_GetOriginalMemoryFunctions = loader.apply("SDL_GetOriginalMemoryFunctions");
        HANDLE$SDL_GetOriginalMemoryFunctions = RawFunctionLoader.link(SEGMENT$SDL_GetOriginalMemoryFunctions, Descriptors.DESCRIPTOR$SDL_GetOriginalMemoryFunctions);
        SEGMENT$SDL_GetMemoryFunctions = loader.apply("SDL_GetMemoryFunctions");
        HANDLE$SDL_GetMemoryFunctions = RawFunctionLoader.link(SEGMENT$SDL_GetMemoryFunctions, Descriptors.DESCRIPTOR$SDL_GetMemoryFunctions);
        SEGMENT$SDL_SetMemoryFunctions = loader.apply("SDL_SetMemoryFunctions");
        HANDLE$SDL_SetMemoryFunctions = RawFunctionLoader.link(SEGMENT$SDL_SetMemoryFunctions, Descriptors.DESCRIPTOR$SDL_SetMemoryFunctions);
        SEGMENT$SDL_aligned_alloc = loader.apply("SDL_aligned_alloc");
        HANDLE$SDL_aligned_alloc = RawFunctionLoader.link(SEGMENT$SDL_aligned_alloc, Descriptors.DESCRIPTOR$SDL_aligned_alloc);
        SEGMENT$SDL_aligned_free = loader.apply("SDL_aligned_free");
        HANDLE$SDL_aligned_free = RawFunctionLoader.link(SEGMENT$SDL_aligned_free, Descriptors.DESCRIPTOR$SDL_aligned_free);
        SEGMENT$SDL_GetNumAllocations = loader.apply("SDL_GetNumAllocations");
        HANDLE$SDL_GetNumAllocations = RawFunctionLoader.link(SEGMENT$SDL_GetNumAllocations, Descriptors.DESCRIPTOR$SDL_GetNumAllocations);
        SEGMENT$SDL_GetEnvironment = loader.apply("SDL_GetEnvironment");
        HANDLE$SDL_GetEnvironment = RawFunctionLoader.link(SEGMENT$SDL_GetEnvironment, Descriptors.DESCRIPTOR$SDL_GetEnvironment);
        SEGMENT$SDL_CreateEnvironment = loader.apply("SDL_CreateEnvironment");
        HANDLE$SDL_CreateEnvironment = RawFunctionLoader.link(SEGMENT$SDL_CreateEnvironment, Descriptors.DESCRIPTOR$SDL_CreateEnvironment);
        SEGMENT$SDL_GetEnvironmentVariable = loader.apply("SDL_GetEnvironmentVariable");
        HANDLE$SDL_GetEnvironmentVariable = RawFunctionLoader.link(SEGMENT$SDL_GetEnvironmentVariable, Descriptors.DESCRIPTOR$SDL_GetEnvironmentVariable);
        SEGMENT$SDL_GetEnvironmentVariables = loader.apply("SDL_GetEnvironmentVariables");
        HANDLE$SDL_GetEnvironmentVariables = RawFunctionLoader.link(SEGMENT$SDL_GetEnvironmentVariables, Descriptors.DESCRIPTOR$SDL_GetEnvironmentVariables);
        SEGMENT$SDL_SetEnvironmentVariable = loader.apply("SDL_SetEnvironmentVariable");
        HANDLE$SDL_SetEnvironmentVariable = RawFunctionLoader.link(SEGMENT$SDL_SetEnvironmentVariable, Descriptors.DESCRIPTOR$SDL_SetEnvironmentVariable);
        SEGMENT$SDL_UnsetEnvironmentVariable = loader.apply("SDL_UnsetEnvironmentVariable");
        HANDLE$SDL_UnsetEnvironmentVariable = RawFunctionLoader.link(SEGMENT$SDL_UnsetEnvironmentVariable, Descriptors.DESCRIPTOR$SDL_UnsetEnvironmentVariable);
        SEGMENT$SDL_DestroyEnvironment = loader.apply("SDL_DestroyEnvironment");
        HANDLE$SDL_DestroyEnvironment = RawFunctionLoader.link(SEGMENT$SDL_DestroyEnvironment, Descriptors.DESCRIPTOR$SDL_DestroyEnvironment);
        SEGMENT$SDL_getenv = loader.apply("SDL_getenv");
        HANDLE$SDL_getenv = RawFunctionLoader.link(SEGMENT$SDL_getenv, Descriptors.DESCRIPTOR$SDL_getenv);
        SEGMENT$SDL_getenv_unsafe = loader.apply("SDL_getenv_unsafe");
        HANDLE$SDL_getenv_unsafe = RawFunctionLoader.link(SEGMENT$SDL_getenv_unsafe, Descriptors.DESCRIPTOR$SDL_getenv_unsafe);
        SEGMENT$SDL_setenv_unsafe = loader.apply("SDL_setenv_unsafe");
        HANDLE$SDL_setenv_unsafe = RawFunctionLoader.link(SEGMENT$SDL_setenv_unsafe, Descriptors.DESCRIPTOR$SDL_setenv_unsafe);
        SEGMENT$SDL_unsetenv_unsafe = loader.apply("SDL_unsetenv_unsafe");
        HANDLE$SDL_unsetenv_unsafe = RawFunctionLoader.link(SEGMENT$SDL_unsetenv_unsafe, Descriptors.DESCRIPTOR$SDL_unsetenv_unsafe);
        SEGMENT$SDL_qsort = loader.apply("SDL_qsort");
        HANDLE$SDL_qsort = RawFunctionLoader.link(SEGMENT$SDL_qsort, Descriptors.DESCRIPTOR$SDL_qsort);
        SEGMENT$SDL_bsearch = loader.apply("SDL_bsearch");
        HANDLE$SDL_bsearch = RawFunctionLoader.link(SEGMENT$SDL_bsearch, Descriptors.DESCRIPTOR$SDL_bsearch);
        SEGMENT$SDL_qsort_r = loader.apply("SDL_qsort_r");
        HANDLE$SDL_qsort_r = RawFunctionLoader.link(SEGMENT$SDL_qsort_r, Descriptors.DESCRIPTOR$SDL_qsort_r);
        SEGMENT$SDL_bsearch_r = loader.apply("SDL_bsearch_r");
        HANDLE$SDL_bsearch_r = RawFunctionLoader.link(SEGMENT$SDL_bsearch_r, Descriptors.DESCRIPTOR$SDL_bsearch_r);
        SEGMENT$SDL_abs = loader.apply("SDL_abs");
        HANDLE$SDL_abs = RawFunctionLoader.link(SEGMENT$SDL_abs, Descriptors.DESCRIPTOR$SDL_abs);
        SEGMENT$SDL_isalpha = loader.apply("SDL_isalpha");
        HANDLE$SDL_isalpha = RawFunctionLoader.link(SEGMENT$SDL_isalpha, Descriptors.DESCRIPTOR$SDL_isalpha);
        SEGMENT$SDL_isalnum = loader.apply("SDL_isalnum");
        HANDLE$SDL_isalnum = RawFunctionLoader.link(SEGMENT$SDL_isalnum, Descriptors.DESCRIPTOR$SDL_isalnum);
        SEGMENT$SDL_isblank = loader.apply("SDL_isblank");
        HANDLE$SDL_isblank = RawFunctionLoader.link(SEGMENT$SDL_isblank, Descriptors.DESCRIPTOR$SDL_isblank);
        SEGMENT$SDL_iscntrl = loader.apply("SDL_iscntrl");
        HANDLE$SDL_iscntrl = RawFunctionLoader.link(SEGMENT$SDL_iscntrl, Descriptors.DESCRIPTOR$SDL_iscntrl);
        SEGMENT$SDL_isdigit = loader.apply("SDL_isdigit");
        HANDLE$SDL_isdigit = RawFunctionLoader.link(SEGMENT$SDL_isdigit, Descriptors.DESCRIPTOR$SDL_isdigit);
        SEGMENT$SDL_isxdigit = loader.apply("SDL_isxdigit");
        HANDLE$SDL_isxdigit = RawFunctionLoader.link(SEGMENT$SDL_isxdigit, Descriptors.DESCRIPTOR$SDL_isxdigit);
        SEGMENT$SDL_ispunct = loader.apply("SDL_ispunct");
        HANDLE$SDL_ispunct = RawFunctionLoader.link(SEGMENT$SDL_ispunct, Descriptors.DESCRIPTOR$SDL_ispunct);
        SEGMENT$SDL_isspace = loader.apply("SDL_isspace");
        HANDLE$SDL_isspace = RawFunctionLoader.link(SEGMENT$SDL_isspace, Descriptors.DESCRIPTOR$SDL_isspace);
        SEGMENT$SDL_isupper = loader.apply("SDL_isupper");
        HANDLE$SDL_isupper = RawFunctionLoader.link(SEGMENT$SDL_isupper, Descriptors.DESCRIPTOR$SDL_isupper);
        SEGMENT$SDL_islower = loader.apply("SDL_islower");
        HANDLE$SDL_islower = RawFunctionLoader.link(SEGMENT$SDL_islower, Descriptors.DESCRIPTOR$SDL_islower);
        SEGMENT$SDL_isprint = loader.apply("SDL_isprint");
        HANDLE$SDL_isprint = RawFunctionLoader.link(SEGMENT$SDL_isprint, Descriptors.DESCRIPTOR$SDL_isprint);
        SEGMENT$SDL_isgraph = loader.apply("SDL_isgraph");
        HANDLE$SDL_isgraph = RawFunctionLoader.link(SEGMENT$SDL_isgraph, Descriptors.DESCRIPTOR$SDL_isgraph);
        SEGMENT$SDL_toupper = loader.apply("SDL_toupper");
        HANDLE$SDL_toupper = RawFunctionLoader.link(SEGMENT$SDL_toupper, Descriptors.DESCRIPTOR$SDL_toupper);
        SEGMENT$SDL_tolower = loader.apply("SDL_tolower");
        HANDLE$SDL_tolower = RawFunctionLoader.link(SEGMENT$SDL_tolower, Descriptors.DESCRIPTOR$SDL_tolower);
        SEGMENT$SDL_crc16 = loader.apply("SDL_crc16");
        HANDLE$SDL_crc16 = RawFunctionLoader.link(SEGMENT$SDL_crc16, Descriptors.DESCRIPTOR$SDL_crc16);
        SEGMENT$SDL_crc32 = loader.apply("SDL_crc32");
        HANDLE$SDL_crc32 = RawFunctionLoader.link(SEGMENT$SDL_crc32, Descriptors.DESCRIPTOR$SDL_crc32);
        SEGMENT$SDL_murmur3_32 = loader.apply("SDL_murmur3_32");
        HANDLE$SDL_murmur3_32 = RawFunctionLoader.link(SEGMENT$SDL_murmur3_32, Descriptors.DESCRIPTOR$SDL_murmur3_32);
        SEGMENT$SDL_memcpy = loader.apply("SDL_memcpy");
        HANDLE$SDL_memcpy = RawFunctionLoader.link(SEGMENT$SDL_memcpy, Descriptors.DESCRIPTOR$SDL_memcpy);
        SEGMENT$SDL_memmove = loader.apply("SDL_memmove");
        HANDLE$SDL_memmove = RawFunctionLoader.link(SEGMENT$SDL_memmove, Descriptors.DESCRIPTOR$SDL_memmove);
        SEGMENT$SDL_memset = loader.apply("SDL_memset");
        HANDLE$SDL_memset = RawFunctionLoader.link(SEGMENT$SDL_memset, Descriptors.DESCRIPTOR$SDL_memset);
        SEGMENT$SDL_memset4 = loader.apply("SDL_memset4");
        HANDLE$SDL_memset4 = RawFunctionLoader.link(SEGMENT$SDL_memset4, Descriptors.DESCRIPTOR$SDL_memset4);
        SEGMENT$SDL_memcmp = loader.apply("SDL_memcmp");
        HANDLE$SDL_memcmp = RawFunctionLoader.link(SEGMENT$SDL_memcmp, Descriptors.DESCRIPTOR$SDL_memcmp);
        SEGMENT$SDL_wcslen = loader.apply("SDL_wcslen");
        HANDLE$SDL_wcslen = RawFunctionLoader.link(SEGMENT$SDL_wcslen, Descriptors.DESCRIPTOR$SDL_wcslen);
        SEGMENT$SDL_wcsnlen = loader.apply("SDL_wcsnlen");
        HANDLE$SDL_wcsnlen = RawFunctionLoader.link(SEGMENT$SDL_wcsnlen, Descriptors.DESCRIPTOR$SDL_wcsnlen);
        SEGMENT$SDL_wcslcpy = loader.apply("SDL_wcslcpy");
        HANDLE$SDL_wcslcpy = RawFunctionLoader.link(SEGMENT$SDL_wcslcpy, Descriptors.DESCRIPTOR$SDL_wcslcpy);
        SEGMENT$SDL_wcslcat = loader.apply("SDL_wcslcat");
        HANDLE$SDL_wcslcat = RawFunctionLoader.link(SEGMENT$SDL_wcslcat, Descriptors.DESCRIPTOR$SDL_wcslcat);
        SEGMENT$SDL_wcsdup = loader.apply("SDL_wcsdup");
        HANDLE$SDL_wcsdup = RawFunctionLoader.link(SEGMENT$SDL_wcsdup, Descriptors.DESCRIPTOR$SDL_wcsdup);
        SEGMENT$SDL_wcsstr = loader.apply("SDL_wcsstr");
        HANDLE$SDL_wcsstr = RawFunctionLoader.link(SEGMENT$SDL_wcsstr, Descriptors.DESCRIPTOR$SDL_wcsstr);
        SEGMENT$SDL_wcsnstr = loader.apply("SDL_wcsnstr");
        HANDLE$SDL_wcsnstr = RawFunctionLoader.link(SEGMENT$SDL_wcsnstr, Descriptors.DESCRIPTOR$SDL_wcsnstr);
        SEGMENT$SDL_wcscmp = loader.apply("SDL_wcscmp");
        HANDLE$SDL_wcscmp = RawFunctionLoader.link(SEGMENT$SDL_wcscmp, Descriptors.DESCRIPTOR$SDL_wcscmp);
        SEGMENT$SDL_wcsncmp = loader.apply("SDL_wcsncmp");
        HANDLE$SDL_wcsncmp = RawFunctionLoader.link(SEGMENT$SDL_wcsncmp, Descriptors.DESCRIPTOR$SDL_wcsncmp);
        SEGMENT$SDL_wcscasecmp = loader.apply("SDL_wcscasecmp");
        HANDLE$SDL_wcscasecmp = RawFunctionLoader.link(SEGMENT$SDL_wcscasecmp, Descriptors.DESCRIPTOR$SDL_wcscasecmp);
        SEGMENT$SDL_wcsncasecmp = loader.apply("SDL_wcsncasecmp");
        HANDLE$SDL_wcsncasecmp = RawFunctionLoader.link(SEGMENT$SDL_wcsncasecmp, Descriptors.DESCRIPTOR$SDL_wcsncasecmp);
        SEGMENT$SDL_wcstol = loader.apply("SDL_wcstol");
        HANDLE$SDL_wcstol = RawFunctionLoader.link(SEGMENT$SDL_wcstol, Descriptors.DESCRIPTOR$SDL_wcstol);
        SEGMENT$SDL_strlen = loader.apply("SDL_strlen");
        HANDLE$SDL_strlen = RawFunctionLoader.link(SEGMENT$SDL_strlen, Descriptors.DESCRIPTOR$SDL_strlen);
        SEGMENT$SDL_strnlen = loader.apply("SDL_strnlen");
        HANDLE$SDL_strnlen = RawFunctionLoader.link(SEGMENT$SDL_strnlen, Descriptors.DESCRIPTOR$SDL_strnlen);
        SEGMENT$SDL_strlcpy = loader.apply("SDL_strlcpy");
        HANDLE$SDL_strlcpy = RawFunctionLoader.link(SEGMENT$SDL_strlcpy, Descriptors.DESCRIPTOR$SDL_strlcpy);
        SEGMENT$SDL_utf8strlcpy = loader.apply("SDL_utf8strlcpy");
        HANDLE$SDL_utf8strlcpy = RawFunctionLoader.link(SEGMENT$SDL_utf8strlcpy, Descriptors.DESCRIPTOR$SDL_utf8strlcpy);
        SEGMENT$SDL_strlcat = loader.apply("SDL_strlcat");
        HANDLE$SDL_strlcat = RawFunctionLoader.link(SEGMENT$SDL_strlcat, Descriptors.DESCRIPTOR$SDL_strlcat);
        SEGMENT$SDL_strdup = loader.apply("SDL_strdup");
        HANDLE$SDL_strdup = RawFunctionLoader.link(SEGMENT$SDL_strdup, Descriptors.DESCRIPTOR$SDL_strdup);
        SEGMENT$SDL_strndup = loader.apply("SDL_strndup");
        HANDLE$SDL_strndup = RawFunctionLoader.link(SEGMENT$SDL_strndup, Descriptors.DESCRIPTOR$SDL_strndup);
        SEGMENT$SDL_strrev = loader.apply("SDL_strrev");
        HANDLE$SDL_strrev = RawFunctionLoader.link(SEGMENT$SDL_strrev, Descriptors.DESCRIPTOR$SDL_strrev);
        SEGMENT$SDL_strupr = loader.apply("SDL_strupr");
        HANDLE$SDL_strupr = RawFunctionLoader.link(SEGMENT$SDL_strupr, Descriptors.DESCRIPTOR$SDL_strupr);
        SEGMENT$SDL_strlwr = loader.apply("SDL_strlwr");
        HANDLE$SDL_strlwr = RawFunctionLoader.link(SEGMENT$SDL_strlwr, Descriptors.DESCRIPTOR$SDL_strlwr);
        SEGMENT$SDL_strchr = loader.apply("SDL_strchr");
        HANDLE$SDL_strchr = RawFunctionLoader.link(SEGMENT$SDL_strchr, Descriptors.DESCRIPTOR$SDL_strchr);
        SEGMENT$SDL_strrchr = loader.apply("SDL_strrchr");
        HANDLE$SDL_strrchr = RawFunctionLoader.link(SEGMENT$SDL_strrchr, Descriptors.DESCRIPTOR$SDL_strrchr);
        SEGMENT$SDL_strstr = loader.apply("SDL_strstr");
        HANDLE$SDL_strstr = RawFunctionLoader.link(SEGMENT$SDL_strstr, Descriptors.DESCRIPTOR$SDL_strstr);
        SEGMENT$SDL_strnstr = loader.apply("SDL_strnstr");
        HANDLE$SDL_strnstr = RawFunctionLoader.link(SEGMENT$SDL_strnstr, Descriptors.DESCRIPTOR$SDL_strnstr);
        SEGMENT$SDL_strcasestr = loader.apply("SDL_strcasestr");
        HANDLE$SDL_strcasestr = RawFunctionLoader.link(SEGMENT$SDL_strcasestr, Descriptors.DESCRIPTOR$SDL_strcasestr);
        SEGMENT$SDL_strtok_r = loader.apply("SDL_strtok_r");
        HANDLE$SDL_strtok_r = RawFunctionLoader.link(SEGMENT$SDL_strtok_r, Descriptors.DESCRIPTOR$SDL_strtok_r);
        SEGMENT$SDL_utf8strlen = loader.apply("SDL_utf8strlen");
        HANDLE$SDL_utf8strlen = RawFunctionLoader.link(SEGMENT$SDL_utf8strlen, Descriptors.DESCRIPTOR$SDL_utf8strlen);
        SEGMENT$SDL_utf8strnlen = loader.apply("SDL_utf8strnlen");
        HANDLE$SDL_utf8strnlen = RawFunctionLoader.link(SEGMENT$SDL_utf8strnlen, Descriptors.DESCRIPTOR$SDL_utf8strnlen);
        SEGMENT$SDL_itoa = loader.apply("SDL_itoa");
        HANDLE$SDL_itoa = RawFunctionLoader.link(SEGMENT$SDL_itoa, Descriptors.DESCRIPTOR$SDL_itoa);
        SEGMENT$SDL_uitoa = loader.apply("SDL_uitoa");
        HANDLE$SDL_uitoa = RawFunctionLoader.link(SEGMENT$SDL_uitoa, Descriptors.DESCRIPTOR$SDL_uitoa);
        SEGMENT$SDL_ltoa = loader.apply("SDL_ltoa");
        HANDLE$SDL_ltoa = RawFunctionLoader.link(SEGMENT$SDL_ltoa, Descriptors.DESCRIPTOR$SDL_ltoa);
        SEGMENT$SDL_ultoa = loader.apply("SDL_ultoa");
        HANDLE$SDL_ultoa = RawFunctionLoader.link(SEGMENT$SDL_ultoa, Descriptors.DESCRIPTOR$SDL_ultoa);
        SEGMENT$SDL_lltoa = loader.apply("SDL_lltoa");
        HANDLE$SDL_lltoa = RawFunctionLoader.link(SEGMENT$SDL_lltoa, Descriptors.DESCRIPTOR$SDL_lltoa);
        SEGMENT$SDL_ulltoa = loader.apply("SDL_ulltoa");
        HANDLE$SDL_ulltoa = RawFunctionLoader.link(SEGMENT$SDL_ulltoa, Descriptors.DESCRIPTOR$SDL_ulltoa);
        SEGMENT$SDL_atoi = loader.apply("SDL_atoi");
        HANDLE$SDL_atoi = RawFunctionLoader.link(SEGMENT$SDL_atoi, Descriptors.DESCRIPTOR$SDL_atoi);
        SEGMENT$SDL_atof = loader.apply("SDL_atof");
        HANDLE$SDL_atof = RawFunctionLoader.link(SEGMENT$SDL_atof, Descriptors.DESCRIPTOR$SDL_atof);
        SEGMENT$SDL_strtol = loader.apply("SDL_strtol");
        HANDLE$SDL_strtol = RawFunctionLoader.link(SEGMENT$SDL_strtol, Descriptors.DESCRIPTOR$SDL_strtol);
        SEGMENT$SDL_strtoul = loader.apply("SDL_strtoul");
        HANDLE$SDL_strtoul = RawFunctionLoader.link(SEGMENT$SDL_strtoul, Descriptors.DESCRIPTOR$SDL_strtoul);
        SEGMENT$SDL_strtoll = loader.apply("SDL_strtoll");
        HANDLE$SDL_strtoll = RawFunctionLoader.link(SEGMENT$SDL_strtoll, Descriptors.DESCRIPTOR$SDL_strtoll);
        SEGMENT$SDL_strtoull = loader.apply("SDL_strtoull");
        HANDLE$SDL_strtoull = RawFunctionLoader.link(SEGMENT$SDL_strtoull, Descriptors.DESCRIPTOR$SDL_strtoull);
        SEGMENT$SDL_strtod = loader.apply("SDL_strtod");
        HANDLE$SDL_strtod = RawFunctionLoader.link(SEGMENT$SDL_strtod, Descriptors.DESCRIPTOR$SDL_strtod);
        SEGMENT$SDL_strcmp = loader.apply("SDL_strcmp");
        HANDLE$SDL_strcmp = RawFunctionLoader.link(SEGMENT$SDL_strcmp, Descriptors.DESCRIPTOR$SDL_strcmp);
        SEGMENT$SDL_strncmp = loader.apply("SDL_strncmp");
        HANDLE$SDL_strncmp = RawFunctionLoader.link(SEGMENT$SDL_strncmp, Descriptors.DESCRIPTOR$SDL_strncmp);
        SEGMENT$SDL_strcasecmp = loader.apply("SDL_strcasecmp");
        HANDLE$SDL_strcasecmp = RawFunctionLoader.link(SEGMENT$SDL_strcasecmp, Descriptors.DESCRIPTOR$SDL_strcasecmp);
        SEGMENT$SDL_strncasecmp = loader.apply("SDL_strncasecmp");
        HANDLE$SDL_strncasecmp = RawFunctionLoader.link(SEGMENT$SDL_strncasecmp, Descriptors.DESCRIPTOR$SDL_strncasecmp);
        SEGMENT$SDL_strpbrk = loader.apply("SDL_strpbrk");
        HANDLE$SDL_strpbrk = RawFunctionLoader.link(SEGMENT$SDL_strpbrk, Descriptors.DESCRIPTOR$SDL_strpbrk);
        SEGMENT$SDL_StepUTF8 = loader.apply("SDL_StepUTF8");
        HANDLE$SDL_StepUTF8 = RawFunctionLoader.link(SEGMENT$SDL_StepUTF8, Descriptors.DESCRIPTOR$SDL_StepUTF8);
        SEGMENT$SDL_StepBackUTF8 = loader.apply("SDL_StepBackUTF8");
        HANDLE$SDL_StepBackUTF8 = RawFunctionLoader.link(SEGMENT$SDL_StepBackUTF8, Descriptors.DESCRIPTOR$SDL_StepBackUTF8);
        SEGMENT$SDL_UCS4ToUTF8 = loader.apply("SDL_UCS4ToUTF8");
        HANDLE$SDL_UCS4ToUTF8 = RawFunctionLoader.link(SEGMENT$SDL_UCS4ToUTF8, Descriptors.DESCRIPTOR$SDL_UCS4ToUTF8);
        SEGMENT$SDL_srand = loader.apply("SDL_srand");
        HANDLE$SDL_srand = RawFunctionLoader.link(SEGMENT$SDL_srand, Descriptors.DESCRIPTOR$SDL_srand);
        SEGMENT$SDL_rand = loader.apply("SDL_rand");
        HANDLE$SDL_rand = RawFunctionLoader.link(SEGMENT$SDL_rand, Descriptors.DESCRIPTOR$SDL_rand);
        SEGMENT$SDL_randf = loader.apply("SDL_randf");
        HANDLE$SDL_randf = RawFunctionLoader.link(SEGMENT$SDL_randf, Descriptors.DESCRIPTOR$SDL_randf);
        SEGMENT$SDL_rand_bits = loader.apply("SDL_rand_bits");
        HANDLE$SDL_rand_bits = RawFunctionLoader.link(SEGMENT$SDL_rand_bits, Descriptors.DESCRIPTOR$SDL_rand_bits);
        SEGMENT$SDL_rand_r = loader.apply("SDL_rand_r");
        HANDLE$SDL_rand_r = RawFunctionLoader.link(SEGMENT$SDL_rand_r, Descriptors.DESCRIPTOR$SDL_rand_r);
        SEGMENT$SDL_randf_r = loader.apply("SDL_randf_r");
        HANDLE$SDL_randf_r = RawFunctionLoader.link(SEGMENT$SDL_randf_r, Descriptors.DESCRIPTOR$SDL_randf_r);
        SEGMENT$SDL_rand_bits_r = loader.apply("SDL_rand_bits_r");
        HANDLE$SDL_rand_bits_r = RawFunctionLoader.link(SEGMENT$SDL_rand_bits_r, Descriptors.DESCRIPTOR$SDL_rand_bits_r);
        SEGMENT$SDL_acos = loader.apply("SDL_acos");
        HANDLE$SDL_acos = RawFunctionLoader.link(SEGMENT$SDL_acos, Descriptors.DESCRIPTOR$SDL_acos);
        SEGMENT$SDL_acosf = loader.apply("SDL_acosf");
        HANDLE$SDL_acosf = RawFunctionLoader.link(SEGMENT$SDL_acosf, Descriptors.DESCRIPTOR$SDL_acosf);
        SEGMENT$SDL_asin = loader.apply("SDL_asin");
        HANDLE$SDL_asin = RawFunctionLoader.link(SEGMENT$SDL_asin, Descriptors.DESCRIPTOR$SDL_asin);
        SEGMENT$SDL_asinf = loader.apply("SDL_asinf");
        HANDLE$SDL_asinf = RawFunctionLoader.link(SEGMENT$SDL_asinf, Descriptors.DESCRIPTOR$SDL_asinf);
        SEGMENT$SDL_atan = loader.apply("SDL_atan");
        HANDLE$SDL_atan = RawFunctionLoader.link(SEGMENT$SDL_atan, Descriptors.DESCRIPTOR$SDL_atan);
        SEGMENT$SDL_atanf = loader.apply("SDL_atanf");
        HANDLE$SDL_atanf = RawFunctionLoader.link(SEGMENT$SDL_atanf, Descriptors.DESCRIPTOR$SDL_atanf);
        SEGMENT$SDL_atan2 = loader.apply("SDL_atan2");
        HANDLE$SDL_atan2 = RawFunctionLoader.link(SEGMENT$SDL_atan2, Descriptors.DESCRIPTOR$SDL_atan2);
        SEGMENT$SDL_atan2f = loader.apply("SDL_atan2f");
        HANDLE$SDL_atan2f = RawFunctionLoader.link(SEGMENT$SDL_atan2f, Descriptors.DESCRIPTOR$SDL_atan2f);
        SEGMENT$SDL_ceil = loader.apply("SDL_ceil");
        HANDLE$SDL_ceil = RawFunctionLoader.link(SEGMENT$SDL_ceil, Descriptors.DESCRIPTOR$SDL_ceil);
        SEGMENT$SDL_ceilf = loader.apply("SDL_ceilf");
        HANDLE$SDL_ceilf = RawFunctionLoader.link(SEGMENT$SDL_ceilf, Descriptors.DESCRIPTOR$SDL_ceilf);
        SEGMENT$SDL_copysign = loader.apply("SDL_copysign");
        HANDLE$SDL_copysign = RawFunctionLoader.link(SEGMENT$SDL_copysign, Descriptors.DESCRIPTOR$SDL_copysign);
        SEGMENT$SDL_copysignf = loader.apply("SDL_copysignf");
        HANDLE$SDL_copysignf = RawFunctionLoader.link(SEGMENT$SDL_copysignf, Descriptors.DESCRIPTOR$SDL_copysignf);
        SEGMENT$SDL_cos = loader.apply("SDL_cos");
        HANDLE$SDL_cos = RawFunctionLoader.link(SEGMENT$SDL_cos, Descriptors.DESCRIPTOR$SDL_cos);
        SEGMENT$SDL_cosf = loader.apply("SDL_cosf");
        HANDLE$SDL_cosf = RawFunctionLoader.link(SEGMENT$SDL_cosf, Descriptors.DESCRIPTOR$SDL_cosf);
        SEGMENT$SDL_exp = loader.apply("SDL_exp");
        HANDLE$SDL_exp = RawFunctionLoader.link(SEGMENT$SDL_exp, Descriptors.DESCRIPTOR$SDL_exp);
        SEGMENT$SDL_expf = loader.apply("SDL_expf");
        HANDLE$SDL_expf = RawFunctionLoader.link(SEGMENT$SDL_expf, Descriptors.DESCRIPTOR$SDL_expf);
        SEGMENT$SDL_fabs = loader.apply("SDL_fabs");
        HANDLE$SDL_fabs = RawFunctionLoader.link(SEGMENT$SDL_fabs, Descriptors.DESCRIPTOR$SDL_fabs);
        SEGMENT$SDL_fabsf = loader.apply("SDL_fabsf");
        HANDLE$SDL_fabsf = RawFunctionLoader.link(SEGMENT$SDL_fabsf, Descriptors.DESCRIPTOR$SDL_fabsf);
        SEGMENT$SDL_floor = loader.apply("SDL_floor");
        HANDLE$SDL_floor = RawFunctionLoader.link(SEGMENT$SDL_floor, Descriptors.DESCRIPTOR$SDL_floor);
        SEGMENT$SDL_floorf = loader.apply("SDL_floorf");
        HANDLE$SDL_floorf = RawFunctionLoader.link(SEGMENT$SDL_floorf, Descriptors.DESCRIPTOR$SDL_floorf);
        SEGMENT$SDL_trunc = loader.apply("SDL_trunc");
        HANDLE$SDL_trunc = RawFunctionLoader.link(SEGMENT$SDL_trunc, Descriptors.DESCRIPTOR$SDL_trunc);
        SEGMENT$SDL_truncf = loader.apply("SDL_truncf");
        HANDLE$SDL_truncf = RawFunctionLoader.link(SEGMENT$SDL_truncf, Descriptors.DESCRIPTOR$SDL_truncf);
        SEGMENT$SDL_fmod = loader.apply("SDL_fmod");
        HANDLE$SDL_fmod = RawFunctionLoader.link(SEGMENT$SDL_fmod, Descriptors.DESCRIPTOR$SDL_fmod);
        SEGMENT$SDL_fmodf = loader.apply("SDL_fmodf");
        HANDLE$SDL_fmodf = RawFunctionLoader.link(SEGMENT$SDL_fmodf, Descriptors.DESCRIPTOR$SDL_fmodf);
        SEGMENT$SDL_isinf = loader.apply("SDL_isinf");
        HANDLE$SDL_isinf = RawFunctionLoader.link(SEGMENT$SDL_isinf, Descriptors.DESCRIPTOR$SDL_isinf);
        SEGMENT$SDL_isinff = loader.apply("SDL_isinff");
        HANDLE$SDL_isinff = RawFunctionLoader.link(SEGMENT$SDL_isinff, Descriptors.DESCRIPTOR$SDL_isinff);
        SEGMENT$SDL_isnan = loader.apply("SDL_isnan");
        HANDLE$SDL_isnan = RawFunctionLoader.link(SEGMENT$SDL_isnan, Descriptors.DESCRIPTOR$SDL_isnan);
        SEGMENT$SDL_isnanf = loader.apply("SDL_isnanf");
        HANDLE$SDL_isnanf = RawFunctionLoader.link(SEGMENT$SDL_isnanf, Descriptors.DESCRIPTOR$SDL_isnanf);
        SEGMENT$SDL_log = loader.apply("SDL_log");
        HANDLE$SDL_log = RawFunctionLoader.link(SEGMENT$SDL_log, Descriptors.DESCRIPTOR$SDL_log);
        SEGMENT$SDL_logf = loader.apply("SDL_logf");
        HANDLE$SDL_logf = RawFunctionLoader.link(SEGMENT$SDL_logf, Descriptors.DESCRIPTOR$SDL_logf);
        SEGMENT$SDL_log10 = loader.apply("SDL_log10");
        HANDLE$SDL_log10 = RawFunctionLoader.link(SEGMENT$SDL_log10, Descriptors.DESCRIPTOR$SDL_log10);
        SEGMENT$SDL_log10f = loader.apply("SDL_log10f");
        HANDLE$SDL_log10f = RawFunctionLoader.link(SEGMENT$SDL_log10f, Descriptors.DESCRIPTOR$SDL_log10f);
        SEGMENT$SDL_modf = loader.apply("SDL_modf");
        HANDLE$SDL_modf = RawFunctionLoader.link(SEGMENT$SDL_modf, Descriptors.DESCRIPTOR$SDL_modf);
        SEGMENT$SDL_modff = loader.apply("SDL_modff");
        HANDLE$SDL_modff = RawFunctionLoader.link(SEGMENT$SDL_modff, Descriptors.DESCRIPTOR$SDL_modff);
        SEGMENT$SDL_pow = loader.apply("SDL_pow");
        HANDLE$SDL_pow = RawFunctionLoader.link(SEGMENT$SDL_pow, Descriptors.DESCRIPTOR$SDL_pow);
        SEGMENT$SDL_powf = loader.apply("SDL_powf");
        HANDLE$SDL_powf = RawFunctionLoader.link(SEGMENT$SDL_powf, Descriptors.DESCRIPTOR$SDL_powf);
        SEGMENT$SDL_round = loader.apply("SDL_round");
        HANDLE$SDL_round = RawFunctionLoader.link(SEGMENT$SDL_round, Descriptors.DESCRIPTOR$SDL_round);
        SEGMENT$SDL_roundf = loader.apply("SDL_roundf");
        HANDLE$SDL_roundf = RawFunctionLoader.link(SEGMENT$SDL_roundf, Descriptors.DESCRIPTOR$SDL_roundf);
        SEGMENT$SDL_lround = loader.apply("SDL_lround");
        HANDLE$SDL_lround = RawFunctionLoader.link(SEGMENT$SDL_lround, Descriptors.DESCRIPTOR$SDL_lround);
        SEGMENT$SDL_lroundf = loader.apply("SDL_lroundf");
        HANDLE$SDL_lroundf = RawFunctionLoader.link(SEGMENT$SDL_lroundf, Descriptors.DESCRIPTOR$SDL_lroundf);
        SEGMENT$SDL_scalbn = loader.apply("SDL_scalbn");
        HANDLE$SDL_scalbn = RawFunctionLoader.link(SEGMENT$SDL_scalbn, Descriptors.DESCRIPTOR$SDL_scalbn);
        SEGMENT$SDL_scalbnf = loader.apply("SDL_scalbnf");
        HANDLE$SDL_scalbnf = RawFunctionLoader.link(SEGMENT$SDL_scalbnf, Descriptors.DESCRIPTOR$SDL_scalbnf);
        SEGMENT$SDL_sin = loader.apply("SDL_sin");
        HANDLE$SDL_sin = RawFunctionLoader.link(SEGMENT$SDL_sin, Descriptors.DESCRIPTOR$SDL_sin);
        SEGMENT$SDL_sinf = loader.apply("SDL_sinf");
        HANDLE$SDL_sinf = RawFunctionLoader.link(SEGMENT$SDL_sinf, Descriptors.DESCRIPTOR$SDL_sinf);
        SEGMENT$SDL_sqrt = loader.apply("SDL_sqrt");
        HANDLE$SDL_sqrt = RawFunctionLoader.link(SEGMENT$SDL_sqrt, Descriptors.DESCRIPTOR$SDL_sqrt);
        SEGMENT$SDL_sqrtf = loader.apply("SDL_sqrtf");
        HANDLE$SDL_sqrtf = RawFunctionLoader.link(SEGMENT$SDL_sqrtf, Descriptors.DESCRIPTOR$SDL_sqrtf);
        SEGMENT$SDL_tan = loader.apply("SDL_tan");
        HANDLE$SDL_tan = RawFunctionLoader.link(SEGMENT$SDL_tan, Descriptors.DESCRIPTOR$SDL_tan);
        SEGMENT$SDL_tanf = loader.apply("SDL_tanf");
        HANDLE$SDL_tanf = RawFunctionLoader.link(SEGMENT$SDL_tanf, Descriptors.DESCRIPTOR$SDL_tanf);
        SEGMENT$SDL_iconv_open = loader.apply("SDL_iconv_open");
        HANDLE$SDL_iconv_open = RawFunctionLoader.link(SEGMENT$SDL_iconv_open, Descriptors.DESCRIPTOR$SDL_iconv_open);
        SEGMENT$SDL_iconv_close = loader.apply("SDL_iconv_close");
        HANDLE$SDL_iconv_close = RawFunctionLoader.link(SEGMENT$SDL_iconv_close, Descriptors.DESCRIPTOR$SDL_iconv_close);
        SEGMENT$SDL_iconv = loader.apply("SDL_iconv");
        HANDLE$SDL_iconv = RawFunctionLoader.link(SEGMENT$SDL_iconv, Descriptors.DESCRIPTOR$SDL_iconv);
        SEGMENT$SDL_iconv_string = loader.apply("SDL_iconv_string");
        HANDLE$SDL_iconv_string = RawFunctionLoader.link(SEGMENT$SDL_iconv_string, Descriptors.DESCRIPTOR$SDL_iconv_string);
        SEGMENT$SDL_AsyncIOFromFile = loader.apply("SDL_AsyncIOFromFile");
        HANDLE$SDL_AsyncIOFromFile = RawFunctionLoader.link(SEGMENT$SDL_AsyncIOFromFile, Descriptors.DESCRIPTOR$SDL_AsyncIOFromFile);
        SEGMENT$SDL_GetAsyncIOSize = loader.apply("SDL_GetAsyncIOSize");
        HANDLE$SDL_GetAsyncIOSize = RawFunctionLoader.link(SEGMENT$SDL_GetAsyncIOSize, Descriptors.DESCRIPTOR$SDL_GetAsyncIOSize);
        SEGMENT$SDL_ReadAsyncIO = loader.apply("SDL_ReadAsyncIO");
        HANDLE$SDL_ReadAsyncIO = RawFunctionLoader.link(SEGMENT$SDL_ReadAsyncIO, Descriptors.DESCRIPTOR$SDL_ReadAsyncIO);
        SEGMENT$SDL_WriteAsyncIO = loader.apply("SDL_WriteAsyncIO");
        HANDLE$SDL_WriteAsyncIO = RawFunctionLoader.link(SEGMENT$SDL_WriteAsyncIO, Descriptors.DESCRIPTOR$SDL_WriteAsyncIO);
        SEGMENT$SDL_CloseAsyncIO = loader.apply("SDL_CloseAsyncIO");
        HANDLE$SDL_CloseAsyncIO = RawFunctionLoader.link(SEGMENT$SDL_CloseAsyncIO, Descriptors.DESCRIPTOR$SDL_CloseAsyncIO);
        SEGMENT$SDL_CreateAsyncIOQueue = loader.apply("SDL_CreateAsyncIOQueue");
        HANDLE$SDL_CreateAsyncIOQueue = RawFunctionLoader.link(SEGMENT$SDL_CreateAsyncIOQueue, Descriptors.DESCRIPTOR$SDL_CreateAsyncIOQueue);
        SEGMENT$SDL_DestroyAsyncIOQueue = loader.apply("SDL_DestroyAsyncIOQueue");
        HANDLE$SDL_DestroyAsyncIOQueue = RawFunctionLoader.link(SEGMENT$SDL_DestroyAsyncIOQueue, Descriptors.DESCRIPTOR$SDL_DestroyAsyncIOQueue);
        SEGMENT$SDL_GetAsyncIOResult = loader.apply("SDL_GetAsyncIOResult");
        HANDLE$SDL_GetAsyncIOResult = RawFunctionLoader.link(SEGMENT$SDL_GetAsyncIOResult, Descriptors.DESCRIPTOR$SDL_GetAsyncIOResult);
        SEGMENT$SDL_WaitAsyncIOResult = loader.apply("SDL_WaitAsyncIOResult");
        HANDLE$SDL_WaitAsyncIOResult = RawFunctionLoader.link(SEGMENT$SDL_WaitAsyncIOResult, Descriptors.DESCRIPTOR$SDL_WaitAsyncIOResult);
        SEGMENT$SDL_SignalAsyncIOQueue = loader.apply("SDL_SignalAsyncIOQueue");
        HANDLE$SDL_SignalAsyncIOQueue = RawFunctionLoader.link(SEGMENT$SDL_SignalAsyncIOQueue, Descriptors.DESCRIPTOR$SDL_SignalAsyncIOQueue);
        SEGMENT$SDL_LoadFileAsync = loader.apply("SDL_LoadFileAsync");
        HANDLE$SDL_LoadFileAsync = RawFunctionLoader.link(SEGMENT$SDL_LoadFileAsync, Descriptors.DESCRIPTOR$SDL_LoadFileAsync);
        SEGMENT$SDL_TryLockSpinlock = loader.apply("SDL_TryLockSpinlock");
        HANDLE$SDL_TryLockSpinlock = RawFunctionLoader.link(SEGMENT$SDL_TryLockSpinlock, Descriptors.DESCRIPTOR$SDL_TryLockSpinlock);
        SEGMENT$SDL_LockSpinlock = loader.apply("SDL_LockSpinlock");
        HANDLE$SDL_LockSpinlock = RawFunctionLoader.link(SEGMENT$SDL_LockSpinlock, Descriptors.DESCRIPTOR$SDL_LockSpinlock);
        SEGMENT$SDL_UnlockSpinlock = loader.apply("SDL_UnlockSpinlock");
        HANDLE$SDL_UnlockSpinlock = RawFunctionLoader.link(SEGMENT$SDL_UnlockSpinlock, Descriptors.DESCRIPTOR$SDL_UnlockSpinlock);
        SEGMENT$SDL_MemoryBarrierReleaseFunction = loader.apply("SDL_MemoryBarrierReleaseFunction");
        HANDLE$SDL_MemoryBarrierReleaseFunction = RawFunctionLoader.link(SEGMENT$SDL_MemoryBarrierReleaseFunction, Descriptors.DESCRIPTOR$SDL_MemoryBarrierReleaseFunction);
        SEGMENT$SDL_MemoryBarrierAcquireFunction = loader.apply("SDL_MemoryBarrierAcquireFunction");
        HANDLE$SDL_MemoryBarrierAcquireFunction = RawFunctionLoader.link(SEGMENT$SDL_MemoryBarrierAcquireFunction, Descriptors.DESCRIPTOR$SDL_MemoryBarrierAcquireFunction);
        SEGMENT$SDL_CompareAndSwapAtomicInt = loader.apply("SDL_CompareAndSwapAtomicInt");
        HANDLE$SDL_CompareAndSwapAtomicInt = RawFunctionLoader.link(SEGMENT$SDL_CompareAndSwapAtomicInt, Descriptors.DESCRIPTOR$SDL_CompareAndSwapAtomicInt);
        SEGMENT$SDL_SetAtomicInt = loader.apply("SDL_SetAtomicInt");
        HANDLE$SDL_SetAtomicInt = RawFunctionLoader.link(SEGMENT$SDL_SetAtomicInt, Descriptors.DESCRIPTOR$SDL_SetAtomicInt);
        SEGMENT$SDL_GetAtomicInt = loader.apply("SDL_GetAtomicInt");
        HANDLE$SDL_GetAtomicInt = RawFunctionLoader.link(SEGMENT$SDL_GetAtomicInt, Descriptors.DESCRIPTOR$SDL_GetAtomicInt);
        SEGMENT$SDL_AddAtomicInt = loader.apply("SDL_AddAtomicInt");
        HANDLE$SDL_AddAtomicInt = RawFunctionLoader.link(SEGMENT$SDL_AddAtomicInt, Descriptors.DESCRIPTOR$SDL_AddAtomicInt);
        SEGMENT$SDL_CompareAndSwapAtomicU32 = loader.apply("SDL_CompareAndSwapAtomicU32");
        HANDLE$SDL_CompareAndSwapAtomicU32 = RawFunctionLoader.link(SEGMENT$SDL_CompareAndSwapAtomicU32, Descriptors.DESCRIPTOR$SDL_CompareAndSwapAtomicU32);
        SEGMENT$SDL_SetAtomicU32 = loader.apply("SDL_SetAtomicU32");
        HANDLE$SDL_SetAtomicU32 = RawFunctionLoader.link(SEGMENT$SDL_SetAtomicU32, Descriptors.DESCRIPTOR$SDL_SetAtomicU32);
        SEGMENT$SDL_GetAtomicU32 = loader.apply("SDL_GetAtomicU32");
        HANDLE$SDL_GetAtomicU32 = RawFunctionLoader.link(SEGMENT$SDL_GetAtomicU32, Descriptors.DESCRIPTOR$SDL_GetAtomicU32);
        SEGMENT$SDL_CompareAndSwapAtomicPointer = loader.apply("SDL_CompareAndSwapAtomicPointer");
        HANDLE$SDL_CompareAndSwapAtomicPointer = RawFunctionLoader.link(SEGMENT$SDL_CompareAndSwapAtomicPointer, Descriptors.DESCRIPTOR$SDL_CompareAndSwapAtomicPointer);
        SEGMENT$SDL_SetAtomicPointer = loader.apply("SDL_SetAtomicPointer");
        HANDLE$SDL_SetAtomicPointer = RawFunctionLoader.link(SEGMENT$SDL_SetAtomicPointer, Descriptors.DESCRIPTOR$SDL_SetAtomicPointer);
        SEGMENT$SDL_GetAtomicPointer = loader.apply("SDL_GetAtomicPointer");
        HANDLE$SDL_GetAtomicPointer = RawFunctionLoader.link(SEGMENT$SDL_GetAtomicPointer, Descriptors.DESCRIPTOR$SDL_GetAtomicPointer);
        SEGMENT$SDL_GetNumAudioDrivers = loader.apply("SDL_GetNumAudioDrivers");
        HANDLE$SDL_GetNumAudioDrivers = RawFunctionLoader.link(SEGMENT$SDL_GetNumAudioDrivers, Descriptors.DESCRIPTOR$SDL_GetNumAudioDrivers);
        SEGMENT$SDL_GetAudioDriver = loader.apply("SDL_GetAudioDriver");
        HANDLE$SDL_GetAudioDriver = RawFunctionLoader.link(SEGMENT$SDL_GetAudioDriver, Descriptors.DESCRIPTOR$SDL_GetAudioDriver);
        SEGMENT$SDL_GetCurrentAudioDriver = loader.apply("SDL_GetCurrentAudioDriver");
        HANDLE$SDL_GetCurrentAudioDriver = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentAudioDriver, Descriptors.DESCRIPTOR$SDL_GetCurrentAudioDriver);
        SEGMENT$SDL_GetAudioPlaybackDevices = loader.apply("SDL_GetAudioPlaybackDevices");
        HANDLE$SDL_GetAudioPlaybackDevices = RawFunctionLoader.link(SEGMENT$SDL_GetAudioPlaybackDevices, Descriptors.DESCRIPTOR$SDL_GetAudioPlaybackDevices);
        SEGMENT$SDL_GetAudioRecordingDevices = loader.apply("SDL_GetAudioRecordingDevices");
        HANDLE$SDL_GetAudioRecordingDevices = RawFunctionLoader.link(SEGMENT$SDL_GetAudioRecordingDevices, Descriptors.DESCRIPTOR$SDL_GetAudioRecordingDevices);
        SEGMENT$SDL_GetAudioDeviceName = loader.apply("SDL_GetAudioDeviceName");
        HANDLE$SDL_GetAudioDeviceName = RawFunctionLoader.link(SEGMENT$SDL_GetAudioDeviceName, Descriptors.DESCRIPTOR$SDL_GetAudioDeviceName);
        SEGMENT$SDL_GetAudioDeviceFormat = loader.apply("SDL_GetAudioDeviceFormat");
        HANDLE$SDL_GetAudioDeviceFormat = RawFunctionLoader.link(SEGMENT$SDL_GetAudioDeviceFormat, Descriptors.DESCRIPTOR$SDL_GetAudioDeviceFormat);
        SEGMENT$SDL_GetAudioDeviceChannelMap = loader.apply("SDL_GetAudioDeviceChannelMap");
        HANDLE$SDL_GetAudioDeviceChannelMap = RawFunctionLoader.link(SEGMENT$SDL_GetAudioDeviceChannelMap, Descriptors.DESCRIPTOR$SDL_GetAudioDeviceChannelMap);
        SEGMENT$SDL_OpenAudioDevice = loader.apply("SDL_OpenAudioDevice");
        HANDLE$SDL_OpenAudioDevice = RawFunctionLoader.link(SEGMENT$SDL_OpenAudioDevice, Descriptors.DESCRIPTOR$SDL_OpenAudioDevice);
        SEGMENT$SDL_IsAudioDevicePhysical = loader.apply("SDL_IsAudioDevicePhysical");
        HANDLE$SDL_IsAudioDevicePhysical = RawFunctionLoader.link(SEGMENT$SDL_IsAudioDevicePhysical, Descriptors.DESCRIPTOR$SDL_IsAudioDevicePhysical);
        SEGMENT$SDL_IsAudioDevicePlayback = loader.apply("SDL_IsAudioDevicePlayback");
        HANDLE$SDL_IsAudioDevicePlayback = RawFunctionLoader.link(SEGMENT$SDL_IsAudioDevicePlayback, Descriptors.DESCRIPTOR$SDL_IsAudioDevicePlayback);
        SEGMENT$SDL_PauseAudioDevice = loader.apply("SDL_PauseAudioDevice");
        HANDLE$SDL_PauseAudioDevice = RawFunctionLoader.link(SEGMENT$SDL_PauseAudioDevice, Descriptors.DESCRIPTOR$SDL_PauseAudioDevice);
        SEGMENT$SDL_ResumeAudioDevice = loader.apply("SDL_ResumeAudioDevice");
        HANDLE$SDL_ResumeAudioDevice = RawFunctionLoader.link(SEGMENT$SDL_ResumeAudioDevice, Descriptors.DESCRIPTOR$SDL_ResumeAudioDevice);
        SEGMENT$SDL_AudioDevicePaused = loader.apply("SDL_AudioDevicePaused");
        HANDLE$SDL_AudioDevicePaused = RawFunctionLoader.link(SEGMENT$SDL_AudioDevicePaused, Descriptors.DESCRIPTOR$SDL_AudioDevicePaused);
        SEGMENT$SDL_GetAudioDeviceGain = loader.apply("SDL_GetAudioDeviceGain");
        HANDLE$SDL_GetAudioDeviceGain = RawFunctionLoader.link(SEGMENT$SDL_GetAudioDeviceGain, Descriptors.DESCRIPTOR$SDL_GetAudioDeviceGain);
        SEGMENT$SDL_SetAudioDeviceGain = loader.apply("SDL_SetAudioDeviceGain");
        HANDLE$SDL_SetAudioDeviceGain = RawFunctionLoader.link(SEGMENT$SDL_SetAudioDeviceGain, Descriptors.DESCRIPTOR$SDL_SetAudioDeviceGain);
        SEGMENT$SDL_CloseAudioDevice = loader.apply("SDL_CloseAudioDevice");
        HANDLE$SDL_CloseAudioDevice = RawFunctionLoader.link(SEGMENT$SDL_CloseAudioDevice, Descriptors.DESCRIPTOR$SDL_CloseAudioDevice);
        SEGMENT$SDL_BindAudioStreams = loader.apply("SDL_BindAudioStreams");
        HANDLE$SDL_BindAudioStreams = RawFunctionLoader.link(SEGMENT$SDL_BindAudioStreams, Descriptors.DESCRIPTOR$SDL_BindAudioStreams);
        SEGMENT$SDL_BindAudioStream = loader.apply("SDL_BindAudioStream");
        HANDLE$SDL_BindAudioStream = RawFunctionLoader.link(SEGMENT$SDL_BindAudioStream, Descriptors.DESCRIPTOR$SDL_BindAudioStream);
        SEGMENT$SDL_UnbindAudioStreams = loader.apply("SDL_UnbindAudioStreams");
        HANDLE$SDL_UnbindAudioStreams = RawFunctionLoader.link(SEGMENT$SDL_UnbindAudioStreams, Descriptors.DESCRIPTOR$SDL_UnbindAudioStreams);
        SEGMENT$SDL_UnbindAudioStream = loader.apply("SDL_UnbindAudioStream");
        HANDLE$SDL_UnbindAudioStream = RawFunctionLoader.link(SEGMENT$SDL_UnbindAudioStream, Descriptors.DESCRIPTOR$SDL_UnbindAudioStream);
        SEGMENT$SDL_GetAudioStreamDevice = loader.apply("SDL_GetAudioStreamDevice");
        HANDLE$SDL_GetAudioStreamDevice = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamDevice, Descriptors.DESCRIPTOR$SDL_GetAudioStreamDevice);
        SEGMENT$SDL_CreateAudioStream = loader.apply("SDL_CreateAudioStream");
        HANDLE$SDL_CreateAudioStream = RawFunctionLoader.link(SEGMENT$SDL_CreateAudioStream, Descriptors.DESCRIPTOR$SDL_CreateAudioStream);
        SEGMENT$SDL_GetAudioStreamProperties = loader.apply("SDL_GetAudioStreamProperties");
        HANDLE$SDL_GetAudioStreamProperties = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamProperties, Descriptors.DESCRIPTOR$SDL_GetAudioStreamProperties);
        SEGMENT$SDL_GetAudioStreamFormat = loader.apply("SDL_GetAudioStreamFormat");
        HANDLE$SDL_GetAudioStreamFormat = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamFormat, Descriptors.DESCRIPTOR$SDL_GetAudioStreamFormat);
        SEGMENT$SDL_SetAudioStreamFormat = loader.apply("SDL_SetAudioStreamFormat");
        HANDLE$SDL_SetAudioStreamFormat = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamFormat, Descriptors.DESCRIPTOR$SDL_SetAudioStreamFormat);
        SEGMENT$SDL_GetAudioStreamFrequencyRatio = loader.apply("SDL_GetAudioStreamFrequencyRatio");
        HANDLE$SDL_GetAudioStreamFrequencyRatio = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamFrequencyRatio, Descriptors.DESCRIPTOR$SDL_GetAudioStreamFrequencyRatio);
        SEGMENT$SDL_SetAudioStreamFrequencyRatio = loader.apply("SDL_SetAudioStreamFrequencyRatio");
        HANDLE$SDL_SetAudioStreamFrequencyRatio = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamFrequencyRatio, Descriptors.DESCRIPTOR$SDL_SetAudioStreamFrequencyRatio);
        SEGMENT$SDL_GetAudioStreamGain = loader.apply("SDL_GetAudioStreamGain");
        HANDLE$SDL_GetAudioStreamGain = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamGain, Descriptors.DESCRIPTOR$SDL_GetAudioStreamGain);
        SEGMENT$SDL_SetAudioStreamGain = loader.apply("SDL_SetAudioStreamGain");
        HANDLE$SDL_SetAudioStreamGain = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamGain, Descriptors.DESCRIPTOR$SDL_SetAudioStreamGain);
        SEGMENT$SDL_GetAudioStreamInputChannelMap = loader.apply("SDL_GetAudioStreamInputChannelMap");
        HANDLE$SDL_GetAudioStreamInputChannelMap = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamInputChannelMap, Descriptors.DESCRIPTOR$SDL_GetAudioStreamInputChannelMap);
        SEGMENT$SDL_GetAudioStreamOutputChannelMap = loader.apply("SDL_GetAudioStreamOutputChannelMap");
        HANDLE$SDL_GetAudioStreamOutputChannelMap = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamOutputChannelMap, Descriptors.DESCRIPTOR$SDL_GetAudioStreamOutputChannelMap);
        SEGMENT$SDL_SetAudioStreamInputChannelMap = loader.apply("SDL_SetAudioStreamInputChannelMap");
        HANDLE$SDL_SetAudioStreamInputChannelMap = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamInputChannelMap, Descriptors.DESCRIPTOR$SDL_SetAudioStreamInputChannelMap);
        SEGMENT$SDL_SetAudioStreamOutputChannelMap = loader.apply("SDL_SetAudioStreamOutputChannelMap");
        HANDLE$SDL_SetAudioStreamOutputChannelMap = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamOutputChannelMap, Descriptors.DESCRIPTOR$SDL_SetAudioStreamOutputChannelMap);
        SEGMENT$SDL_PutAudioStreamData = loader.apply("SDL_PutAudioStreamData");
        HANDLE$SDL_PutAudioStreamData = RawFunctionLoader.link(SEGMENT$SDL_PutAudioStreamData, Descriptors.DESCRIPTOR$SDL_PutAudioStreamData);
        SEGMENT$SDL_GetAudioStreamData = loader.apply("SDL_GetAudioStreamData");
        HANDLE$SDL_GetAudioStreamData = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamData, Descriptors.DESCRIPTOR$SDL_GetAudioStreamData);
        SEGMENT$SDL_GetAudioStreamAvailable = loader.apply("SDL_GetAudioStreamAvailable");
        HANDLE$SDL_GetAudioStreamAvailable = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamAvailable, Descriptors.DESCRIPTOR$SDL_GetAudioStreamAvailable);
        SEGMENT$SDL_GetAudioStreamQueued = loader.apply("SDL_GetAudioStreamQueued");
        HANDLE$SDL_GetAudioStreamQueued = RawFunctionLoader.link(SEGMENT$SDL_GetAudioStreamQueued, Descriptors.DESCRIPTOR$SDL_GetAudioStreamQueued);
        SEGMENT$SDL_FlushAudioStream = loader.apply("SDL_FlushAudioStream");
        HANDLE$SDL_FlushAudioStream = RawFunctionLoader.link(SEGMENT$SDL_FlushAudioStream, Descriptors.DESCRIPTOR$SDL_FlushAudioStream);
        SEGMENT$SDL_ClearAudioStream = loader.apply("SDL_ClearAudioStream");
        HANDLE$SDL_ClearAudioStream = RawFunctionLoader.link(SEGMENT$SDL_ClearAudioStream, Descriptors.DESCRIPTOR$SDL_ClearAudioStream);
        SEGMENT$SDL_PauseAudioStreamDevice = loader.apply("SDL_PauseAudioStreamDevice");
        HANDLE$SDL_PauseAudioStreamDevice = RawFunctionLoader.link(SEGMENT$SDL_PauseAudioStreamDevice, Descriptors.DESCRIPTOR$SDL_PauseAudioStreamDevice);
        SEGMENT$SDL_ResumeAudioStreamDevice = loader.apply("SDL_ResumeAudioStreamDevice");
        HANDLE$SDL_ResumeAudioStreamDevice = RawFunctionLoader.link(SEGMENT$SDL_ResumeAudioStreamDevice, Descriptors.DESCRIPTOR$SDL_ResumeAudioStreamDevice);
        SEGMENT$SDL_AudioStreamDevicePaused = loader.apply("SDL_AudioStreamDevicePaused");
        HANDLE$SDL_AudioStreamDevicePaused = RawFunctionLoader.link(SEGMENT$SDL_AudioStreamDevicePaused, Descriptors.DESCRIPTOR$SDL_AudioStreamDevicePaused);
        SEGMENT$SDL_LockAudioStream = loader.apply("SDL_LockAudioStream");
        HANDLE$SDL_LockAudioStream = RawFunctionLoader.link(SEGMENT$SDL_LockAudioStream, Descriptors.DESCRIPTOR$SDL_LockAudioStream);
        SEGMENT$SDL_UnlockAudioStream = loader.apply("SDL_UnlockAudioStream");
        HANDLE$SDL_UnlockAudioStream = RawFunctionLoader.link(SEGMENT$SDL_UnlockAudioStream, Descriptors.DESCRIPTOR$SDL_UnlockAudioStream);
        SEGMENT$SDL_SetAudioStreamGetCallback = loader.apply("SDL_SetAudioStreamGetCallback");
        HANDLE$SDL_SetAudioStreamGetCallback = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamGetCallback, Descriptors.DESCRIPTOR$SDL_SetAudioStreamGetCallback);
        SEGMENT$SDL_SetAudioStreamPutCallback = loader.apply("SDL_SetAudioStreamPutCallback");
        HANDLE$SDL_SetAudioStreamPutCallback = RawFunctionLoader.link(SEGMENT$SDL_SetAudioStreamPutCallback, Descriptors.DESCRIPTOR$SDL_SetAudioStreamPutCallback);
        SEGMENT$SDL_DestroyAudioStream = loader.apply("SDL_DestroyAudioStream");
        HANDLE$SDL_DestroyAudioStream = RawFunctionLoader.link(SEGMENT$SDL_DestroyAudioStream, Descriptors.DESCRIPTOR$SDL_DestroyAudioStream);
        SEGMENT$SDL_OpenAudioDeviceStream = loader.apply("SDL_OpenAudioDeviceStream");
        HANDLE$SDL_OpenAudioDeviceStream = RawFunctionLoader.link(SEGMENT$SDL_OpenAudioDeviceStream, Descriptors.DESCRIPTOR$SDL_OpenAudioDeviceStream);
        SEGMENT$SDL_SetAudioPostmixCallback = loader.apply("SDL_SetAudioPostmixCallback");
        HANDLE$SDL_SetAudioPostmixCallback = RawFunctionLoader.link(SEGMENT$SDL_SetAudioPostmixCallback, Descriptors.DESCRIPTOR$SDL_SetAudioPostmixCallback);
        SEGMENT$SDL_LoadWAV_IO = loader.apply("SDL_LoadWAV_IO");
        HANDLE$SDL_LoadWAV_IO = RawFunctionLoader.link(SEGMENT$SDL_LoadWAV_IO, Descriptors.DESCRIPTOR$SDL_LoadWAV_IO);
        SEGMENT$SDL_LoadWAV = loader.apply("SDL_LoadWAV");
        HANDLE$SDL_LoadWAV = RawFunctionLoader.link(SEGMENT$SDL_LoadWAV, Descriptors.DESCRIPTOR$SDL_LoadWAV);
        SEGMENT$SDL_MixAudio = loader.apply("SDL_MixAudio");
        HANDLE$SDL_MixAudio = RawFunctionLoader.link(SEGMENT$SDL_MixAudio, Descriptors.DESCRIPTOR$SDL_MixAudio);
        SEGMENT$SDL_ConvertAudioSamples = loader.apply("SDL_ConvertAudioSamples");
        HANDLE$SDL_ConvertAudioSamples = RawFunctionLoader.link(SEGMENT$SDL_ConvertAudioSamples, Descriptors.DESCRIPTOR$SDL_ConvertAudioSamples);
        SEGMENT$SDL_GetAudioFormatName = loader.apply("SDL_GetAudioFormatName");
        HANDLE$SDL_GetAudioFormatName = RawFunctionLoader.link(SEGMENT$SDL_GetAudioFormatName, Descriptors.DESCRIPTOR$SDL_GetAudioFormatName);
        SEGMENT$SDL_GetSilenceValueForFormat = loader.apply("SDL_GetSilenceValueForFormat");
        HANDLE$SDL_GetSilenceValueForFormat = RawFunctionLoader.link(SEGMENT$SDL_GetSilenceValueForFormat, Descriptors.DESCRIPTOR$SDL_GetSilenceValueForFormat);
        SEGMENT$SDL_ComposeCustomBlendMode = loader.apply("SDL_ComposeCustomBlendMode");
        HANDLE$SDL_ComposeCustomBlendMode = RawFunctionLoader.link(SEGMENT$SDL_ComposeCustomBlendMode, Descriptors.DESCRIPTOR$SDL_ComposeCustomBlendMode);
        SEGMENT$SDL_GetNumCameraDrivers = loader.apply("SDL_GetNumCameraDrivers");
        HANDLE$SDL_GetNumCameraDrivers = RawFunctionLoader.link(SEGMENT$SDL_GetNumCameraDrivers, Descriptors.DESCRIPTOR$SDL_GetNumCameraDrivers);
        SEGMENT$SDL_GetCameraDriver = loader.apply("SDL_GetCameraDriver");
        HANDLE$SDL_GetCameraDriver = RawFunctionLoader.link(SEGMENT$SDL_GetCameraDriver, Descriptors.DESCRIPTOR$SDL_GetCameraDriver);
        SEGMENT$SDL_GetCurrentCameraDriver = loader.apply("SDL_GetCurrentCameraDriver");
        HANDLE$SDL_GetCurrentCameraDriver = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentCameraDriver, Descriptors.DESCRIPTOR$SDL_GetCurrentCameraDriver);
        SEGMENT$SDL_GetCameras = loader.apply("SDL_GetCameras");
        HANDLE$SDL_GetCameras = RawFunctionLoader.link(SEGMENT$SDL_GetCameras, Descriptors.DESCRIPTOR$SDL_GetCameras);
        SEGMENT$SDL_GetCameraSupportedFormats = loader.apply("SDL_GetCameraSupportedFormats");
        HANDLE$SDL_GetCameraSupportedFormats = RawFunctionLoader.link(SEGMENT$SDL_GetCameraSupportedFormats, Descriptors.DESCRIPTOR$SDL_GetCameraSupportedFormats);
        SEGMENT$SDL_GetCameraName = loader.apply("SDL_GetCameraName");
        HANDLE$SDL_GetCameraName = RawFunctionLoader.link(SEGMENT$SDL_GetCameraName, Descriptors.DESCRIPTOR$SDL_GetCameraName);
        SEGMENT$SDL_GetCameraPosition = loader.apply("SDL_GetCameraPosition");
        HANDLE$SDL_GetCameraPosition = RawFunctionLoader.link(SEGMENT$SDL_GetCameraPosition, Descriptors.DESCRIPTOR$SDL_GetCameraPosition);
        SEGMENT$SDL_OpenCamera = loader.apply("SDL_OpenCamera");
        HANDLE$SDL_OpenCamera = RawFunctionLoader.link(SEGMENT$SDL_OpenCamera, Descriptors.DESCRIPTOR$SDL_OpenCamera);
        SEGMENT$SDL_GetCameraPermissionState = loader.apply("SDL_GetCameraPermissionState");
        HANDLE$SDL_GetCameraPermissionState = RawFunctionLoader.link(SEGMENT$SDL_GetCameraPermissionState, Descriptors.DESCRIPTOR$SDL_GetCameraPermissionState);
        SEGMENT$SDL_GetCameraID = loader.apply("SDL_GetCameraID");
        HANDLE$SDL_GetCameraID = RawFunctionLoader.link(SEGMENT$SDL_GetCameraID, Descriptors.DESCRIPTOR$SDL_GetCameraID);
        SEGMENT$SDL_GetCameraProperties = loader.apply("SDL_GetCameraProperties");
        HANDLE$SDL_GetCameraProperties = RawFunctionLoader.link(SEGMENT$SDL_GetCameraProperties, Descriptors.DESCRIPTOR$SDL_GetCameraProperties);
        SEGMENT$SDL_GetCameraFormat = loader.apply("SDL_GetCameraFormat");
        HANDLE$SDL_GetCameraFormat = RawFunctionLoader.link(SEGMENT$SDL_GetCameraFormat, Descriptors.DESCRIPTOR$SDL_GetCameraFormat);
        SEGMENT$SDL_AcquireCameraFrame = loader.apply("SDL_AcquireCameraFrame");
        HANDLE$SDL_AcquireCameraFrame = RawFunctionLoader.link(SEGMENT$SDL_AcquireCameraFrame, Descriptors.DESCRIPTOR$SDL_AcquireCameraFrame);
        SEGMENT$SDL_ReleaseCameraFrame = loader.apply("SDL_ReleaseCameraFrame");
        HANDLE$SDL_ReleaseCameraFrame = RawFunctionLoader.link(SEGMENT$SDL_ReleaseCameraFrame, Descriptors.DESCRIPTOR$SDL_ReleaseCameraFrame);
        SEGMENT$SDL_CloseCamera = loader.apply("SDL_CloseCamera");
        HANDLE$SDL_CloseCamera = RawFunctionLoader.link(SEGMENT$SDL_CloseCamera, Descriptors.DESCRIPTOR$SDL_CloseCamera);
        SEGMENT$SDL_SetClipboardText = loader.apply("SDL_SetClipboardText");
        HANDLE$SDL_SetClipboardText = RawFunctionLoader.link(SEGMENT$SDL_SetClipboardText, Descriptors.DESCRIPTOR$SDL_SetClipboardText);
        SEGMENT$SDL_GetClipboardText = loader.apply("SDL_GetClipboardText");
        HANDLE$SDL_GetClipboardText = RawFunctionLoader.link(SEGMENT$SDL_GetClipboardText, Descriptors.DESCRIPTOR$SDL_GetClipboardText);
        SEGMENT$SDL_HasClipboardText = loader.apply("SDL_HasClipboardText");
        HANDLE$SDL_HasClipboardText = RawFunctionLoader.link(SEGMENT$SDL_HasClipboardText, Descriptors.DESCRIPTOR$SDL_HasClipboardText);
        SEGMENT$SDL_SetPrimarySelectionText = loader.apply("SDL_SetPrimarySelectionText");
        HANDLE$SDL_SetPrimarySelectionText = RawFunctionLoader.link(SEGMENT$SDL_SetPrimarySelectionText, Descriptors.DESCRIPTOR$SDL_SetPrimarySelectionText);
        SEGMENT$SDL_GetPrimarySelectionText = loader.apply("SDL_GetPrimarySelectionText");
        HANDLE$SDL_GetPrimarySelectionText = RawFunctionLoader.link(SEGMENT$SDL_GetPrimarySelectionText, Descriptors.DESCRIPTOR$SDL_GetPrimarySelectionText);
        SEGMENT$SDL_HasPrimarySelectionText = loader.apply("SDL_HasPrimarySelectionText");
        HANDLE$SDL_HasPrimarySelectionText = RawFunctionLoader.link(SEGMENT$SDL_HasPrimarySelectionText, Descriptors.DESCRIPTOR$SDL_HasPrimarySelectionText);
        SEGMENT$SDL_SetClipboardData = loader.apply("SDL_SetClipboardData");
        HANDLE$SDL_SetClipboardData = RawFunctionLoader.link(SEGMENT$SDL_SetClipboardData, Descriptors.DESCRIPTOR$SDL_SetClipboardData);
        SEGMENT$SDL_ClearClipboardData = loader.apply("SDL_ClearClipboardData");
        HANDLE$SDL_ClearClipboardData = RawFunctionLoader.link(SEGMENT$SDL_ClearClipboardData, Descriptors.DESCRIPTOR$SDL_ClearClipboardData);
        SEGMENT$SDL_GetClipboardData = loader.apply("SDL_GetClipboardData");
        HANDLE$SDL_GetClipboardData = RawFunctionLoader.link(SEGMENT$SDL_GetClipboardData, Descriptors.DESCRIPTOR$SDL_GetClipboardData);
        SEGMENT$SDL_HasClipboardData = loader.apply("SDL_HasClipboardData");
        HANDLE$SDL_HasClipboardData = RawFunctionLoader.link(SEGMENT$SDL_HasClipboardData, Descriptors.DESCRIPTOR$SDL_HasClipboardData);
        SEGMENT$SDL_GetClipboardMimeTypes = loader.apply("SDL_GetClipboardMimeTypes");
        HANDLE$SDL_GetClipboardMimeTypes = RawFunctionLoader.link(SEGMENT$SDL_GetClipboardMimeTypes, Descriptors.DESCRIPTOR$SDL_GetClipboardMimeTypes);
        SEGMENT$SDL_GetNumLogicalCPUCores = loader.apply("SDL_GetNumLogicalCPUCores");
        HANDLE$SDL_GetNumLogicalCPUCores = RawFunctionLoader.link(SEGMENT$SDL_GetNumLogicalCPUCores, Descriptors.DESCRIPTOR$SDL_GetNumLogicalCPUCores);
        SEGMENT$SDL_GetCPUCacheLineSize = loader.apply("SDL_GetCPUCacheLineSize");
        HANDLE$SDL_GetCPUCacheLineSize = RawFunctionLoader.link(SEGMENT$SDL_GetCPUCacheLineSize, Descriptors.DESCRIPTOR$SDL_GetCPUCacheLineSize);
        SEGMENT$SDL_HasAltiVec = loader.apply("SDL_HasAltiVec");
        HANDLE$SDL_HasAltiVec = RawFunctionLoader.link(SEGMENT$SDL_HasAltiVec, Descriptors.DESCRIPTOR$SDL_HasAltiVec);
        SEGMENT$SDL_HasMMX = loader.apply("SDL_HasMMX");
        HANDLE$SDL_HasMMX = RawFunctionLoader.link(SEGMENT$SDL_HasMMX, Descriptors.DESCRIPTOR$SDL_HasMMX);
        SEGMENT$SDL_HasSSE = loader.apply("SDL_HasSSE");
        HANDLE$SDL_HasSSE = RawFunctionLoader.link(SEGMENT$SDL_HasSSE, Descriptors.DESCRIPTOR$SDL_HasSSE);
        SEGMENT$SDL_HasSSE2 = loader.apply("SDL_HasSSE2");
        HANDLE$SDL_HasSSE2 = RawFunctionLoader.link(SEGMENT$SDL_HasSSE2, Descriptors.DESCRIPTOR$SDL_HasSSE2);
        SEGMENT$SDL_HasSSE3 = loader.apply("SDL_HasSSE3");
        HANDLE$SDL_HasSSE3 = RawFunctionLoader.link(SEGMENT$SDL_HasSSE3, Descriptors.DESCRIPTOR$SDL_HasSSE3);
        SEGMENT$SDL_HasSSE41 = loader.apply("SDL_HasSSE41");
        HANDLE$SDL_HasSSE41 = RawFunctionLoader.link(SEGMENT$SDL_HasSSE41, Descriptors.DESCRIPTOR$SDL_HasSSE41);
        SEGMENT$SDL_HasSSE42 = loader.apply("SDL_HasSSE42");
        HANDLE$SDL_HasSSE42 = RawFunctionLoader.link(SEGMENT$SDL_HasSSE42, Descriptors.DESCRIPTOR$SDL_HasSSE42);
        SEGMENT$SDL_HasAVX = loader.apply("SDL_HasAVX");
        HANDLE$SDL_HasAVX = RawFunctionLoader.link(SEGMENT$SDL_HasAVX, Descriptors.DESCRIPTOR$SDL_HasAVX);
        SEGMENT$SDL_HasAVX2 = loader.apply("SDL_HasAVX2");
        HANDLE$SDL_HasAVX2 = RawFunctionLoader.link(SEGMENT$SDL_HasAVX2, Descriptors.DESCRIPTOR$SDL_HasAVX2);
        SEGMENT$SDL_HasAVX512F = loader.apply("SDL_HasAVX512F");
        HANDLE$SDL_HasAVX512F = RawFunctionLoader.link(SEGMENT$SDL_HasAVX512F, Descriptors.DESCRIPTOR$SDL_HasAVX512F);
        SEGMENT$SDL_HasARMSIMD = loader.apply("SDL_HasARMSIMD");
        HANDLE$SDL_HasARMSIMD = RawFunctionLoader.link(SEGMENT$SDL_HasARMSIMD, Descriptors.DESCRIPTOR$SDL_HasARMSIMD);
        SEGMENT$SDL_HasNEON = loader.apply("SDL_HasNEON");
        HANDLE$SDL_HasNEON = RawFunctionLoader.link(SEGMENT$SDL_HasNEON, Descriptors.DESCRIPTOR$SDL_HasNEON);
        SEGMENT$SDL_HasLSX = loader.apply("SDL_HasLSX");
        HANDLE$SDL_HasLSX = RawFunctionLoader.link(SEGMENT$SDL_HasLSX, Descriptors.DESCRIPTOR$SDL_HasLSX);
        SEGMENT$SDL_HasLASX = loader.apply("SDL_HasLASX");
        HANDLE$SDL_HasLASX = RawFunctionLoader.link(SEGMENT$SDL_HasLASX, Descriptors.DESCRIPTOR$SDL_HasLASX);
        SEGMENT$SDL_GetSystemRAM = loader.apply("SDL_GetSystemRAM");
        HANDLE$SDL_GetSystemRAM = RawFunctionLoader.link(SEGMENT$SDL_GetSystemRAM, Descriptors.DESCRIPTOR$SDL_GetSystemRAM);
        SEGMENT$SDL_GetSIMDAlignment = loader.apply("SDL_GetSIMDAlignment");
        HANDLE$SDL_GetSIMDAlignment = RawFunctionLoader.link(SEGMENT$SDL_GetSIMDAlignment, Descriptors.DESCRIPTOR$SDL_GetSIMDAlignment);
        SEGMENT$SDL_ShowOpenFileDialog = loader.apply("SDL_ShowOpenFileDialog");
        HANDLE$SDL_ShowOpenFileDialog = RawFunctionLoader.link(SEGMENT$SDL_ShowOpenFileDialog, Descriptors.DESCRIPTOR$SDL_ShowOpenFileDialog);
        SEGMENT$SDL_ShowSaveFileDialog = loader.apply("SDL_ShowSaveFileDialog");
        HANDLE$SDL_ShowSaveFileDialog = RawFunctionLoader.link(SEGMENT$SDL_ShowSaveFileDialog, Descriptors.DESCRIPTOR$SDL_ShowSaveFileDialog);
        SEGMENT$SDL_ShowOpenFolderDialog = loader.apply("SDL_ShowOpenFolderDialog");
        HANDLE$SDL_ShowOpenFolderDialog = RawFunctionLoader.link(SEGMENT$SDL_ShowOpenFolderDialog, Descriptors.DESCRIPTOR$SDL_ShowOpenFolderDialog);
        SEGMENT$SDL_ShowFileDialogWithProperties = loader.apply("SDL_ShowFileDialogWithProperties");
        HANDLE$SDL_ShowFileDialogWithProperties = RawFunctionLoader.link(SEGMENT$SDL_ShowFileDialogWithProperties, Descriptors.DESCRIPTOR$SDL_ShowFileDialogWithProperties);
        SEGMENT$SDL_OutOfMemory = loader.apply("SDL_OutOfMemory");
        HANDLE$SDL_OutOfMemory = RawFunctionLoader.link(SEGMENT$SDL_OutOfMemory, Descriptors.DESCRIPTOR$SDL_OutOfMemory);
        SEGMENT$SDL_GetError = loader.apply("SDL_GetError");
        HANDLE$SDL_GetError = RawFunctionLoader.link(SEGMENT$SDL_GetError, Descriptors.DESCRIPTOR$SDL_GetError);
        SEGMENT$SDL_ClearError = loader.apply("SDL_ClearError");
        HANDLE$SDL_ClearError = RawFunctionLoader.link(SEGMENT$SDL_ClearError, Descriptors.DESCRIPTOR$SDL_ClearError);
        SEGMENT$SDL_PumpEvents = loader.apply("SDL_PumpEvents");
        HANDLE$SDL_PumpEvents = RawFunctionLoader.link(SEGMENT$SDL_PumpEvents, Descriptors.DESCRIPTOR$SDL_PumpEvents);
        SEGMENT$SDL_PeepEvents = loader.apply("SDL_PeepEvents");
        HANDLE$SDL_PeepEvents = RawFunctionLoader.link(SEGMENT$SDL_PeepEvents, Descriptors.DESCRIPTOR$SDL_PeepEvents);
        SEGMENT$SDL_HasEvent = loader.apply("SDL_HasEvent");
        HANDLE$SDL_HasEvent = RawFunctionLoader.link(SEGMENT$SDL_HasEvent, Descriptors.DESCRIPTOR$SDL_HasEvent);
        SEGMENT$SDL_HasEvents = loader.apply("SDL_HasEvents");
        HANDLE$SDL_HasEvents = RawFunctionLoader.link(SEGMENT$SDL_HasEvents, Descriptors.DESCRIPTOR$SDL_HasEvents);
        SEGMENT$SDL_FlushEvent = loader.apply("SDL_FlushEvent");
        HANDLE$SDL_FlushEvent = RawFunctionLoader.link(SEGMENT$SDL_FlushEvent, Descriptors.DESCRIPTOR$SDL_FlushEvent);
        SEGMENT$SDL_FlushEvents = loader.apply("SDL_FlushEvents");
        HANDLE$SDL_FlushEvents = RawFunctionLoader.link(SEGMENT$SDL_FlushEvents, Descriptors.DESCRIPTOR$SDL_FlushEvents);
        SEGMENT$SDL_PollEvent = loader.apply("SDL_PollEvent");
        HANDLE$SDL_PollEvent = RawFunctionLoader.link(SEGMENT$SDL_PollEvent, Descriptors.DESCRIPTOR$SDL_PollEvent);
        SEGMENT$SDL_WaitEvent = loader.apply("SDL_WaitEvent");
        HANDLE$SDL_WaitEvent = RawFunctionLoader.link(SEGMENT$SDL_WaitEvent, Descriptors.DESCRIPTOR$SDL_WaitEvent);
        SEGMENT$SDL_WaitEventTimeout = loader.apply("SDL_WaitEventTimeout");
        HANDLE$SDL_WaitEventTimeout = RawFunctionLoader.link(SEGMENT$SDL_WaitEventTimeout, Descriptors.DESCRIPTOR$SDL_WaitEventTimeout);
        SEGMENT$SDL_PushEvent = loader.apply("SDL_PushEvent");
        HANDLE$SDL_PushEvent = RawFunctionLoader.link(SEGMENT$SDL_PushEvent, Descriptors.DESCRIPTOR$SDL_PushEvent);
        SEGMENT$SDL_SetEventFilter = loader.apply("SDL_SetEventFilter");
        HANDLE$SDL_SetEventFilter = RawFunctionLoader.link(SEGMENT$SDL_SetEventFilter, Descriptors.DESCRIPTOR$SDL_SetEventFilter);
        SEGMENT$SDL_GetEventFilter = loader.apply("SDL_GetEventFilter");
        HANDLE$SDL_GetEventFilter = RawFunctionLoader.link(SEGMENT$SDL_GetEventFilter, Descriptors.DESCRIPTOR$SDL_GetEventFilter);
        SEGMENT$SDL_AddEventWatch = loader.apply("SDL_AddEventWatch");
        HANDLE$SDL_AddEventWatch = RawFunctionLoader.link(SEGMENT$SDL_AddEventWatch, Descriptors.DESCRIPTOR$SDL_AddEventWatch);
        SEGMENT$SDL_RemoveEventWatch = loader.apply("SDL_RemoveEventWatch");
        HANDLE$SDL_RemoveEventWatch = RawFunctionLoader.link(SEGMENT$SDL_RemoveEventWatch, Descriptors.DESCRIPTOR$SDL_RemoveEventWatch);
        SEGMENT$SDL_FilterEvents = loader.apply("SDL_FilterEvents");
        HANDLE$SDL_FilterEvents = RawFunctionLoader.link(SEGMENT$SDL_FilterEvents, Descriptors.DESCRIPTOR$SDL_FilterEvents);
        SEGMENT$SDL_SetEventEnabled = loader.apply("SDL_SetEventEnabled");
        HANDLE$SDL_SetEventEnabled = RawFunctionLoader.link(SEGMENT$SDL_SetEventEnabled, Descriptors.DESCRIPTOR$SDL_SetEventEnabled);
        SEGMENT$SDL_EventEnabled = loader.apply("SDL_EventEnabled");
        HANDLE$SDL_EventEnabled = RawFunctionLoader.link(SEGMENT$SDL_EventEnabled, Descriptors.DESCRIPTOR$SDL_EventEnabled);
        SEGMENT$SDL_RegisterEvents = loader.apply("SDL_RegisterEvents");
        HANDLE$SDL_RegisterEvents = RawFunctionLoader.link(SEGMENT$SDL_RegisterEvents, Descriptors.DESCRIPTOR$SDL_RegisterEvents);
        SEGMENT$SDL_GetWindowFromEvent = loader.apply("SDL_GetWindowFromEvent");
        HANDLE$SDL_GetWindowFromEvent = RawFunctionLoader.link(SEGMENT$SDL_GetWindowFromEvent, Descriptors.DESCRIPTOR$SDL_GetWindowFromEvent);
        SEGMENT$SDL_GetBasePath = loader.apply("SDL_GetBasePath");
        HANDLE$SDL_GetBasePath = RawFunctionLoader.link(SEGMENT$SDL_GetBasePath, Descriptors.DESCRIPTOR$SDL_GetBasePath);
        SEGMENT$SDL_GetPrefPath = loader.apply("SDL_GetPrefPath");
        HANDLE$SDL_GetPrefPath = RawFunctionLoader.link(SEGMENT$SDL_GetPrefPath, Descriptors.DESCRIPTOR$SDL_GetPrefPath);
        SEGMENT$SDL_GetUserFolder = loader.apply("SDL_GetUserFolder");
        HANDLE$SDL_GetUserFolder = RawFunctionLoader.link(SEGMENT$SDL_GetUserFolder, Descriptors.DESCRIPTOR$SDL_GetUserFolder);
        SEGMENT$SDL_CreateDirectory = loader.apply("SDL_CreateDirectory");
        HANDLE$SDL_CreateDirectory = RawFunctionLoader.link(SEGMENT$SDL_CreateDirectory, Descriptors.DESCRIPTOR$SDL_CreateDirectory);
        SEGMENT$SDL_EnumerateDirectory = loader.apply("SDL_EnumerateDirectory");
        HANDLE$SDL_EnumerateDirectory = RawFunctionLoader.link(SEGMENT$SDL_EnumerateDirectory, Descriptors.DESCRIPTOR$SDL_EnumerateDirectory);
        SEGMENT$SDL_RemovePath = loader.apply("SDL_RemovePath");
        HANDLE$SDL_RemovePath = RawFunctionLoader.link(SEGMENT$SDL_RemovePath, Descriptors.DESCRIPTOR$SDL_RemovePath);
        SEGMENT$SDL_RenamePath = loader.apply("SDL_RenamePath");
        HANDLE$SDL_RenamePath = RawFunctionLoader.link(SEGMENT$SDL_RenamePath, Descriptors.DESCRIPTOR$SDL_RenamePath);
        SEGMENT$SDL_CopyFile = loader.apply("SDL_CopyFile");
        HANDLE$SDL_CopyFile = RawFunctionLoader.link(SEGMENT$SDL_CopyFile, Descriptors.DESCRIPTOR$SDL_CopyFile);
        SEGMENT$SDL_GetPathInfo = loader.apply("SDL_GetPathInfo");
        HANDLE$SDL_GetPathInfo = RawFunctionLoader.link(SEGMENT$SDL_GetPathInfo, Descriptors.DESCRIPTOR$SDL_GetPathInfo);
        SEGMENT$SDL_GlobDirectory = loader.apply("SDL_GlobDirectory");
        HANDLE$SDL_GlobDirectory = RawFunctionLoader.link(SEGMENT$SDL_GlobDirectory, Descriptors.DESCRIPTOR$SDL_GlobDirectory);
        SEGMENT$SDL_GetCurrentDirectory = loader.apply("SDL_GetCurrentDirectory");
        HANDLE$SDL_GetCurrentDirectory = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentDirectory, Descriptors.DESCRIPTOR$SDL_GetCurrentDirectory);
        SEGMENT$SDL_AddGamepadMapping = loader.apply("SDL_AddGamepadMapping");
        HANDLE$SDL_AddGamepadMapping = RawFunctionLoader.link(SEGMENT$SDL_AddGamepadMapping, Descriptors.DESCRIPTOR$SDL_AddGamepadMapping);
        SEGMENT$SDL_AddGamepadMappingsFromIO = loader.apply("SDL_AddGamepadMappingsFromIO");
        HANDLE$SDL_AddGamepadMappingsFromIO = RawFunctionLoader.link(SEGMENT$SDL_AddGamepadMappingsFromIO, Descriptors.DESCRIPTOR$SDL_AddGamepadMappingsFromIO);
        SEGMENT$SDL_AddGamepadMappingsFromFile = loader.apply("SDL_AddGamepadMappingsFromFile");
        HANDLE$SDL_AddGamepadMappingsFromFile = RawFunctionLoader.link(SEGMENT$SDL_AddGamepadMappingsFromFile, Descriptors.DESCRIPTOR$SDL_AddGamepadMappingsFromFile);
        SEGMENT$SDL_ReloadGamepadMappings = loader.apply("SDL_ReloadGamepadMappings");
        HANDLE$SDL_ReloadGamepadMappings = RawFunctionLoader.link(SEGMENT$SDL_ReloadGamepadMappings, Descriptors.DESCRIPTOR$SDL_ReloadGamepadMappings);
        SEGMENT$SDL_GetGamepadMappings = loader.apply("SDL_GetGamepadMappings");
        HANDLE$SDL_GetGamepadMappings = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadMappings, Descriptors.DESCRIPTOR$SDL_GetGamepadMappings);
        SEGMENT$SDL_GetGamepadMappingForGUID = loader.apply("SDL_GetGamepadMappingForGUID");
        HANDLE$SDL_GetGamepadMappingForGUID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadMappingForGUID, Descriptors.DESCRIPTOR$SDL_GetGamepadMappingForGUID);
        SEGMENT$SDL_GetGamepadMapping = loader.apply("SDL_GetGamepadMapping");
        HANDLE$SDL_GetGamepadMapping = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadMapping, Descriptors.DESCRIPTOR$SDL_GetGamepadMapping);
        SEGMENT$SDL_SetGamepadMapping = loader.apply("SDL_SetGamepadMapping");
        HANDLE$SDL_SetGamepadMapping = RawFunctionLoader.link(SEGMENT$SDL_SetGamepadMapping, Descriptors.DESCRIPTOR$SDL_SetGamepadMapping);
        SEGMENT$SDL_HasGamepad = loader.apply("SDL_HasGamepad");
        HANDLE$SDL_HasGamepad = RawFunctionLoader.link(SEGMENT$SDL_HasGamepad, Descriptors.DESCRIPTOR$SDL_HasGamepad);
        SEGMENT$SDL_GetGamepads = loader.apply("SDL_GetGamepads");
        HANDLE$SDL_GetGamepads = RawFunctionLoader.link(SEGMENT$SDL_GetGamepads, Descriptors.DESCRIPTOR$SDL_GetGamepads);
        SEGMENT$SDL_IsGamepad = loader.apply("SDL_IsGamepad");
        HANDLE$SDL_IsGamepad = RawFunctionLoader.link(SEGMENT$SDL_IsGamepad, Descriptors.DESCRIPTOR$SDL_IsGamepad);
        SEGMENT$SDL_GetGamepadNameForID = loader.apply("SDL_GetGamepadNameForID");
        HANDLE$SDL_GetGamepadNameForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadNameForID, Descriptors.DESCRIPTOR$SDL_GetGamepadNameForID);
        SEGMENT$SDL_GetGamepadPathForID = loader.apply("SDL_GetGamepadPathForID");
        HANDLE$SDL_GetGamepadPathForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadPathForID, Descriptors.DESCRIPTOR$SDL_GetGamepadPathForID);
        SEGMENT$SDL_GetGamepadPlayerIndexForID = loader.apply("SDL_GetGamepadPlayerIndexForID");
        HANDLE$SDL_GetGamepadPlayerIndexForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadPlayerIndexForID, Descriptors.DESCRIPTOR$SDL_GetGamepadPlayerIndexForID);
        SEGMENT$SDL_GetGamepadGUIDForID = loader.apply("SDL_GetGamepadGUIDForID");
        HANDLE$SDL_GetGamepadGUIDForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadGUIDForID, Descriptors.DESCRIPTOR$SDL_GetGamepadGUIDForID);
        SEGMENT$SDL_GetGamepadVendorForID = loader.apply("SDL_GetGamepadVendorForID");
        HANDLE$SDL_GetGamepadVendorForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadVendorForID, Descriptors.DESCRIPTOR$SDL_GetGamepadVendorForID);
        SEGMENT$SDL_GetGamepadProductForID = loader.apply("SDL_GetGamepadProductForID");
        HANDLE$SDL_GetGamepadProductForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadProductForID, Descriptors.DESCRIPTOR$SDL_GetGamepadProductForID);
        SEGMENT$SDL_GetGamepadProductVersionForID = loader.apply("SDL_GetGamepadProductVersionForID");
        HANDLE$SDL_GetGamepadProductVersionForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadProductVersionForID, Descriptors.DESCRIPTOR$SDL_GetGamepadProductVersionForID);
        SEGMENT$SDL_GetGamepadTypeForID = loader.apply("SDL_GetGamepadTypeForID");
        HANDLE$SDL_GetGamepadTypeForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadTypeForID, Descriptors.DESCRIPTOR$SDL_GetGamepadTypeForID);
        SEGMENT$SDL_GetRealGamepadTypeForID = loader.apply("SDL_GetRealGamepadTypeForID");
        HANDLE$SDL_GetRealGamepadTypeForID = RawFunctionLoader.link(SEGMENT$SDL_GetRealGamepadTypeForID, Descriptors.DESCRIPTOR$SDL_GetRealGamepadTypeForID);
        SEGMENT$SDL_GetGamepadMappingForID = loader.apply("SDL_GetGamepadMappingForID");
        HANDLE$SDL_GetGamepadMappingForID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadMappingForID, Descriptors.DESCRIPTOR$SDL_GetGamepadMappingForID);
        SEGMENT$SDL_OpenGamepad = loader.apply("SDL_OpenGamepad");
        HANDLE$SDL_OpenGamepad = RawFunctionLoader.link(SEGMENT$SDL_OpenGamepad, Descriptors.DESCRIPTOR$SDL_OpenGamepad);
        SEGMENT$SDL_GetGamepadFromID = loader.apply("SDL_GetGamepadFromID");
        HANDLE$SDL_GetGamepadFromID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadFromID, Descriptors.DESCRIPTOR$SDL_GetGamepadFromID);
        SEGMENT$SDL_GetGamepadFromPlayerIndex = loader.apply("SDL_GetGamepadFromPlayerIndex");
        HANDLE$SDL_GetGamepadFromPlayerIndex = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadFromPlayerIndex, Descriptors.DESCRIPTOR$SDL_GetGamepadFromPlayerIndex);
        SEGMENT$SDL_GetGamepadProperties = loader.apply("SDL_GetGamepadProperties");
        HANDLE$SDL_GetGamepadProperties = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadProperties, Descriptors.DESCRIPTOR$SDL_GetGamepadProperties);
        SEGMENT$SDL_GetGamepadID = loader.apply("SDL_GetGamepadID");
        HANDLE$SDL_GetGamepadID = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadID, Descriptors.DESCRIPTOR$SDL_GetGamepadID);
        SEGMENT$SDL_GetGamepadName = loader.apply("SDL_GetGamepadName");
        HANDLE$SDL_GetGamepadName = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadName, Descriptors.DESCRIPTOR$SDL_GetGamepadName);
        SEGMENT$SDL_GetGamepadPath = loader.apply("SDL_GetGamepadPath");
        HANDLE$SDL_GetGamepadPath = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadPath, Descriptors.DESCRIPTOR$SDL_GetGamepadPath);
        SEGMENT$SDL_GetGamepadType = loader.apply("SDL_GetGamepadType");
        HANDLE$SDL_GetGamepadType = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadType, Descriptors.DESCRIPTOR$SDL_GetGamepadType);
        SEGMENT$SDL_GetRealGamepadType = loader.apply("SDL_GetRealGamepadType");
        HANDLE$SDL_GetRealGamepadType = RawFunctionLoader.link(SEGMENT$SDL_GetRealGamepadType, Descriptors.DESCRIPTOR$SDL_GetRealGamepadType);
        SEGMENT$SDL_GetGamepadPlayerIndex = loader.apply("SDL_GetGamepadPlayerIndex");
        HANDLE$SDL_GetGamepadPlayerIndex = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadPlayerIndex, Descriptors.DESCRIPTOR$SDL_GetGamepadPlayerIndex);
        SEGMENT$SDL_SetGamepadPlayerIndex = loader.apply("SDL_SetGamepadPlayerIndex");
        HANDLE$SDL_SetGamepadPlayerIndex = RawFunctionLoader.link(SEGMENT$SDL_SetGamepadPlayerIndex, Descriptors.DESCRIPTOR$SDL_SetGamepadPlayerIndex);
        SEGMENT$SDL_GetGamepadVendor = loader.apply("SDL_GetGamepadVendor");
        HANDLE$SDL_GetGamepadVendor = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadVendor, Descriptors.DESCRIPTOR$SDL_GetGamepadVendor);
        SEGMENT$SDL_GetGamepadProduct = loader.apply("SDL_GetGamepadProduct");
        HANDLE$SDL_GetGamepadProduct = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadProduct, Descriptors.DESCRIPTOR$SDL_GetGamepadProduct);
        SEGMENT$SDL_GetGamepadProductVersion = loader.apply("SDL_GetGamepadProductVersion");
        HANDLE$SDL_GetGamepadProductVersion = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadProductVersion, Descriptors.DESCRIPTOR$SDL_GetGamepadProductVersion);
        SEGMENT$SDL_GetGamepadFirmwareVersion = loader.apply("SDL_GetGamepadFirmwareVersion");
        HANDLE$SDL_GetGamepadFirmwareVersion = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadFirmwareVersion, Descriptors.DESCRIPTOR$SDL_GetGamepadFirmwareVersion);
        SEGMENT$SDL_GetGamepadSerial = loader.apply("SDL_GetGamepadSerial");
        HANDLE$SDL_GetGamepadSerial = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadSerial, Descriptors.DESCRIPTOR$SDL_GetGamepadSerial);
        SEGMENT$SDL_GetGamepadSteamHandle = loader.apply("SDL_GetGamepadSteamHandle");
        HANDLE$SDL_GetGamepadSteamHandle = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadSteamHandle, Descriptors.DESCRIPTOR$SDL_GetGamepadSteamHandle);
        SEGMENT$SDL_GetGamepadConnectionState = loader.apply("SDL_GetGamepadConnectionState");
        HANDLE$SDL_GetGamepadConnectionState = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadConnectionState, Descriptors.DESCRIPTOR$SDL_GetGamepadConnectionState);
        SEGMENT$SDL_GetGamepadPowerInfo = loader.apply("SDL_GetGamepadPowerInfo");
        HANDLE$SDL_GetGamepadPowerInfo = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadPowerInfo, Descriptors.DESCRIPTOR$SDL_GetGamepadPowerInfo);
        SEGMENT$SDL_GamepadConnected = loader.apply("SDL_GamepadConnected");
        HANDLE$SDL_GamepadConnected = RawFunctionLoader.link(SEGMENT$SDL_GamepadConnected, Descriptors.DESCRIPTOR$SDL_GamepadConnected);
        SEGMENT$SDL_GetGamepadJoystick = loader.apply("SDL_GetGamepadJoystick");
        HANDLE$SDL_GetGamepadJoystick = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadJoystick, Descriptors.DESCRIPTOR$SDL_GetGamepadJoystick);
        SEGMENT$SDL_SetGamepadEventsEnabled = loader.apply("SDL_SetGamepadEventsEnabled");
        HANDLE$SDL_SetGamepadEventsEnabled = RawFunctionLoader.link(SEGMENT$SDL_SetGamepadEventsEnabled, Descriptors.DESCRIPTOR$SDL_SetGamepadEventsEnabled);
        SEGMENT$SDL_GamepadEventsEnabled = loader.apply("SDL_GamepadEventsEnabled");
        HANDLE$SDL_GamepadEventsEnabled = RawFunctionLoader.link(SEGMENT$SDL_GamepadEventsEnabled, Descriptors.DESCRIPTOR$SDL_GamepadEventsEnabled);
        SEGMENT$SDL_GetGamepadBindings = loader.apply("SDL_GetGamepadBindings");
        HANDLE$SDL_GetGamepadBindings = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadBindings, Descriptors.DESCRIPTOR$SDL_GetGamepadBindings);
        SEGMENT$SDL_UpdateGamepads = loader.apply("SDL_UpdateGamepads");
        HANDLE$SDL_UpdateGamepads = RawFunctionLoader.link(SEGMENT$SDL_UpdateGamepads, Descriptors.DESCRIPTOR$SDL_UpdateGamepads);
        SEGMENT$SDL_GetGamepadTypeFromString = loader.apply("SDL_GetGamepadTypeFromString");
        HANDLE$SDL_GetGamepadTypeFromString = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadTypeFromString, Descriptors.DESCRIPTOR$SDL_GetGamepadTypeFromString);
        SEGMENT$SDL_GetGamepadStringForType = loader.apply("SDL_GetGamepadStringForType");
        HANDLE$SDL_GetGamepadStringForType = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadStringForType, Descriptors.DESCRIPTOR$SDL_GetGamepadStringForType);
        SEGMENT$SDL_GetGamepadAxisFromString = loader.apply("SDL_GetGamepadAxisFromString");
        HANDLE$SDL_GetGamepadAxisFromString = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadAxisFromString, Descriptors.DESCRIPTOR$SDL_GetGamepadAxisFromString);
        SEGMENT$SDL_GetGamepadStringForAxis = loader.apply("SDL_GetGamepadStringForAxis");
        HANDLE$SDL_GetGamepadStringForAxis = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadStringForAxis, Descriptors.DESCRIPTOR$SDL_GetGamepadStringForAxis);
        SEGMENT$SDL_GamepadHasAxis = loader.apply("SDL_GamepadHasAxis");
        HANDLE$SDL_GamepadHasAxis = RawFunctionLoader.link(SEGMENT$SDL_GamepadHasAxis, Descriptors.DESCRIPTOR$SDL_GamepadHasAxis);
        SEGMENT$SDL_GetGamepadAxis = loader.apply("SDL_GetGamepadAxis");
        HANDLE$SDL_GetGamepadAxis = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadAxis, Descriptors.DESCRIPTOR$SDL_GetGamepadAxis);
        SEGMENT$SDL_GetGamepadButtonFromString = loader.apply("SDL_GetGamepadButtonFromString");
        HANDLE$SDL_GetGamepadButtonFromString = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadButtonFromString, Descriptors.DESCRIPTOR$SDL_GetGamepadButtonFromString);
        SEGMENT$SDL_GetGamepadStringForButton = loader.apply("SDL_GetGamepadStringForButton");
        HANDLE$SDL_GetGamepadStringForButton = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadStringForButton, Descriptors.DESCRIPTOR$SDL_GetGamepadStringForButton);
        SEGMENT$SDL_GamepadHasButton = loader.apply("SDL_GamepadHasButton");
        HANDLE$SDL_GamepadHasButton = RawFunctionLoader.link(SEGMENT$SDL_GamepadHasButton, Descriptors.DESCRIPTOR$SDL_GamepadHasButton);
        SEGMENT$SDL_GetGamepadButton = loader.apply("SDL_GetGamepadButton");
        HANDLE$SDL_GetGamepadButton = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadButton, Descriptors.DESCRIPTOR$SDL_GetGamepadButton);
        SEGMENT$SDL_GetGamepadButtonLabelForType = loader.apply("SDL_GetGamepadButtonLabelForType");
        HANDLE$SDL_GetGamepadButtonLabelForType = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadButtonLabelForType, Descriptors.DESCRIPTOR$SDL_GetGamepadButtonLabelForType);
        SEGMENT$SDL_GetGamepadButtonLabel = loader.apply("SDL_GetGamepadButtonLabel");
        HANDLE$SDL_GetGamepadButtonLabel = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadButtonLabel, Descriptors.DESCRIPTOR$SDL_GetGamepadButtonLabel);
        SEGMENT$SDL_GetNumGamepadTouchpads = loader.apply("SDL_GetNumGamepadTouchpads");
        HANDLE$SDL_GetNumGamepadTouchpads = RawFunctionLoader.link(SEGMENT$SDL_GetNumGamepadTouchpads, Descriptors.DESCRIPTOR$SDL_GetNumGamepadTouchpads);
        SEGMENT$SDL_GetNumGamepadTouchpadFingers = loader.apply("SDL_GetNumGamepadTouchpadFingers");
        HANDLE$SDL_GetNumGamepadTouchpadFingers = RawFunctionLoader.link(SEGMENT$SDL_GetNumGamepadTouchpadFingers, Descriptors.DESCRIPTOR$SDL_GetNumGamepadTouchpadFingers);
        SEGMENT$SDL_GetGamepadTouchpadFinger = loader.apply("SDL_GetGamepadTouchpadFinger");
        HANDLE$SDL_GetGamepadTouchpadFinger = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadTouchpadFinger, Descriptors.DESCRIPTOR$SDL_GetGamepadTouchpadFinger);
        SEGMENT$SDL_GamepadHasSensor = loader.apply("SDL_GamepadHasSensor");
        HANDLE$SDL_GamepadHasSensor = RawFunctionLoader.link(SEGMENT$SDL_GamepadHasSensor, Descriptors.DESCRIPTOR$SDL_GamepadHasSensor);
        SEGMENT$SDL_SetGamepadSensorEnabled = loader.apply("SDL_SetGamepadSensorEnabled");
        HANDLE$SDL_SetGamepadSensorEnabled = RawFunctionLoader.link(SEGMENT$SDL_SetGamepadSensorEnabled, Descriptors.DESCRIPTOR$SDL_SetGamepadSensorEnabled);
        SEGMENT$SDL_GamepadSensorEnabled = loader.apply("SDL_GamepadSensorEnabled");
        HANDLE$SDL_GamepadSensorEnabled = RawFunctionLoader.link(SEGMENT$SDL_GamepadSensorEnabled, Descriptors.DESCRIPTOR$SDL_GamepadSensorEnabled);
        SEGMENT$SDL_GetGamepadSensorDataRate = loader.apply("SDL_GetGamepadSensorDataRate");
        HANDLE$SDL_GetGamepadSensorDataRate = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadSensorDataRate, Descriptors.DESCRIPTOR$SDL_GetGamepadSensorDataRate);
        SEGMENT$SDL_GetGamepadSensorData = loader.apply("SDL_GetGamepadSensorData");
        HANDLE$SDL_GetGamepadSensorData = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadSensorData, Descriptors.DESCRIPTOR$SDL_GetGamepadSensorData);
        SEGMENT$SDL_RumbleGamepad = loader.apply("SDL_RumbleGamepad");
        HANDLE$SDL_RumbleGamepad = RawFunctionLoader.link(SEGMENT$SDL_RumbleGamepad, Descriptors.DESCRIPTOR$SDL_RumbleGamepad);
        SEGMENT$SDL_RumbleGamepadTriggers = loader.apply("SDL_RumbleGamepadTriggers");
        HANDLE$SDL_RumbleGamepadTriggers = RawFunctionLoader.link(SEGMENT$SDL_RumbleGamepadTriggers, Descriptors.DESCRIPTOR$SDL_RumbleGamepadTriggers);
        SEGMENT$SDL_SetGamepadLED = loader.apply("SDL_SetGamepadLED");
        HANDLE$SDL_SetGamepadLED = RawFunctionLoader.link(SEGMENT$SDL_SetGamepadLED, Descriptors.DESCRIPTOR$SDL_SetGamepadLED);
        SEGMENT$SDL_SendGamepadEffect = loader.apply("SDL_SendGamepadEffect");
        HANDLE$SDL_SendGamepadEffect = RawFunctionLoader.link(SEGMENT$SDL_SendGamepadEffect, Descriptors.DESCRIPTOR$SDL_SendGamepadEffect);
        SEGMENT$SDL_CloseGamepad = loader.apply("SDL_CloseGamepad");
        HANDLE$SDL_CloseGamepad = RawFunctionLoader.link(SEGMENT$SDL_CloseGamepad, Descriptors.DESCRIPTOR$SDL_CloseGamepad);
        SEGMENT$SDL_GetGamepadAppleSFSymbolsNameForButton = loader.apply("SDL_GetGamepadAppleSFSymbolsNameForButton");
        HANDLE$SDL_GetGamepadAppleSFSymbolsNameForButton = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadAppleSFSymbolsNameForButton, Descriptors.DESCRIPTOR$SDL_GetGamepadAppleSFSymbolsNameForButton);
        SEGMENT$SDL_GetGamepadAppleSFSymbolsNameForAxis = loader.apply("SDL_GetGamepadAppleSFSymbolsNameForAxis");
        HANDLE$SDL_GetGamepadAppleSFSymbolsNameForAxis = RawFunctionLoader.link(SEGMENT$SDL_GetGamepadAppleSFSymbolsNameForAxis, Descriptors.DESCRIPTOR$SDL_GetGamepadAppleSFSymbolsNameForAxis);
        SEGMENT$SDL_GPUSupportsShaderFormats = loader.apply("SDL_GPUSupportsShaderFormats");
        HANDLE$SDL_GPUSupportsShaderFormats = RawFunctionLoader.link(SEGMENT$SDL_GPUSupportsShaderFormats, Descriptors.DESCRIPTOR$SDL_GPUSupportsShaderFormats);
        SEGMENT$SDL_GPUSupportsProperties = loader.apply("SDL_GPUSupportsProperties");
        HANDLE$SDL_GPUSupportsProperties = RawFunctionLoader.link(SEGMENT$SDL_GPUSupportsProperties, Descriptors.DESCRIPTOR$SDL_GPUSupportsProperties);
        SEGMENT$SDL_CreateGPUDevice = loader.apply("SDL_CreateGPUDevice");
        HANDLE$SDL_CreateGPUDevice = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUDevice, Descriptors.DESCRIPTOR$SDL_CreateGPUDevice);
        SEGMENT$SDL_CreateGPUDeviceWithProperties = loader.apply("SDL_CreateGPUDeviceWithProperties");
        HANDLE$SDL_CreateGPUDeviceWithProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUDeviceWithProperties, Descriptors.DESCRIPTOR$SDL_CreateGPUDeviceWithProperties);
        SEGMENT$SDL_DestroyGPUDevice = loader.apply("SDL_DestroyGPUDevice");
        HANDLE$SDL_DestroyGPUDevice = RawFunctionLoader.link(SEGMENT$SDL_DestroyGPUDevice, Descriptors.DESCRIPTOR$SDL_DestroyGPUDevice);
        SEGMENT$SDL_GetNumGPUDrivers = loader.apply("SDL_GetNumGPUDrivers");
        HANDLE$SDL_GetNumGPUDrivers = RawFunctionLoader.link(SEGMENT$SDL_GetNumGPUDrivers, Descriptors.DESCRIPTOR$SDL_GetNumGPUDrivers);
        SEGMENT$SDL_GetGPUDriver = loader.apply("SDL_GetGPUDriver");
        HANDLE$SDL_GetGPUDriver = RawFunctionLoader.link(SEGMENT$SDL_GetGPUDriver, Descriptors.DESCRIPTOR$SDL_GetGPUDriver);
        SEGMENT$SDL_GetGPUDeviceDriver = loader.apply("SDL_GetGPUDeviceDriver");
        HANDLE$SDL_GetGPUDeviceDriver = RawFunctionLoader.link(SEGMENT$SDL_GetGPUDeviceDriver, Descriptors.DESCRIPTOR$SDL_GetGPUDeviceDriver);
        SEGMENT$SDL_GetGPUShaderFormats = loader.apply("SDL_GetGPUShaderFormats");
        HANDLE$SDL_GetGPUShaderFormats = RawFunctionLoader.link(SEGMENT$SDL_GetGPUShaderFormats, Descriptors.DESCRIPTOR$SDL_GetGPUShaderFormats);
        SEGMENT$SDL_CreateGPUComputePipeline = loader.apply("SDL_CreateGPUComputePipeline");
        HANDLE$SDL_CreateGPUComputePipeline = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUComputePipeline, Descriptors.DESCRIPTOR$SDL_CreateGPUComputePipeline);
        SEGMENT$SDL_CreateGPUGraphicsPipeline = loader.apply("SDL_CreateGPUGraphicsPipeline");
        HANDLE$SDL_CreateGPUGraphicsPipeline = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUGraphicsPipeline, Descriptors.DESCRIPTOR$SDL_CreateGPUGraphicsPipeline);
        SEGMENT$SDL_CreateGPUSampler = loader.apply("SDL_CreateGPUSampler");
        HANDLE$SDL_CreateGPUSampler = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUSampler, Descriptors.DESCRIPTOR$SDL_CreateGPUSampler);
        SEGMENT$SDL_CreateGPUShader = loader.apply("SDL_CreateGPUShader");
        HANDLE$SDL_CreateGPUShader = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUShader, Descriptors.DESCRIPTOR$SDL_CreateGPUShader);
        SEGMENT$SDL_CreateGPUTexture = loader.apply("SDL_CreateGPUTexture");
        HANDLE$SDL_CreateGPUTexture = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUTexture, Descriptors.DESCRIPTOR$SDL_CreateGPUTexture);
        SEGMENT$SDL_CreateGPUBuffer = loader.apply("SDL_CreateGPUBuffer");
        HANDLE$SDL_CreateGPUBuffer = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUBuffer, Descriptors.DESCRIPTOR$SDL_CreateGPUBuffer);
        SEGMENT$SDL_CreateGPUTransferBuffer = loader.apply("SDL_CreateGPUTransferBuffer");
        HANDLE$SDL_CreateGPUTransferBuffer = RawFunctionLoader.link(SEGMENT$SDL_CreateGPUTransferBuffer, Descriptors.DESCRIPTOR$SDL_CreateGPUTransferBuffer);
        SEGMENT$SDL_SetGPUBufferName = loader.apply("SDL_SetGPUBufferName");
        HANDLE$SDL_SetGPUBufferName = RawFunctionLoader.link(SEGMENT$SDL_SetGPUBufferName, Descriptors.DESCRIPTOR$SDL_SetGPUBufferName);
        SEGMENT$SDL_SetGPUTextureName = loader.apply("SDL_SetGPUTextureName");
        HANDLE$SDL_SetGPUTextureName = RawFunctionLoader.link(SEGMENT$SDL_SetGPUTextureName, Descriptors.DESCRIPTOR$SDL_SetGPUTextureName);
        SEGMENT$SDL_InsertGPUDebugLabel = loader.apply("SDL_InsertGPUDebugLabel");
        HANDLE$SDL_InsertGPUDebugLabel = RawFunctionLoader.link(SEGMENT$SDL_InsertGPUDebugLabel, Descriptors.DESCRIPTOR$SDL_InsertGPUDebugLabel);
        SEGMENT$SDL_PushGPUDebugGroup = loader.apply("SDL_PushGPUDebugGroup");
        HANDLE$SDL_PushGPUDebugGroup = RawFunctionLoader.link(SEGMENT$SDL_PushGPUDebugGroup, Descriptors.DESCRIPTOR$SDL_PushGPUDebugGroup);
        SEGMENT$SDL_PopGPUDebugGroup = loader.apply("SDL_PopGPUDebugGroup");
        HANDLE$SDL_PopGPUDebugGroup = RawFunctionLoader.link(SEGMENT$SDL_PopGPUDebugGroup, Descriptors.DESCRIPTOR$SDL_PopGPUDebugGroup);
        SEGMENT$SDL_ReleaseGPUTexture = loader.apply("SDL_ReleaseGPUTexture");
        HANDLE$SDL_ReleaseGPUTexture = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUTexture, Descriptors.DESCRIPTOR$SDL_ReleaseGPUTexture);
        SEGMENT$SDL_ReleaseGPUSampler = loader.apply("SDL_ReleaseGPUSampler");
        HANDLE$SDL_ReleaseGPUSampler = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUSampler, Descriptors.DESCRIPTOR$SDL_ReleaseGPUSampler);
        SEGMENT$SDL_ReleaseGPUBuffer = loader.apply("SDL_ReleaseGPUBuffer");
        HANDLE$SDL_ReleaseGPUBuffer = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUBuffer, Descriptors.DESCRIPTOR$SDL_ReleaseGPUBuffer);
        SEGMENT$SDL_ReleaseGPUTransferBuffer = loader.apply("SDL_ReleaseGPUTransferBuffer");
        HANDLE$SDL_ReleaseGPUTransferBuffer = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUTransferBuffer, Descriptors.DESCRIPTOR$SDL_ReleaseGPUTransferBuffer);
        SEGMENT$SDL_ReleaseGPUComputePipeline = loader.apply("SDL_ReleaseGPUComputePipeline");
        HANDLE$SDL_ReleaseGPUComputePipeline = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUComputePipeline, Descriptors.DESCRIPTOR$SDL_ReleaseGPUComputePipeline);
        SEGMENT$SDL_ReleaseGPUShader = loader.apply("SDL_ReleaseGPUShader");
        HANDLE$SDL_ReleaseGPUShader = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUShader, Descriptors.DESCRIPTOR$SDL_ReleaseGPUShader);
        SEGMENT$SDL_ReleaseGPUGraphicsPipeline = loader.apply("SDL_ReleaseGPUGraphicsPipeline");
        HANDLE$SDL_ReleaseGPUGraphicsPipeline = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUGraphicsPipeline, Descriptors.DESCRIPTOR$SDL_ReleaseGPUGraphicsPipeline);
        SEGMENT$SDL_AcquireGPUCommandBuffer = loader.apply("SDL_AcquireGPUCommandBuffer");
        HANDLE$SDL_AcquireGPUCommandBuffer = RawFunctionLoader.link(SEGMENT$SDL_AcquireGPUCommandBuffer, Descriptors.DESCRIPTOR$SDL_AcquireGPUCommandBuffer);
        SEGMENT$SDL_PushGPUVertexUniformData = loader.apply("SDL_PushGPUVertexUniformData");
        HANDLE$SDL_PushGPUVertexUniformData = RawFunctionLoader.link(SEGMENT$SDL_PushGPUVertexUniformData, Descriptors.DESCRIPTOR$SDL_PushGPUVertexUniformData);
        SEGMENT$SDL_PushGPUFragmentUniformData = loader.apply("SDL_PushGPUFragmentUniformData");
        HANDLE$SDL_PushGPUFragmentUniformData = RawFunctionLoader.link(SEGMENT$SDL_PushGPUFragmentUniformData, Descriptors.DESCRIPTOR$SDL_PushGPUFragmentUniformData);
        SEGMENT$SDL_PushGPUComputeUniformData = loader.apply("SDL_PushGPUComputeUniformData");
        HANDLE$SDL_PushGPUComputeUniformData = RawFunctionLoader.link(SEGMENT$SDL_PushGPUComputeUniformData, Descriptors.DESCRIPTOR$SDL_PushGPUComputeUniformData);
        SEGMENT$SDL_BeginGPURenderPass = loader.apply("SDL_BeginGPURenderPass");
        HANDLE$SDL_BeginGPURenderPass = RawFunctionLoader.link(SEGMENT$SDL_BeginGPURenderPass, Descriptors.DESCRIPTOR$SDL_BeginGPURenderPass);
        SEGMENT$SDL_BindGPUGraphicsPipeline = loader.apply("SDL_BindGPUGraphicsPipeline");
        HANDLE$SDL_BindGPUGraphicsPipeline = RawFunctionLoader.link(SEGMENT$SDL_BindGPUGraphicsPipeline, Descriptors.DESCRIPTOR$SDL_BindGPUGraphicsPipeline);
        SEGMENT$SDL_SetGPUViewport = loader.apply("SDL_SetGPUViewport");
        HANDLE$SDL_SetGPUViewport = RawFunctionLoader.link(SEGMENT$SDL_SetGPUViewport, Descriptors.DESCRIPTOR$SDL_SetGPUViewport);
        SEGMENT$SDL_SetGPUScissor = loader.apply("SDL_SetGPUScissor");
        HANDLE$SDL_SetGPUScissor = RawFunctionLoader.link(SEGMENT$SDL_SetGPUScissor, Descriptors.DESCRIPTOR$SDL_SetGPUScissor);
        SEGMENT$SDL_SetGPUBlendConstants = loader.apply("SDL_SetGPUBlendConstants");
        HANDLE$SDL_SetGPUBlendConstants = RawFunctionLoader.link(SEGMENT$SDL_SetGPUBlendConstants, Descriptors.DESCRIPTOR$SDL_SetGPUBlendConstants);
        SEGMENT$SDL_SetGPUStencilReference = loader.apply("SDL_SetGPUStencilReference");
        HANDLE$SDL_SetGPUStencilReference = RawFunctionLoader.link(SEGMENT$SDL_SetGPUStencilReference, Descriptors.DESCRIPTOR$SDL_SetGPUStencilReference);
        SEGMENT$SDL_BindGPUVertexBuffers = loader.apply("SDL_BindGPUVertexBuffers");
        HANDLE$SDL_BindGPUVertexBuffers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUVertexBuffers, Descriptors.DESCRIPTOR$SDL_BindGPUVertexBuffers);
        SEGMENT$SDL_BindGPUIndexBuffer = loader.apply("SDL_BindGPUIndexBuffer");
        HANDLE$SDL_BindGPUIndexBuffer = RawFunctionLoader.link(SEGMENT$SDL_BindGPUIndexBuffer, Descriptors.DESCRIPTOR$SDL_BindGPUIndexBuffer);
        SEGMENT$SDL_BindGPUVertexSamplers = loader.apply("SDL_BindGPUVertexSamplers");
        HANDLE$SDL_BindGPUVertexSamplers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUVertexSamplers, Descriptors.DESCRIPTOR$SDL_BindGPUVertexSamplers);
        SEGMENT$SDL_BindGPUVertexStorageTextures = loader.apply("SDL_BindGPUVertexStorageTextures");
        HANDLE$SDL_BindGPUVertexStorageTextures = RawFunctionLoader.link(SEGMENT$SDL_BindGPUVertexStorageTextures, Descriptors.DESCRIPTOR$SDL_BindGPUVertexStorageTextures);
        SEGMENT$SDL_BindGPUVertexStorageBuffers = loader.apply("SDL_BindGPUVertexStorageBuffers");
        HANDLE$SDL_BindGPUVertexStorageBuffers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUVertexStorageBuffers, Descriptors.DESCRIPTOR$SDL_BindGPUVertexStorageBuffers);
        SEGMENT$SDL_BindGPUFragmentSamplers = loader.apply("SDL_BindGPUFragmentSamplers");
        HANDLE$SDL_BindGPUFragmentSamplers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUFragmentSamplers, Descriptors.DESCRIPTOR$SDL_BindGPUFragmentSamplers);
        SEGMENT$SDL_BindGPUFragmentStorageTextures = loader.apply("SDL_BindGPUFragmentStorageTextures");
        HANDLE$SDL_BindGPUFragmentStorageTextures = RawFunctionLoader.link(SEGMENT$SDL_BindGPUFragmentStorageTextures, Descriptors.DESCRIPTOR$SDL_BindGPUFragmentStorageTextures);
        SEGMENT$SDL_BindGPUFragmentStorageBuffers = loader.apply("SDL_BindGPUFragmentStorageBuffers");
        HANDLE$SDL_BindGPUFragmentStorageBuffers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUFragmentStorageBuffers, Descriptors.DESCRIPTOR$SDL_BindGPUFragmentStorageBuffers);
        SEGMENT$SDL_DrawGPUIndexedPrimitives = loader.apply("SDL_DrawGPUIndexedPrimitives");
        HANDLE$SDL_DrawGPUIndexedPrimitives = RawFunctionLoader.link(SEGMENT$SDL_DrawGPUIndexedPrimitives, Descriptors.DESCRIPTOR$SDL_DrawGPUIndexedPrimitives);
        SEGMENT$SDL_DrawGPUPrimitives = loader.apply("SDL_DrawGPUPrimitives");
        HANDLE$SDL_DrawGPUPrimitives = RawFunctionLoader.link(SEGMENT$SDL_DrawGPUPrimitives, Descriptors.DESCRIPTOR$SDL_DrawGPUPrimitives);
        SEGMENT$SDL_DrawGPUPrimitivesIndirect = loader.apply("SDL_DrawGPUPrimitivesIndirect");
        HANDLE$SDL_DrawGPUPrimitivesIndirect = RawFunctionLoader.link(SEGMENT$SDL_DrawGPUPrimitivesIndirect, Descriptors.DESCRIPTOR$SDL_DrawGPUPrimitivesIndirect);
        SEGMENT$SDL_DrawGPUIndexedPrimitivesIndirect = loader.apply("SDL_DrawGPUIndexedPrimitivesIndirect");
        HANDLE$SDL_DrawGPUIndexedPrimitivesIndirect = RawFunctionLoader.link(SEGMENT$SDL_DrawGPUIndexedPrimitivesIndirect, Descriptors.DESCRIPTOR$SDL_DrawGPUIndexedPrimitivesIndirect);
        SEGMENT$SDL_EndGPURenderPass = loader.apply("SDL_EndGPURenderPass");
        HANDLE$SDL_EndGPURenderPass = RawFunctionLoader.link(SEGMENT$SDL_EndGPURenderPass, Descriptors.DESCRIPTOR$SDL_EndGPURenderPass);
        SEGMENT$SDL_BeginGPUComputePass = loader.apply("SDL_BeginGPUComputePass");
        HANDLE$SDL_BeginGPUComputePass = RawFunctionLoader.link(SEGMENT$SDL_BeginGPUComputePass, Descriptors.DESCRIPTOR$SDL_BeginGPUComputePass);
        SEGMENT$SDL_BindGPUComputePipeline = loader.apply("SDL_BindGPUComputePipeline");
        HANDLE$SDL_BindGPUComputePipeline = RawFunctionLoader.link(SEGMENT$SDL_BindGPUComputePipeline, Descriptors.DESCRIPTOR$SDL_BindGPUComputePipeline);
        SEGMENT$SDL_BindGPUComputeSamplers = loader.apply("SDL_BindGPUComputeSamplers");
        HANDLE$SDL_BindGPUComputeSamplers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUComputeSamplers, Descriptors.DESCRIPTOR$SDL_BindGPUComputeSamplers);
        SEGMENT$SDL_BindGPUComputeStorageTextures = loader.apply("SDL_BindGPUComputeStorageTextures");
        HANDLE$SDL_BindGPUComputeStorageTextures = RawFunctionLoader.link(SEGMENT$SDL_BindGPUComputeStorageTextures, Descriptors.DESCRIPTOR$SDL_BindGPUComputeStorageTextures);
        SEGMENT$SDL_BindGPUComputeStorageBuffers = loader.apply("SDL_BindGPUComputeStorageBuffers");
        HANDLE$SDL_BindGPUComputeStorageBuffers = RawFunctionLoader.link(SEGMENT$SDL_BindGPUComputeStorageBuffers, Descriptors.DESCRIPTOR$SDL_BindGPUComputeStorageBuffers);
        SEGMENT$SDL_DispatchGPUCompute = loader.apply("SDL_DispatchGPUCompute");
        HANDLE$SDL_DispatchGPUCompute = RawFunctionLoader.link(SEGMENT$SDL_DispatchGPUCompute, Descriptors.DESCRIPTOR$SDL_DispatchGPUCompute);
        SEGMENT$SDL_DispatchGPUComputeIndirect = loader.apply("SDL_DispatchGPUComputeIndirect");
        HANDLE$SDL_DispatchGPUComputeIndirect = RawFunctionLoader.link(SEGMENT$SDL_DispatchGPUComputeIndirect, Descriptors.DESCRIPTOR$SDL_DispatchGPUComputeIndirect);
        SEGMENT$SDL_EndGPUComputePass = loader.apply("SDL_EndGPUComputePass");
        HANDLE$SDL_EndGPUComputePass = RawFunctionLoader.link(SEGMENT$SDL_EndGPUComputePass, Descriptors.DESCRIPTOR$SDL_EndGPUComputePass);
        SEGMENT$SDL_MapGPUTransferBuffer = loader.apply("SDL_MapGPUTransferBuffer");
        HANDLE$SDL_MapGPUTransferBuffer = RawFunctionLoader.link(SEGMENT$SDL_MapGPUTransferBuffer, Descriptors.DESCRIPTOR$SDL_MapGPUTransferBuffer);
        SEGMENT$SDL_UnmapGPUTransferBuffer = loader.apply("SDL_UnmapGPUTransferBuffer");
        HANDLE$SDL_UnmapGPUTransferBuffer = RawFunctionLoader.link(SEGMENT$SDL_UnmapGPUTransferBuffer, Descriptors.DESCRIPTOR$SDL_UnmapGPUTransferBuffer);
        SEGMENT$SDL_BeginGPUCopyPass = loader.apply("SDL_BeginGPUCopyPass");
        HANDLE$SDL_BeginGPUCopyPass = RawFunctionLoader.link(SEGMENT$SDL_BeginGPUCopyPass, Descriptors.DESCRIPTOR$SDL_BeginGPUCopyPass);
        SEGMENT$SDL_UploadToGPUTexture = loader.apply("SDL_UploadToGPUTexture");
        HANDLE$SDL_UploadToGPUTexture = RawFunctionLoader.link(SEGMENT$SDL_UploadToGPUTexture, Descriptors.DESCRIPTOR$SDL_UploadToGPUTexture);
        SEGMENT$SDL_UploadToGPUBuffer = loader.apply("SDL_UploadToGPUBuffer");
        HANDLE$SDL_UploadToGPUBuffer = RawFunctionLoader.link(SEGMENT$SDL_UploadToGPUBuffer, Descriptors.DESCRIPTOR$SDL_UploadToGPUBuffer);
        SEGMENT$SDL_CopyGPUTextureToTexture = loader.apply("SDL_CopyGPUTextureToTexture");
        HANDLE$SDL_CopyGPUTextureToTexture = RawFunctionLoader.link(SEGMENT$SDL_CopyGPUTextureToTexture, Descriptors.DESCRIPTOR$SDL_CopyGPUTextureToTexture);
        SEGMENT$SDL_CopyGPUBufferToBuffer = loader.apply("SDL_CopyGPUBufferToBuffer");
        HANDLE$SDL_CopyGPUBufferToBuffer = RawFunctionLoader.link(SEGMENT$SDL_CopyGPUBufferToBuffer, Descriptors.DESCRIPTOR$SDL_CopyGPUBufferToBuffer);
        SEGMENT$SDL_DownloadFromGPUTexture = loader.apply("SDL_DownloadFromGPUTexture");
        HANDLE$SDL_DownloadFromGPUTexture = RawFunctionLoader.link(SEGMENT$SDL_DownloadFromGPUTexture, Descriptors.DESCRIPTOR$SDL_DownloadFromGPUTexture);
        SEGMENT$SDL_DownloadFromGPUBuffer = loader.apply("SDL_DownloadFromGPUBuffer");
        HANDLE$SDL_DownloadFromGPUBuffer = RawFunctionLoader.link(SEGMENT$SDL_DownloadFromGPUBuffer, Descriptors.DESCRIPTOR$SDL_DownloadFromGPUBuffer);
        SEGMENT$SDL_EndGPUCopyPass = loader.apply("SDL_EndGPUCopyPass");
        HANDLE$SDL_EndGPUCopyPass = RawFunctionLoader.link(SEGMENT$SDL_EndGPUCopyPass, Descriptors.DESCRIPTOR$SDL_EndGPUCopyPass);
        SEGMENT$SDL_GenerateMipmapsForGPUTexture = loader.apply("SDL_GenerateMipmapsForGPUTexture");
        HANDLE$SDL_GenerateMipmapsForGPUTexture = RawFunctionLoader.link(SEGMENT$SDL_GenerateMipmapsForGPUTexture, Descriptors.DESCRIPTOR$SDL_GenerateMipmapsForGPUTexture);
        SEGMENT$SDL_BlitGPUTexture = loader.apply("SDL_BlitGPUTexture");
        HANDLE$SDL_BlitGPUTexture = RawFunctionLoader.link(SEGMENT$SDL_BlitGPUTexture, Descriptors.DESCRIPTOR$SDL_BlitGPUTexture);
        SEGMENT$SDL_WindowSupportsGPUSwapchainComposition = loader.apply("SDL_WindowSupportsGPUSwapchainComposition");
        HANDLE$SDL_WindowSupportsGPUSwapchainComposition = RawFunctionLoader.link(SEGMENT$SDL_WindowSupportsGPUSwapchainComposition, Descriptors.DESCRIPTOR$SDL_WindowSupportsGPUSwapchainComposition);
        SEGMENT$SDL_WindowSupportsGPUPresentMode = loader.apply("SDL_WindowSupportsGPUPresentMode");
        HANDLE$SDL_WindowSupportsGPUPresentMode = RawFunctionLoader.link(SEGMENT$SDL_WindowSupportsGPUPresentMode, Descriptors.DESCRIPTOR$SDL_WindowSupportsGPUPresentMode);
        SEGMENT$SDL_ClaimWindowForGPUDevice = loader.apply("SDL_ClaimWindowForGPUDevice");
        HANDLE$SDL_ClaimWindowForGPUDevice = RawFunctionLoader.link(SEGMENT$SDL_ClaimWindowForGPUDevice, Descriptors.DESCRIPTOR$SDL_ClaimWindowForGPUDevice);
        SEGMENT$SDL_ReleaseWindowFromGPUDevice = loader.apply("SDL_ReleaseWindowFromGPUDevice");
        HANDLE$SDL_ReleaseWindowFromGPUDevice = RawFunctionLoader.link(SEGMENT$SDL_ReleaseWindowFromGPUDevice, Descriptors.DESCRIPTOR$SDL_ReleaseWindowFromGPUDevice);
        SEGMENT$SDL_SetGPUSwapchainParameters = loader.apply("SDL_SetGPUSwapchainParameters");
        HANDLE$SDL_SetGPUSwapchainParameters = RawFunctionLoader.link(SEGMENT$SDL_SetGPUSwapchainParameters, Descriptors.DESCRIPTOR$SDL_SetGPUSwapchainParameters);
        SEGMENT$SDL_SetGPUAllowedFramesInFlight = loader.apply("SDL_SetGPUAllowedFramesInFlight");
        HANDLE$SDL_SetGPUAllowedFramesInFlight = RawFunctionLoader.link(SEGMENT$SDL_SetGPUAllowedFramesInFlight, Descriptors.DESCRIPTOR$SDL_SetGPUAllowedFramesInFlight);
        SEGMENT$SDL_GetGPUSwapchainTextureFormat = loader.apply("SDL_GetGPUSwapchainTextureFormat");
        HANDLE$SDL_GetGPUSwapchainTextureFormat = RawFunctionLoader.link(SEGMENT$SDL_GetGPUSwapchainTextureFormat, Descriptors.DESCRIPTOR$SDL_GetGPUSwapchainTextureFormat);
        SEGMENT$SDL_AcquireGPUSwapchainTexture = loader.apply("SDL_AcquireGPUSwapchainTexture");
        HANDLE$SDL_AcquireGPUSwapchainTexture = RawFunctionLoader.link(SEGMENT$SDL_AcquireGPUSwapchainTexture, Descriptors.DESCRIPTOR$SDL_AcquireGPUSwapchainTexture);
        SEGMENT$SDL_WaitForGPUSwapchain = loader.apply("SDL_WaitForGPUSwapchain");
        HANDLE$SDL_WaitForGPUSwapchain = RawFunctionLoader.link(SEGMENT$SDL_WaitForGPUSwapchain, Descriptors.DESCRIPTOR$SDL_WaitForGPUSwapchain);
        SEGMENT$SDL_WaitAndAcquireGPUSwapchainTexture = loader.apply("SDL_WaitAndAcquireGPUSwapchainTexture");
        HANDLE$SDL_WaitAndAcquireGPUSwapchainTexture = RawFunctionLoader.link(SEGMENT$SDL_WaitAndAcquireGPUSwapchainTexture, Descriptors.DESCRIPTOR$SDL_WaitAndAcquireGPUSwapchainTexture);
        SEGMENT$SDL_SubmitGPUCommandBuffer = loader.apply("SDL_SubmitGPUCommandBuffer");
        HANDLE$SDL_SubmitGPUCommandBuffer = RawFunctionLoader.link(SEGMENT$SDL_SubmitGPUCommandBuffer, Descriptors.DESCRIPTOR$SDL_SubmitGPUCommandBuffer);
        SEGMENT$SDL_SubmitGPUCommandBufferAndAcquireFence = loader.apply("SDL_SubmitGPUCommandBufferAndAcquireFence");
        HANDLE$SDL_SubmitGPUCommandBufferAndAcquireFence = RawFunctionLoader.link(SEGMENT$SDL_SubmitGPUCommandBufferAndAcquireFence, Descriptors.DESCRIPTOR$SDL_SubmitGPUCommandBufferAndAcquireFence);
        SEGMENT$SDL_CancelGPUCommandBuffer = loader.apply("SDL_CancelGPUCommandBuffer");
        HANDLE$SDL_CancelGPUCommandBuffer = RawFunctionLoader.link(SEGMENT$SDL_CancelGPUCommandBuffer, Descriptors.DESCRIPTOR$SDL_CancelGPUCommandBuffer);
        SEGMENT$SDL_WaitForGPUIdle = loader.apply("SDL_WaitForGPUIdle");
        HANDLE$SDL_WaitForGPUIdle = RawFunctionLoader.link(SEGMENT$SDL_WaitForGPUIdle, Descriptors.DESCRIPTOR$SDL_WaitForGPUIdle);
        SEGMENT$SDL_WaitForGPUFences = loader.apply("SDL_WaitForGPUFences");
        HANDLE$SDL_WaitForGPUFences = RawFunctionLoader.link(SEGMENT$SDL_WaitForGPUFences, Descriptors.DESCRIPTOR$SDL_WaitForGPUFences);
        SEGMENT$SDL_QueryGPUFence = loader.apply("SDL_QueryGPUFence");
        HANDLE$SDL_QueryGPUFence = RawFunctionLoader.link(SEGMENT$SDL_QueryGPUFence, Descriptors.DESCRIPTOR$SDL_QueryGPUFence);
        SEGMENT$SDL_ReleaseGPUFence = loader.apply("SDL_ReleaseGPUFence");
        HANDLE$SDL_ReleaseGPUFence = RawFunctionLoader.link(SEGMENT$SDL_ReleaseGPUFence, Descriptors.DESCRIPTOR$SDL_ReleaseGPUFence);
        SEGMENT$SDL_GPUTextureFormatTexelBlockSize = loader.apply("SDL_GPUTextureFormatTexelBlockSize");
        HANDLE$SDL_GPUTextureFormatTexelBlockSize = RawFunctionLoader.link(SEGMENT$SDL_GPUTextureFormatTexelBlockSize, Descriptors.DESCRIPTOR$SDL_GPUTextureFormatTexelBlockSize);
        SEGMENT$SDL_GPUTextureSupportsFormat = loader.apply("SDL_GPUTextureSupportsFormat");
        HANDLE$SDL_GPUTextureSupportsFormat = RawFunctionLoader.link(SEGMENT$SDL_GPUTextureSupportsFormat, Descriptors.DESCRIPTOR$SDL_GPUTextureSupportsFormat);
        SEGMENT$SDL_GPUTextureSupportsSampleCount = loader.apply("SDL_GPUTextureSupportsSampleCount");
        HANDLE$SDL_GPUTextureSupportsSampleCount = RawFunctionLoader.link(SEGMENT$SDL_GPUTextureSupportsSampleCount, Descriptors.DESCRIPTOR$SDL_GPUTextureSupportsSampleCount);
        SEGMENT$SDL_CalculateGPUTextureFormatSize = loader.apply("SDL_CalculateGPUTextureFormatSize");
        HANDLE$SDL_CalculateGPUTextureFormatSize = RawFunctionLoader.link(SEGMENT$SDL_CalculateGPUTextureFormatSize, Descriptors.DESCRIPTOR$SDL_CalculateGPUTextureFormatSize);
        SEGMENT$SDL_GDKSuspendGPU = loader.apply("SDL_GDKSuspendGPU");
        HANDLE$SDL_GDKSuspendGPU = RawFunctionLoader.link(SEGMENT$SDL_GDKSuspendGPU, Descriptors.DESCRIPTOR$SDL_GDKSuspendGPU);
        SEGMENT$SDL_GDKResumeGPU = loader.apply("SDL_GDKResumeGPU");
        HANDLE$SDL_GDKResumeGPU = RawFunctionLoader.link(SEGMENT$SDL_GDKResumeGPU, Descriptors.DESCRIPTOR$SDL_GDKResumeGPU);
        SEGMENT$SDL_GUIDToString = loader.apply("SDL_GUIDToString");
        HANDLE$SDL_GUIDToString = RawFunctionLoader.link(SEGMENT$SDL_GUIDToString, Descriptors.DESCRIPTOR$SDL_GUIDToString);
        SEGMENT$SDL_StringToGUID = loader.apply("SDL_StringToGUID");
        HANDLE$SDL_StringToGUID = RawFunctionLoader.link(SEGMENT$SDL_StringToGUID, Descriptors.DESCRIPTOR$SDL_StringToGUID);
        SEGMENT$SDL_GetHaptics = loader.apply("SDL_GetHaptics");
        HANDLE$SDL_GetHaptics = RawFunctionLoader.link(SEGMENT$SDL_GetHaptics, Descriptors.DESCRIPTOR$SDL_GetHaptics);
        SEGMENT$SDL_GetHapticNameForID = loader.apply("SDL_GetHapticNameForID");
        HANDLE$SDL_GetHapticNameForID = RawFunctionLoader.link(SEGMENT$SDL_GetHapticNameForID, Descriptors.DESCRIPTOR$SDL_GetHapticNameForID);
        SEGMENT$SDL_OpenHaptic = loader.apply("SDL_OpenHaptic");
        HANDLE$SDL_OpenHaptic = RawFunctionLoader.link(SEGMENT$SDL_OpenHaptic, Descriptors.DESCRIPTOR$SDL_OpenHaptic);
        SEGMENT$SDL_GetHapticFromID = loader.apply("SDL_GetHapticFromID");
        HANDLE$SDL_GetHapticFromID = RawFunctionLoader.link(SEGMENT$SDL_GetHapticFromID, Descriptors.DESCRIPTOR$SDL_GetHapticFromID);
        SEGMENT$SDL_GetHapticID = loader.apply("SDL_GetHapticID");
        HANDLE$SDL_GetHapticID = RawFunctionLoader.link(SEGMENT$SDL_GetHapticID, Descriptors.DESCRIPTOR$SDL_GetHapticID);
        SEGMENT$SDL_GetHapticName = loader.apply("SDL_GetHapticName");
        HANDLE$SDL_GetHapticName = RawFunctionLoader.link(SEGMENT$SDL_GetHapticName, Descriptors.DESCRIPTOR$SDL_GetHapticName);
        SEGMENT$SDL_IsMouseHaptic = loader.apply("SDL_IsMouseHaptic");
        HANDLE$SDL_IsMouseHaptic = RawFunctionLoader.link(SEGMENT$SDL_IsMouseHaptic, Descriptors.DESCRIPTOR$SDL_IsMouseHaptic);
        SEGMENT$SDL_OpenHapticFromMouse = loader.apply("SDL_OpenHapticFromMouse");
        HANDLE$SDL_OpenHapticFromMouse = RawFunctionLoader.link(SEGMENT$SDL_OpenHapticFromMouse, Descriptors.DESCRIPTOR$SDL_OpenHapticFromMouse);
        SEGMENT$SDL_IsJoystickHaptic = loader.apply("SDL_IsJoystickHaptic");
        HANDLE$SDL_IsJoystickHaptic = RawFunctionLoader.link(SEGMENT$SDL_IsJoystickHaptic, Descriptors.DESCRIPTOR$SDL_IsJoystickHaptic);
        SEGMENT$SDL_OpenHapticFromJoystick = loader.apply("SDL_OpenHapticFromJoystick");
        HANDLE$SDL_OpenHapticFromJoystick = RawFunctionLoader.link(SEGMENT$SDL_OpenHapticFromJoystick, Descriptors.DESCRIPTOR$SDL_OpenHapticFromJoystick);
        SEGMENT$SDL_CloseHaptic = loader.apply("SDL_CloseHaptic");
        HANDLE$SDL_CloseHaptic = RawFunctionLoader.link(SEGMENT$SDL_CloseHaptic, Descriptors.DESCRIPTOR$SDL_CloseHaptic);
        SEGMENT$SDL_GetMaxHapticEffects = loader.apply("SDL_GetMaxHapticEffects");
        HANDLE$SDL_GetMaxHapticEffects = RawFunctionLoader.link(SEGMENT$SDL_GetMaxHapticEffects, Descriptors.DESCRIPTOR$SDL_GetMaxHapticEffects);
        SEGMENT$SDL_GetMaxHapticEffectsPlaying = loader.apply("SDL_GetMaxHapticEffectsPlaying");
        HANDLE$SDL_GetMaxHapticEffectsPlaying = RawFunctionLoader.link(SEGMENT$SDL_GetMaxHapticEffectsPlaying, Descriptors.DESCRIPTOR$SDL_GetMaxHapticEffectsPlaying);
        SEGMENT$SDL_GetHapticFeatures = loader.apply("SDL_GetHapticFeatures");
        HANDLE$SDL_GetHapticFeatures = RawFunctionLoader.link(SEGMENT$SDL_GetHapticFeatures, Descriptors.DESCRIPTOR$SDL_GetHapticFeatures);
        SEGMENT$SDL_GetNumHapticAxes = loader.apply("SDL_GetNumHapticAxes");
        HANDLE$SDL_GetNumHapticAxes = RawFunctionLoader.link(SEGMENT$SDL_GetNumHapticAxes, Descriptors.DESCRIPTOR$SDL_GetNumHapticAxes);
        SEGMENT$SDL_HapticEffectSupported = loader.apply("SDL_HapticEffectSupported");
        HANDLE$SDL_HapticEffectSupported = RawFunctionLoader.link(SEGMENT$SDL_HapticEffectSupported, Descriptors.DESCRIPTOR$SDL_HapticEffectSupported);
        SEGMENT$SDL_CreateHapticEffect = loader.apply("SDL_CreateHapticEffect");
        HANDLE$SDL_CreateHapticEffect = RawFunctionLoader.link(SEGMENT$SDL_CreateHapticEffect, Descriptors.DESCRIPTOR$SDL_CreateHapticEffect);
        SEGMENT$SDL_UpdateHapticEffect = loader.apply("SDL_UpdateHapticEffect");
        HANDLE$SDL_UpdateHapticEffect = RawFunctionLoader.link(SEGMENT$SDL_UpdateHapticEffect, Descriptors.DESCRIPTOR$SDL_UpdateHapticEffect);
        SEGMENT$SDL_RunHapticEffect = loader.apply("SDL_RunHapticEffect");
        HANDLE$SDL_RunHapticEffect = RawFunctionLoader.link(SEGMENT$SDL_RunHapticEffect, Descriptors.DESCRIPTOR$SDL_RunHapticEffect);
        SEGMENT$SDL_StopHapticEffect = loader.apply("SDL_StopHapticEffect");
        HANDLE$SDL_StopHapticEffect = RawFunctionLoader.link(SEGMENT$SDL_StopHapticEffect, Descriptors.DESCRIPTOR$SDL_StopHapticEffect);
        SEGMENT$SDL_DestroyHapticEffect = loader.apply("SDL_DestroyHapticEffect");
        HANDLE$SDL_DestroyHapticEffect = RawFunctionLoader.link(SEGMENT$SDL_DestroyHapticEffect, Descriptors.DESCRIPTOR$SDL_DestroyHapticEffect);
        SEGMENT$SDL_GetHapticEffectStatus = loader.apply("SDL_GetHapticEffectStatus");
        HANDLE$SDL_GetHapticEffectStatus = RawFunctionLoader.link(SEGMENT$SDL_GetHapticEffectStatus, Descriptors.DESCRIPTOR$SDL_GetHapticEffectStatus);
        SEGMENT$SDL_SetHapticGain = loader.apply("SDL_SetHapticGain");
        HANDLE$SDL_SetHapticGain = RawFunctionLoader.link(SEGMENT$SDL_SetHapticGain, Descriptors.DESCRIPTOR$SDL_SetHapticGain);
        SEGMENT$SDL_SetHapticAutocenter = loader.apply("SDL_SetHapticAutocenter");
        HANDLE$SDL_SetHapticAutocenter = RawFunctionLoader.link(SEGMENT$SDL_SetHapticAutocenter, Descriptors.DESCRIPTOR$SDL_SetHapticAutocenter);
        SEGMENT$SDL_PauseHaptic = loader.apply("SDL_PauseHaptic");
        HANDLE$SDL_PauseHaptic = RawFunctionLoader.link(SEGMENT$SDL_PauseHaptic, Descriptors.DESCRIPTOR$SDL_PauseHaptic);
        SEGMENT$SDL_ResumeHaptic = loader.apply("SDL_ResumeHaptic");
        HANDLE$SDL_ResumeHaptic = RawFunctionLoader.link(SEGMENT$SDL_ResumeHaptic, Descriptors.DESCRIPTOR$SDL_ResumeHaptic);
        SEGMENT$SDL_StopHapticEffects = loader.apply("SDL_StopHapticEffects");
        HANDLE$SDL_StopHapticEffects = RawFunctionLoader.link(SEGMENT$SDL_StopHapticEffects, Descriptors.DESCRIPTOR$SDL_StopHapticEffects);
        SEGMENT$SDL_HapticRumbleSupported = loader.apply("SDL_HapticRumbleSupported");
        HANDLE$SDL_HapticRumbleSupported = RawFunctionLoader.link(SEGMENT$SDL_HapticRumbleSupported, Descriptors.DESCRIPTOR$SDL_HapticRumbleSupported);
        SEGMENT$SDL_InitHapticRumble = loader.apply("SDL_InitHapticRumble");
        HANDLE$SDL_InitHapticRumble = RawFunctionLoader.link(SEGMENT$SDL_InitHapticRumble, Descriptors.DESCRIPTOR$SDL_InitHapticRumble);
        SEGMENT$SDL_PlayHapticRumble = loader.apply("SDL_PlayHapticRumble");
        HANDLE$SDL_PlayHapticRumble = RawFunctionLoader.link(SEGMENT$SDL_PlayHapticRumble, Descriptors.DESCRIPTOR$SDL_PlayHapticRumble);
        SEGMENT$SDL_StopHapticRumble = loader.apply("SDL_StopHapticRumble");
        HANDLE$SDL_StopHapticRumble = RawFunctionLoader.link(SEGMENT$SDL_StopHapticRumble, Descriptors.DESCRIPTOR$SDL_StopHapticRumble);
        SEGMENT$SDL_hid_init = loader.apply("SDL_hid_init");
        HANDLE$SDL_hid_init = RawFunctionLoader.link(SEGMENT$SDL_hid_init, Descriptors.DESCRIPTOR$SDL_hid_init);
        SEGMENT$SDL_hid_exit = loader.apply("SDL_hid_exit");
        HANDLE$SDL_hid_exit = RawFunctionLoader.link(SEGMENT$SDL_hid_exit, Descriptors.DESCRIPTOR$SDL_hid_exit);
        SEGMENT$SDL_hid_device_change_count = loader.apply("SDL_hid_device_change_count");
        HANDLE$SDL_hid_device_change_count = RawFunctionLoader.link(SEGMENT$SDL_hid_device_change_count, Descriptors.DESCRIPTOR$SDL_hid_device_change_count);
        SEGMENT$SDL_hid_enumerate = loader.apply("SDL_hid_enumerate");
        HANDLE$SDL_hid_enumerate = RawFunctionLoader.link(SEGMENT$SDL_hid_enumerate, Descriptors.DESCRIPTOR$SDL_hid_enumerate);
        SEGMENT$SDL_hid_free_enumeration = loader.apply("SDL_hid_free_enumeration");
        HANDLE$SDL_hid_free_enumeration = RawFunctionLoader.link(SEGMENT$SDL_hid_free_enumeration, Descriptors.DESCRIPTOR$SDL_hid_free_enumeration);
        SEGMENT$SDL_hid_open = loader.apply("SDL_hid_open");
        HANDLE$SDL_hid_open = RawFunctionLoader.link(SEGMENT$SDL_hid_open, Descriptors.DESCRIPTOR$SDL_hid_open);
        SEGMENT$SDL_hid_open_path = loader.apply("SDL_hid_open_path");
        HANDLE$SDL_hid_open_path = RawFunctionLoader.link(SEGMENT$SDL_hid_open_path, Descriptors.DESCRIPTOR$SDL_hid_open_path);
        SEGMENT$SDL_hid_write = loader.apply("SDL_hid_write");
        HANDLE$SDL_hid_write = RawFunctionLoader.link(SEGMENT$SDL_hid_write, Descriptors.DESCRIPTOR$SDL_hid_write);
        SEGMENT$SDL_hid_read_timeout = loader.apply("SDL_hid_read_timeout");
        HANDLE$SDL_hid_read_timeout = RawFunctionLoader.link(SEGMENT$SDL_hid_read_timeout, Descriptors.DESCRIPTOR$SDL_hid_read_timeout);
        SEGMENT$SDL_hid_read = loader.apply("SDL_hid_read");
        HANDLE$SDL_hid_read = RawFunctionLoader.link(SEGMENT$SDL_hid_read, Descriptors.DESCRIPTOR$SDL_hid_read);
        SEGMENT$SDL_hid_set_nonblocking = loader.apply("SDL_hid_set_nonblocking");
        HANDLE$SDL_hid_set_nonblocking = RawFunctionLoader.link(SEGMENT$SDL_hid_set_nonblocking, Descriptors.DESCRIPTOR$SDL_hid_set_nonblocking);
        SEGMENT$SDL_hid_send_feature_report = loader.apply("SDL_hid_send_feature_report");
        HANDLE$SDL_hid_send_feature_report = RawFunctionLoader.link(SEGMENT$SDL_hid_send_feature_report, Descriptors.DESCRIPTOR$SDL_hid_send_feature_report);
        SEGMENT$SDL_hid_get_feature_report = loader.apply("SDL_hid_get_feature_report");
        HANDLE$SDL_hid_get_feature_report = RawFunctionLoader.link(SEGMENT$SDL_hid_get_feature_report, Descriptors.DESCRIPTOR$SDL_hid_get_feature_report);
        SEGMENT$SDL_hid_get_input_report = loader.apply("SDL_hid_get_input_report");
        HANDLE$SDL_hid_get_input_report = RawFunctionLoader.link(SEGMENT$SDL_hid_get_input_report, Descriptors.DESCRIPTOR$SDL_hid_get_input_report);
        SEGMENT$SDL_hid_close = loader.apply("SDL_hid_close");
        HANDLE$SDL_hid_close = RawFunctionLoader.link(SEGMENT$SDL_hid_close, Descriptors.DESCRIPTOR$SDL_hid_close);
        SEGMENT$SDL_hid_get_manufacturer_string = loader.apply("SDL_hid_get_manufacturer_string");
        HANDLE$SDL_hid_get_manufacturer_string = RawFunctionLoader.link(SEGMENT$SDL_hid_get_manufacturer_string, Descriptors.DESCRIPTOR$SDL_hid_get_manufacturer_string);
        SEGMENT$SDL_hid_get_product_string = loader.apply("SDL_hid_get_product_string");
        HANDLE$SDL_hid_get_product_string = RawFunctionLoader.link(SEGMENT$SDL_hid_get_product_string, Descriptors.DESCRIPTOR$SDL_hid_get_product_string);
        SEGMENT$SDL_hid_get_serial_number_string = loader.apply("SDL_hid_get_serial_number_string");
        HANDLE$SDL_hid_get_serial_number_string = RawFunctionLoader.link(SEGMENT$SDL_hid_get_serial_number_string, Descriptors.DESCRIPTOR$SDL_hid_get_serial_number_string);
        SEGMENT$SDL_hid_get_indexed_string = loader.apply("SDL_hid_get_indexed_string");
        HANDLE$SDL_hid_get_indexed_string = RawFunctionLoader.link(SEGMENT$SDL_hid_get_indexed_string, Descriptors.DESCRIPTOR$SDL_hid_get_indexed_string);
        SEGMENT$SDL_hid_get_device_info = loader.apply("SDL_hid_get_device_info");
        HANDLE$SDL_hid_get_device_info = RawFunctionLoader.link(SEGMENT$SDL_hid_get_device_info, Descriptors.DESCRIPTOR$SDL_hid_get_device_info);
        SEGMENT$SDL_hid_get_report_descriptor = loader.apply("SDL_hid_get_report_descriptor");
        HANDLE$SDL_hid_get_report_descriptor = RawFunctionLoader.link(SEGMENT$SDL_hid_get_report_descriptor, Descriptors.DESCRIPTOR$SDL_hid_get_report_descriptor);
        SEGMENT$SDL_hid_ble_scan = loader.apply("SDL_hid_ble_scan");
        HANDLE$SDL_hid_ble_scan = RawFunctionLoader.link(SEGMENT$SDL_hid_ble_scan, Descriptors.DESCRIPTOR$SDL_hid_ble_scan);
        SEGMENT$SDL_SetHintWithPriority = loader.apply("SDL_SetHintWithPriority");
        HANDLE$SDL_SetHintWithPriority = RawFunctionLoader.link(SEGMENT$SDL_SetHintWithPriority, Descriptors.DESCRIPTOR$SDL_SetHintWithPriority);
        SEGMENT$SDL_SetHint = loader.apply("SDL_SetHint");
        HANDLE$SDL_SetHint = RawFunctionLoader.link(SEGMENT$SDL_SetHint, Descriptors.DESCRIPTOR$SDL_SetHint);
        SEGMENT$SDL_ResetHint = loader.apply("SDL_ResetHint");
        HANDLE$SDL_ResetHint = RawFunctionLoader.link(SEGMENT$SDL_ResetHint, Descriptors.DESCRIPTOR$SDL_ResetHint);
        SEGMENT$SDL_ResetHints = loader.apply("SDL_ResetHints");
        HANDLE$SDL_ResetHints = RawFunctionLoader.link(SEGMENT$SDL_ResetHints, Descriptors.DESCRIPTOR$SDL_ResetHints);
        SEGMENT$SDL_GetHint = loader.apply("SDL_GetHint");
        HANDLE$SDL_GetHint = RawFunctionLoader.link(SEGMENT$SDL_GetHint, Descriptors.DESCRIPTOR$SDL_GetHint);
        SEGMENT$SDL_GetHintBoolean = loader.apply("SDL_GetHintBoolean");
        HANDLE$SDL_GetHintBoolean = RawFunctionLoader.link(SEGMENT$SDL_GetHintBoolean, Descriptors.DESCRIPTOR$SDL_GetHintBoolean);
        SEGMENT$SDL_AddHintCallback = loader.apply("SDL_AddHintCallback");
        HANDLE$SDL_AddHintCallback = RawFunctionLoader.link(SEGMENT$SDL_AddHintCallback, Descriptors.DESCRIPTOR$SDL_AddHintCallback);
        SEGMENT$SDL_RemoveHintCallback = loader.apply("SDL_RemoveHintCallback");
        HANDLE$SDL_RemoveHintCallback = RawFunctionLoader.link(SEGMENT$SDL_RemoveHintCallback, Descriptors.DESCRIPTOR$SDL_RemoveHintCallback);
        SEGMENT$SDL_Init = loader.apply("SDL_Init");
        HANDLE$SDL_Init = RawFunctionLoader.link(SEGMENT$SDL_Init, Descriptors.DESCRIPTOR$SDL_Init);
        SEGMENT$SDL_InitSubSystem = loader.apply("SDL_InitSubSystem");
        HANDLE$SDL_InitSubSystem = RawFunctionLoader.link(SEGMENT$SDL_InitSubSystem, Descriptors.DESCRIPTOR$SDL_InitSubSystem);
        SEGMENT$SDL_QuitSubSystem = loader.apply("SDL_QuitSubSystem");
        HANDLE$SDL_QuitSubSystem = RawFunctionLoader.link(SEGMENT$SDL_QuitSubSystem, Descriptors.DESCRIPTOR$SDL_QuitSubSystem);
        SEGMENT$SDL_WasInit = loader.apply("SDL_WasInit");
        HANDLE$SDL_WasInit = RawFunctionLoader.link(SEGMENT$SDL_WasInit, Descriptors.DESCRIPTOR$SDL_WasInit);
        SEGMENT$SDL_Quit = loader.apply("SDL_Quit");
        HANDLE$SDL_Quit = RawFunctionLoader.link(SEGMENT$SDL_Quit, Descriptors.DESCRIPTOR$SDL_Quit);
        SEGMENT$SDL_IsMainThread = loader.apply("SDL_IsMainThread");
        HANDLE$SDL_IsMainThread = RawFunctionLoader.link(SEGMENT$SDL_IsMainThread, Descriptors.DESCRIPTOR$SDL_IsMainThread);
        SEGMENT$SDL_RunOnMainThread = loader.apply("SDL_RunOnMainThread");
        HANDLE$SDL_RunOnMainThread = RawFunctionLoader.link(SEGMENT$SDL_RunOnMainThread, Descriptors.DESCRIPTOR$SDL_RunOnMainThread);
        SEGMENT$SDL_SetAppMetadata = loader.apply("SDL_SetAppMetadata");
        HANDLE$SDL_SetAppMetadata = RawFunctionLoader.link(SEGMENT$SDL_SetAppMetadata, Descriptors.DESCRIPTOR$SDL_SetAppMetadata);
        SEGMENT$SDL_SetAppMetadataProperty = loader.apply("SDL_SetAppMetadataProperty");
        HANDLE$SDL_SetAppMetadataProperty = RawFunctionLoader.link(SEGMENT$SDL_SetAppMetadataProperty, Descriptors.DESCRIPTOR$SDL_SetAppMetadataProperty);
        SEGMENT$SDL_GetAppMetadataProperty = loader.apply("SDL_GetAppMetadataProperty");
        HANDLE$SDL_GetAppMetadataProperty = RawFunctionLoader.link(SEGMENT$SDL_GetAppMetadataProperty, Descriptors.DESCRIPTOR$SDL_GetAppMetadataProperty);
        SEGMENT$SDL_IOFromFile = loader.apply("SDL_IOFromFile");
        HANDLE$SDL_IOFromFile = RawFunctionLoader.link(SEGMENT$SDL_IOFromFile, Descriptors.DESCRIPTOR$SDL_IOFromFile);
        SEGMENT$SDL_IOFromMem = loader.apply("SDL_IOFromMem");
        HANDLE$SDL_IOFromMem = RawFunctionLoader.link(SEGMENT$SDL_IOFromMem, Descriptors.DESCRIPTOR$SDL_IOFromMem);
        SEGMENT$SDL_IOFromConstMem = loader.apply("SDL_IOFromConstMem");
        HANDLE$SDL_IOFromConstMem = RawFunctionLoader.link(SEGMENT$SDL_IOFromConstMem, Descriptors.DESCRIPTOR$SDL_IOFromConstMem);
        SEGMENT$SDL_IOFromDynamicMem = loader.apply("SDL_IOFromDynamicMem");
        HANDLE$SDL_IOFromDynamicMem = RawFunctionLoader.link(SEGMENT$SDL_IOFromDynamicMem, Descriptors.DESCRIPTOR$SDL_IOFromDynamicMem);
        SEGMENT$SDL_OpenIO = loader.apply("SDL_OpenIO");
        HANDLE$SDL_OpenIO = RawFunctionLoader.link(SEGMENT$SDL_OpenIO, Descriptors.DESCRIPTOR$SDL_OpenIO);
        SEGMENT$SDL_CloseIO = loader.apply("SDL_CloseIO");
        HANDLE$SDL_CloseIO = RawFunctionLoader.link(SEGMENT$SDL_CloseIO, Descriptors.DESCRIPTOR$SDL_CloseIO);
        SEGMENT$SDL_GetIOProperties = loader.apply("SDL_GetIOProperties");
        HANDLE$SDL_GetIOProperties = RawFunctionLoader.link(SEGMENT$SDL_GetIOProperties, Descriptors.DESCRIPTOR$SDL_GetIOProperties);
        SEGMENT$SDL_GetIOStatus = loader.apply("SDL_GetIOStatus");
        HANDLE$SDL_GetIOStatus = RawFunctionLoader.link(SEGMENT$SDL_GetIOStatus, Descriptors.DESCRIPTOR$SDL_GetIOStatus);
        SEGMENT$SDL_GetIOSize = loader.apply("SDL_GetIOSize");
        HANDLE$SDL_GetIOSize = RawFunctionLoader.link(SEGMENT$SDL_GetIOSize, Descriptors.DESCRIPTOR$SDL_GetIOSize);
        SEGMENT$SDL_SeekIO = loader.apply("SDL_SeekIO");
        HANDLE$SDL_SeekIO = RawFunctionLoader.link(SEGMENT$SDL_SeekIO, Descriptors.DESCRIPTOR$SDL_SeekIO);
        SEGMENT$SDL_TellIO = loader.apply("SDL_TellIO");
        HANDLE$SDL_TellIO = RawFunctionLoader.link(SEGMENT$SDL_TellIO, Descriptors.DESCRIPTOR$SDL_TellIO);
        SEGMENT$SDL_ReadIO = loader.apply("SDL_ReadIO");
        HANDLE$SDL_ReadIO = RawFunctionLoader.link(SEGMENT$SDL_ReadIO, Descriptors.DESCRIPTOR$SDL_ReadIO);
        SEGMENT$SDL_WriteIO = loader.apply("SDL_WriteIO");
        HANDLE$SDL_WriteIO = RawFunctionLoader.link(SEGMENT$SDL_WriteIO, Descriptors.DESCRIPTOR$SDL_WriteIO);
        SEGMENT$SDL_FlushIO = loader.apply("SDL_FlushIO");
        HANDLE$SDL_FlushIO = RawFunctionLoader.link(SEGMENT$SDL_FlushIO, Descriptors.DESCRIPTOR$SDL_FlushIO);
        SEGMENT$SDL_LoadFile_IO = loader.apply("SDL_LoadFile_IO");
        HANDLE$SDL_LoadFile_IO = RawFunctionLoader.link(SEGMENT$SDL_LoadFile_IO, Descriptors.DESCRIPTOR$SDL_LoadFile_IO);
        SEGMENT$SDL_LoadFile = loader.apply("SDL_LoadFile");
        HANDLE$SDL_LoadFile = RawFunctionLoader.link(SEGMENT$SDL_LoadFile, Descriptors.DESCRIPTOR$SDL_LoadFile);
        SEGMENT$SDL_SaveFile_IO = loader.apply("SDL_SaveFile_IO");
        HANDLE$SDL_SaveFile_IO = RawFunctionLoader.link(SEGMENT$SDL_SaveFile_IO, Descriptors.DESCRIPTOR$SDL_SaveFile_IO);
        SEGMENT$SDL_SaveFile = loader.apply("SDL_SaveFile");
        HANDLE$SDL_SaveFile = RawFunctionLoader.link(SEGMENT$SDL_SaveFile, Descriptors.DESCRIPTOR$SDL_SaveFile);
        SEGMENT$SDL_ReadU8 = loader.apply("SDL_ReadU8");
        HANDLE$SDL_ReadU8 = RawFunctionLoader.link(SEGMENT$SDL_ReadU8, Descriptors.DESCRIPTOR$SDL_ReadU8);
        SEGMENT$SDL_ReadS8 = loader.apply("SDL_ReadS8");
        HANDLE$SDL_ReadS8 = RawFunctionLoader.link(SEGMENT$SDL_ReadS8, Descriptors.DESCRIPTOR$SDL_ReadS8);
        SEGMENT$SDL_ReadU16LE = loader.apply("SDL_ReadU16LE");
        HANDLE$SDL_ReadU16LE = RawFunctionLoader.link(SEGMENT$SDL_ReadU16LE, Descriptors.DESCRIPTOR$SDL_ReadU16LE);
        SEGMENT$SDL_ReadS16LE = loader.apply("SDL_ReadS16LE");
        HANDLE$SDL_ReadS16LE = RawFunctionLoader.link(SEGMENT$SDL_ReadS16LE, Descriptors.DESCRIPTOR$SDL_ReadS16LE);
        SEGMENT$SDL_ReadU16BE = loader.apply("SDL_ReadU16BE");
        HANDLE$SDL_ReadU16BE = RawFunctionLoader.link(SEGMENT$SDL_ReadU16BE, Descriptors.DESCRIPTOR$SDL_ReadU16BE);
        SEGMENT$SDL_ReadS16BE = loader.apply("SDL_ReadS16BE");
        HANDLE$SDL_ReadS16BE = RawFunctionLoader.link(SEGMENT$SDL_ReadS16BE, Descriptors.DESCRIPTOR$SDL_ReadS16BE);
        SEGMENT$SDL_ReadU32LE = loader.apply("SDL_ReadU32LE");
        HANDLE$SDL_ReadU32LE = RawFunctionLoader.link(SEGMENT$SDL_ReadU32LE, Descriptors.DESCRIPTOR$SDL_ReadU32LE);
        SEGMENT$SDL_ReadS32LE = loader.apply("SDL_ReadS32LE");
        HANDLE$SDL_ReadS32LE = RawFunctionLoader.link(SEGMENT$SDL_ReadS32LE, Descriptors.DESCRIPTOR$SDL_ReadS32LE);
        SEGMENT$SDL_ReadU32BE = loader.apply("SDL_ReadU32BE");
        HANDLE$SDL_ReadU32BE = RawFunctionLoader.link(SEGMENT$SDL_ReadU32BE, Descriptors.DESCRIPTOR$SDL_ReadU32BE);
        SEGMENT$SDL_ReadS32BE = loader.apply("SDL_ReadS32BE");
        HANDLE$SDL_ReadS32BE = RawFunctionLoader.link(SEGMENT$SDL_ReadS32BE, Descriptors.DESCRIPTOR$SDL_ReadS32BE);
        SEGMENT$SDL_ReadU64LE = loader.apply("SDL_ReadU64LE");
        HANDLE$SDL_ReadU64LE = RawFunctionLoader.link(SEGMENT$SDL_ReadU64LE, Descriptors.DESCRIPTOR$SDL_ReadU64LE);
        SEGMENT$SDL_ReadS64LE = loader.apply("SDL_ReadS64LE");
        HANDLE$SDL_ReadS64LE = RawFunctionLoader.link(SEGMENT$SDL_ReadS64LE, Descriptors.DESCRIPTOR$SDL_ReadS64LE);
        SEGMENT$SDL_ReadU64BE = loader.apply("SDL_ReadU64BE");
        HANDLE$SDL_ReadU64BE = RawFunctionLoader.link(SEGMENT$SDL_ReadU64BE, Descriptors.DESCRIPTOR$SDL_ReadU64BE);
        SEGMENT$SDL_ReadS64BE = loader.apply("SDL_ReadS64BE");
        HANDLE$SDL_ReadS64BE = RawFunctionLoader.link(SEGMENT$SDL_ReadS64BE, Descriptors.DESCRIPTOR$SDL_ReadS64BE);
        SEGMENT$SDL_WriteU8 = loader.apply("SDL_WriteU8");
        HANDLE$SDL_WriteU8 = RawFunctionLoader.link(SEGMENT$SDL_WriteU8, Descriptors.DESCRIPTOR$SDL_WriteU8);
        SEGMENT$SDL_WriteS8 = loader.apply("SDL_WriteS8");
        HANDLE$SDL_WriteS8 = RawFunctionLoader.link(SEGMENT$SDL_WriteS8, Descriptors.DESCRIPTOR$SDL_WriteS8);
        SEGMENT$SDL_WriteU16LE = loader.apply("SDL_WriteU16LE");
        HANDLE$SDL_WriteU16LE = RawFunctionLoader.link(SEGMENT$SDL_WriteU16LE, Descriptors.DESCRIPTOR$SDL_WriteU16LE);
        SEGMENT$SDL_WriteS16LE = loader.apply("SDL_WriteS16LE");
        HANDLE$SDL_WriteS16LE = RawFunctionLoader.link(SEGMENT$SDL_WriteS16LE, Descriptors.DESCRIPTOR$SDL_WriteS16LE);
        SEGMENT$SDL_WriteU16BE = loader.apply("SDL_WriteU16BE");
        HANDLE$SDL_WriteU16BE = RawFunctionLoader.link(SEGMENT$SDL_WriteU16BE, Descriptors.DESCRIPTOR$SDL_WriteU16BE);
        SEGMENT$SDL_WriteS16BE = loader.apply("SDL_WriteS16BE");
        HANDLE$SDL_WriteS16BE = RawFunctionLoader.link(SEGMENT$SDL_WriteS16BE, Descriptors.DESCRIPTOR$SDL_WriteS16BE);
        SEGMENT$SDL_WriteU32LE = loader.apply("SDL_WriteU32LE");
        HANDLE$SDL_WriteU32LE = RawFunctionLoader.link(SEGMENT$SDL_WriteU32LE, Descriptors.DESCRIPTOR$SDL_WriteU32LE);
        SEGMENT$SDL_WriteS32LE = loader.apply("SDL_WriteS32LE");
        HANDLE$SDL_WriteS32LE = RawFunctionLoader.link(SEGMENT$SDL_WriteS32LE, Descriptors.DESCRIPTOR$SDL_WriteS32LE);
        SEGMENT$SDL_WriteU32BE = loader.apply("SDL_WriteU32BE");
        HANDLE$SDL_WriteU32BE = RawFunctionLoader.link(SEGMENT$SDL_WriteU32BE, Descriptors.DESCRIPTOR$SDL_WriteU32BE);
        SEGMENT$SDL_WriteS32BE = loader.apply("SDL_WriteS32BE");
        HANDLE$SDL_WriteS32BE = RawFunctionLoader.link(SEGMENT$SDL_WriteS32BE, Descriptors.DESCRIPTOR$SDL_WriteS32BE);
        SEGMENT$SDL_WriteU64LE = loader.apply("SDL_WriteU64LE");
        HANDLE$SDL_WriteU64LE = RawFunctionLoader.link(SEGMENT$SDL_WriteU64LE, Descriptors.DESCRIPTOR$SDL_WriteU64LE);
        SEGMENT$SDL_WriteS64LE = loader.apply("SDL_WriteS64LE");
        HANDLE$SDL_WriteS64LE = RawFunctionLoader.link(SEGMENT$SDL_WriteS64LE, Descriptors.DESCRIPTOR$SDL_WriteS64LE);
        SEGMENT$SDL_WriteU64BE = loader.apply("SDL_WriteU64BE");
        HANDLE$SDL_WriteU64BE = RawFunctionLoader.link(SEGMENT$SDL_WriteU64BE, Descriptors.DESCRIPTOR$SDL_WriteU64BE);
        SEGMENT$SDL_WriteS64BE = loader.apply("SDL_WriteS64BE");
        HANDLE$SDL_WriteS64BE = RawFunctionLoader.link(SEGMENT$SDL_WriteS64BE, Descriptors.DESCRIPTOR$SDL_WriteS64BE);
        SEGMENT$SDL_LockJoysticks = loader.apply("SDL_LockJoysticks");
        HANDLE$SDL_LockJoysticks = RawFunctionLoader.link(SEGMENT$SDL_LockJoysticks, Descriptors.DESCRIPTOR$SDL_LockJoysticks);
        SEGMENT$SDL_UnlockJoysticks = loader.apply("SDL_UnlockJoysticks");
        HANDLE$SDL_UnlockJoysticks = RawFunctionLoader.link(SEGMENT$SDL_UnlockJoysticks, Descriptors.DESCRIPTOR$SDL_UnlockJoysticks);
        SEGMENT$SDL_HasJoystick = loader.apply("SDL_HasJoystick");
        HANDLE$SDL_HasJoystick = RawFunctionLoader.link(SEGMENT$SDL_HasJoystick, Descriptors.DESCRIPTOR$SDL_HasJoystick);
        SEGMENT$SDL_GetJoysticks = loader.apply("SDL_GetJoysticks");
        HANDLE$SDL_GetJoysticks = RawFunctionLoader.link(SEGMENT$SDL_GetJoysticks, Descriptors.DESCRIPTOR$SDL_GetJoysticks);
        SEGMENT$SDL_GetJoystickNameForID = loader.apply("SDL_GetJoystickNameForID");
        HANDLE$SDL_GetJoystickNameForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickNameForID, Descriptors.DESCRIPTOR$SDL_GetJoystickNameForID);
        SEGMENT$SDL_GetJoystickPathForID = loader.apply("SDL_GetJoystickPathForID");
        HANDLE$SDL_GetJoystickPathForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickPathForID, Descriptors.DESCRIPTOR$SDL_GetJoystickPathForID);
        SEGMENT$SDL_GetJoystickPlayerIndexForID = loader.apply("SDL_GetJoystickPlayerIndexForID");
        HANDLE$SDL_GetJoystickPlayerIndexForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickPlayerIndexForID, Descriptors.DESCRIPTOR$SDL_GetJoystickPlayerIndexForID);
        SEGMENT$SDL_GetJoystickGUIDForID = loader.apply("SDL_GetJoystickGUIDForID");
        HANDLE$SDL_GetJoystickGUIDForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickGUIDForID, Descriptors.DESCRIPTOR$SDL_GetJoystickGUIDForID);
        SEGMENT$SDL_GetJoystickVendorForID = loader.apply("SDL_GetJoystickVendorForID");
        HANDLE$SDL_GetJoystickVendorForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickVendorForID, Descriptors.DESCRIPTOR$SDL_GetJoystickVendorForID);
        SEGMENT$SDL_GetJoystickProductForID = loader.apply("SDL_GetJoystickProductForID");
        HANDLE$SDL_GetJoystickProductForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickProductForID, Descriptors.DESCRIPTOR$SDL_GetJoystickProductForID);
        SEGMENT$SDL_GetJoystickProductVersionForID = loader.apply("SDL_GetJoystickProductVersionForID");
        HANDLE$SDL_GetJoystickProductVersionForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickProductVersionForID, Descriptors.DESCRIPTOR$SDL_GetJoystickProductVersionForID);
        SEGMENT$SDL_GetJoystickTypeForID = loader.apply("SDL_GetJoystickTypeForID");
        HANDLE$SDL_GetJoystickTypeForID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickTypeForID, Descriptors.DESCRIPTOR$SDL_GetJoystickTypeForID);
        SEGMENT$SDL_OpenJoystick = loader.apply("SDL_OpenJoystick");
        HANDLE$SDL_OpenJoystick = RawFunctionLoader.link(SEGMENT$SDL_OpenJoystick, Descriptors.DESCRIPTOR$SDL_OpenJoystick);
        SEGMENT$SDL_GetJoystickFromID = loader.apply("SDL_GetJoystickFromID");
        HANDLE$SDL_GetJoystickFromID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickFromID, Descriptors.DESCRIPTOR$SDL_GetJoystickFromID);
        SEGMENT$SDL_GetJoystickFromPlayerIndex = loader.apply("SDL_GetJoystickFromPlayerIndex");
        HANDLE$SDL_GetJoystickFromPlayerIndex = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickFromPlayerIndex, Descriptors.DESCRIPTOR$SDL_GetJoystickFromPlayerIndex);
        SEGMENT$SDL_AttachVirtualJoystick = loader.apply("SDL_AttachVirtualJoystick");
        HANDLE$SDL_AttachVirtualJoystick = RawFunctionLoader.link(SEGMENT$SDL_AttachVirtualJoystick, Descriptors.DESCRIPTOR$SDL_AttachVirtualJoystick);
        SEGMENT$SDL_DetachVirtualJoystick = loader.apply("SDL_DetachVirtualJoystick");
        HANDLE$SDL_DetachVirtualJoystick = RawFunctionLoader.link(SEGMENT$SDL_DetachVirtualJoystick, Descriptors.DESCRIPTOR$SDL_DetachVirtualJoystick);
        SEGMENT$SDL_IsJoystickVirtual = loader.apply("SDL_IsJoystickVirtual");
        HANDLE$SDL_IsJoystickVirtual = RawFunctionLoader.link(SEGMENT$SDL_IsJoystickVirtual, Descriptors.DESCRIPTOR$SDL_IsJoystickVirtual);
        SEGMENT$SDL_SetJoystickVirtualAxis = loader.apply("SDL_SetJoystickVirtualAxis");
        HANDLE$SDL_SetJoystickVirtualAxis = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickVirtualAxis, Descriptors.DESCRIPTOR$SDL_SetJoystickVirtualAxis);
        SEGMENT$SDL_SetJoystickVirtualBall = loader.apply("SDL_SetJoystickVirtualBall");
        HANDLE$SDL_SetJoystickVirtualBall = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickVirtualBall, Descriptors.DESCRIPTOR$SDL_SetJoystickVirtualBall);
        SEGMENT$SDL_SetJoystickVirtualButton = loader.apply("SDL_SetJoystickVirtualButton");
        HANDLE$SDL_SetJoystickVirtualButton = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickVirtualButton, Descriptors.DESCRIPTOR$SDL_SetJoystickVirtualButton);
        SEGMENT$SDL_SetJoystickVirtualHat = loader.apply("SDL_SetJoystickVirtualHat");
        HANDLE$SDL_SetJoystickVirtualHat = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickVirtualHat, Descriptors.DESCRIPTOR$SDL_SetJoystickVirtualHat);
        SEGMENT$SDL_SetJoystickVirtualTouchpad = loader.apply("SDL_SetJoystickVirtualTouchpad");
        HANDLE$SDL_SetJoystickVirtualTouchpad = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickVirtualTouchpad, Descriptors.DESCRIPTOR$SDL_SetJoystickVirtualTouchpad);
        SEGMENT$SDL_SendJoystickVirtualSensorData = loader.apply("SDL_SendJoystickVirtualSensorData");
        HANDLE$SDL_SendJoystickVirtualSensorData = RawFunctionLoader.link(SEGMENT$SDL_SendJoystickVirtualSensorData, Descriptors.DESCRIPTOR$SDL_SendJoystickVirtualSensorData);
        SEGMENT$SDL_GetJoystickProperties = loader.apply("SDL_GetJoystickProperties");
        HANDLE$SDL_GetJoystickProperties = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickProperties, Descriptors.DESCRIPTOR$SDL_GetJoystickProperties);
        SEGMENT$SDL_GetJoystickName = loader.apply("SDL_GetJoystickName");
        HANDLE$SDL_GetJoystickName = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickName, Descriptors.DESCRIPTOR$SDL_GetJoystickName);
        SEGMENT$SDL_GetJoystickPath = loader.apply("SDL_GetJoystickPath");
        HANDLE$SDL_GetJoystickPath = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickPath, Descriptors.DESCRIPTOR$SDL_GetJoystickPath);
        SEGMENT$SDL_GetJoystickPlayerIndex = loader.apply("SDL_GetJoystickPlayerIndex");
        HANDLE$SDL_GetJoystickPlayerIndex = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickPlayerIndex, Descriptors.DESCRIPTOR$SDL_GetJoystickPlayerIndex);
        SEGMENT$SDL_SetJoystickPlayerIndex = loader.apply("SDL_SetJoystickPlayerIndex");
        HANDLE$SDL_SetJoystickPlayerIndex = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickPlayerIndex, Descriptors.DESCRIPTOR$SDL_SetJoystickPlayerIndex);
        SEGMENT$SDL_GetJoystickGUID = loader.apply("SDL_GetJoystickGUID");
        HANDLE$SDL_GetJoystickGUID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickGUID, Descriptors.DESCRIPTOR$SDL_GetJoystickGUID);
        SEGMENT$SDL_GetJoystickVendor = loader.apply("SDL_GetJoystickVendor");
        HANDLE$SDL_GetJoystickVendor = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickVendor, Descriptors.DESCRIPTOR$SDL_GetJoystickVendor);
        SEGMENT$SDL_GetJoystickProduct = loader.apply("SDL_GetJoystickProduct");
        HANDLE$SDL_GetJoystickProduct = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickProduct, Descriptors.DESCRIPTOR$SDL_GetJoystickProduct);
        SEGMENT$SDL_GetJoystickProductVersion = loader.apply("SDL_GetJoystickProductVersion");
        HANDLE$SDL_GetJoystickProductVersion = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickProductVersion, Descriptors.DESCRIPTOR$SDL_GetJoystickProductVersion);
        SEGMENT$SDL_GetJoystickFirmwareVersion = loader.apply("SDL_GetJoystickFirmwareVersion");
        HANDLE$SDL_GetJoystickFirmwareVersion = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickFirmwareVersion, Descriptors.DESCRIPTOR$SDL_GetJoystickFirmwareVersion);
        SEGMENT$SDL_GetJoystickSerial = loader.apply("SDL_GetJoystickSerial");
        HANDLE$SDL_GetJoystickSerial = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickSerial, Descriptors.DESCRIPTOR$SDL_GetJoystickSerial);
        SEGMENT$SDL_GetJoystickType = loader.apply("SDL_GetJoystickType");
        HANDLE$SDL_GetJoystickType = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickType, Descriptors.DESCRIPTOR$SDL_GetJoystickType);
        SEGMENT$SDL_GetJoystickGUIDInfo = loader.apply("SDL_GetJoystickGUIDInfo");
        HANDLE$SDL_GetJoystickGUIDInfo = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickGUIDInfo, Descriptors.DESCRIPTOR$SDL_GetJoystickGUIDInfo);
        SEGMENT$SDL_JoystickConnected = loader.apply("SDL_JoystickConnected");
        HANDLE$SDL_JoystickConnected = RawFunctionLoader.link(SEGMENT$SDL_JoystickConnected, Descriptors.DESCRIPTOR$SDL_JoystickConnected);
        SEGMENT$SDL_GetJoystickID = loader.apply("SDL_GetJoystickID");
        HANDLE$SDL_GetJoystickID = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickID, Descriptors.DESCRIPTOR$SDL_GetJoystickID);
        SEGMENT$SDL_GetNumJoystickAxes = loader.apply("SDL_GetNumJoystickAxes");
        HANDLE$SDL_GetNumJoystickAxes = RawFunctionLoader.link(SEGMENT$SDL_GetNumJoystickAxes, Descriptors.DESCRIPTOR$SDL_GetNumJoystickAxes);
        SEGMENT$SDL_GetNumJoystickBalls = loader.apply("SDL_GetNumJoystickBalls");
        HANDLE$SDL_GetNumJoystickBalls = RawFunctionLoader.link(SEGMENT$SDL_GetNumJoystickBalls, Descriptors.DESCRIPTOR$SDL_GetNumJoystickBalls);
        SEGMENT$SDL_GetNumJoystickHats = loader.apply("SDL_GetNumJoystickHats");
        HANDLE$SDL_GetNumJoystickHats = RawFunctionLoader.link(SEGMENT$SDL_GetNumJoystickHats, Descriptors.DESCRIPTOR$SDL_GetNumJoystickHats);
        SEGMENT$SDL_GetNumJoystickButtons = loader.apply("SDL_GetNumJoystickButtons");
        HANDLE$SDL_GetNumJoystickButtons = RawFunctionLoader.link(SEGMENT$SDL_GetNumJoystickButtons, Descriptors.DESCRIPTOR$SDL_GetNumJoystickButtons);
        SEGMENT$SDL_SetJoystickEventsEnabled = loader.apply("SDL_SetJoystickEventsEnabled");
        HANDLE$SDL_SetJoystickEventsEnabled = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickEventsEnabled, Descriptors.DESCRIPTOR$SDL_SetJoystickEventsEnabled);
        SEGMENT$SDL_JoystickEventsEnabled = loader.apply("SDL_JoystickEventsEnabled");
        HANDLE$SDL_JoystickEventsEnabled = RawFunctionLoader.link(SEGMENT$SDL_JoystickEventsEnabled, Descriptors.DESCRIPTOR$SDL_JoystickEventsEnabled);
        SEGMENT$SDL_UpdateJoysticks = loader.apply("SDL_UpdateJoysticks");
        HANDLE$SDL_UpdateJoysticks = RawFunctionLoader.link(SEGMENT$SDL_UpdateJoysticks, Descriptors.DESCRIPTOR$SDL_UpdateJoysticks);
        SEGMENT$SDL_GetJoystickAxis = loader.apply("SDL_GetJoystickAxis");
        HANDLE$SDL_GetJoystickAxis = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickAxis, Descriptors.DESCRIPTOR$SDL_GetJoystickAxis);
        SEGMENT$SDL_GetJoystickAxisInitialState = loader.apply("SDL_GetJoystickAxisInitialState");
        HANDLE$SDL_GetJoystickAxisInitialState = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickAxisInitialState, Descriptors.DESCRIPTOR$SDL_GetJoystickAxisInitialState);
        SEGMENT$SDL_GetJoystickBall = loader.apply("SDL_GetJoystickBall");
        HANDLE$SDL_GetJoystickBall = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickBall, Descriptors.DESCRIPTOR$SDL_GetJoystickBall);
        SEGMENT$SDL_GetJoystickHat = loader.apply("SDL_GetJoystickHat");
        HANDLE$SDL_GetJoystickHat = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickHat, Descriptors.DESCRIPTOR$SDL_GetJoystickHat);
        SEGMENT$SDL_GetJoystickButton = loader.apply("SDL_GetJoystickButton");
        HANDLE$SDL_GetJoystickButton = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickButton, Descriptors.DESCRIPTOR$SDL_GetJoystickButton);
        SEGMENT$SDL_RumbleJoystick = loader.apply("SDL_RumbleJoystick");
        HANDLE$SDL_RumbleJoystick = RawFunctionLoader.link(SEGMENT$SDL_RumbleJoystick, Descriptors.DESCRIPTOR$SDL_RumbleJoystick);
        SEGMENT$SDL_RumbleJoystickTriggers = loader.apply("SDL_RumbleJoystickTriggers");
        HANDLE$SDL_RumbleJoystickTriggers = RawFunctionLoader.link(SEGMENT$SDL_RumbleJoystickTriggers, Descriptors.DESCRIPTOR$SDL_RumbleJoystickTriggers);
        SEGMENT$SDL_SetJoystickLED = loader.apply("SDL_SetJoystickLED");
        HANDLE$SDL_SetJoystickLED = RawFunctionLoader.link(SEGMENT$SDL_SetJoystickLED, Descriptors.DESCRIPTOR$SDL_SetJoystickLED);
        SEGMENT$SDL_SendJoystickEffect = loader.apply("SDL_SendJoystickEffect");
        HANDLE$SDL_SendJoystickEffect = RawFunctionLoader.link(SEGMENT$SDL_SendJoystickEffect, Descriptors.DESCRIPTOR$SDL_SendJoystickEffect);
        SEGMENT$SDL_CloseJoystick = loader.apply("SDL_CloseJoystick");
        HANDLE$SDL_CloseJoystick = RawFunctionLoader.link(SEGMENT$SDL_CloseJoystick, Descriptors.DESCRIPTOR$SDL_CloseJoystick);
        SEGMENT$SDL_GetJoystickConnectionState = loader.apply("SDL_GetJoystickConnectionState");
        HANDLE$SDL_GetJoystickConnectionState = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickConnectionState, Descriptors.DESCRIPTOR$SDL_GetJoystickConnectionState);
        SEGMENT$SDL_GetJoystickPowerInfo = loader.apply("SDL_GetJoystickPowerInfo");
        HANDLE$SDL_GetJoystickPowerInfo = RawFunctionLoader.link(SEGMENT$SDL_GetJoystickPowerInfo, Descriptors.DESCRIPTOR$SDL_GetJoystickPowerInfo);
        SEGMENT$SDL_HasKeyboard = loader.apply("SDL_HasKeyboard");
        HANDLE$SDL_HasKeyboard = RawFunctionLoader.link(SEGMENT$SDL_HasKeyboard, Descriptors.DESCRIPTOR$SDL_HasKeyboard);
        SEGMENT$SDL_GetKeyboards = loader.apply("SDL_GetKeyboards");
        HANDLE$SDL_GetKeyboards = RawFunctionLoader.link(SEGMENT$SDL_GetKeyboards, Descriptors.DESCRIPTOR$SDL_GetKeyboards);
        SEGMENT$SDL_GetKeyboardNameForID = loader.apply("SDL_GetKeyboardNameForID");
        HANDLE$SDL_GetKeyboardNameForID = RawFunctionLoader.link(SEGMENT$SDL_GetKeyboardNameForID, Descriptors.DESCRIPTOR$SDL_GetKeyboardNameForID);
        SEGMENT$SDL_GetKeyboardFocus = loader.apply("SDL_GetKeyboardFocus");
        HANDLE$SDL_GetKeyboardFocus = RawFunctionLoader.link(SEGMENT$SDL_GetKeyboardFocus, Descriptors.DESCRIPTOR$SDL_GetKeyboardFocus);
        SEGMENT$SDL_GetKeyboardState = loader.apply("SDL_GetKeyboardState");
        HANDLE$SDL_GetKeyboardState = RawFunctionLoader.link(SEGMENT$SDL_GetKeyboardState, Descriptors.DESCRIPTOR$SDL_GetKeyboardState);
        SEGMENT$SDL_ResetKeyboard = loader.apply("SDL_ResetKeyboard");
        HANDLE$SDL_ResetKeyboard = RawFunctionLoader.link(SEGMENT$SDL_ResetKeyboard, Descriptors.DESCRIPTOR$SDL_ResetKeyboard);
        SEGMENT$SDL_GetModState = loader.apply("SDL_GetModState");
        HANDLE$SDL_GetModState = RawFunctionLoader.link(SEGMENT$SDL_GetModState, Descriptors.DESCRIPTOR$SDL_GetModState);
        SEGMENT$SDL_SetModState = loader.apply("SDL_SetModState");
        HANDLE$SDL_SetModState = RawFunctionLoader.link(SEGMENT$SDL_SetModState, Descriptors.DESCRIPTOR$SDL_SetModState);
        SEGMENT$SDL_GetKeyFromScancode = loader.apply("SDL_GetKeyFromScancode");
        HANDLE$SDL_GetKeyFromScancode = RawFunctionLoader.link(SEGMENT$SDL_GetKeyFromScancode, Descriptors.DESCRIPTOR$SDL_GetKeyFromScancode);
        SEGMENT$SDL_GetScancodeFromKey = loader.apply("SDL_GetScancodeFromKey");
        HANDLE$SDL_GetScancodeFromKey = RawFunctionLoader.link(SEGMENT$SDL_GetScancodeFromKey, Descriptors.DESCRIPTOR$SDL_GetScancodeFromKey);
        SEGMENT$SDL_SetScancodeName = loader.apply("SDL_SetScancodeName");
        HANDLE$SDL_SetScancodeName = RawFunctionLoader.link(SEGMENT$SDL_SetScancodeName, Descriptors.DESCRIPTOR$SDL_SetScancodeName);
        SEGMENT$SDL_GetScancodeName = loader.apply("SDL_GetScancodeName");
        HANDLE$SDL_GetScancodeName = RawFunctionLoader.link(SEGMENT$SDL_GetScancodeName, Descriptors.DESCRIPTOR$SDL_GetScancodeName);
        SEGMENT$SDL_GetScancodeFromName = loader.apply("SDL_GetScancodeFromName");
        HANDLE$SDL_GetScancodeFromName = RawFunctionLoader.link(SEGMENT$SDL_GetScancodeFromName, Descriptors.DESCRIPTOR$SDL_GetScancodeFromName);
        SEGMENT$SDL_GetKeyName = loader.apply("SDL_GetKeyName");
        HANDLE$SDL_GetKeyName = RawFunctionLoader.link(SEGMENT$SDL_GetKeyName, Descriptors.DESCRIPTOR$SDL_GetKeyName);
        SEGMENT$SDL_GetKeyFromName = loader.apply("SDL_GetKeyFromName");
        HANDLE$SDL_GetKeyFromName = RawFunctionLoader.link(SEGMENT$SDL_GetKeyFromName, Descriptors.DESCRIPTOR$SDL_GetKeyFromName);
        SEGMENT$SDL_StartTextInput = loader.apply("SDL_StartTextInput");
        HANDLE$SDL_StartTextInput = RawFunctionLoader.link(SEGMENT$SDL_StartTextInput, Descriptors.DESCRIPTOR$SDL_StartTextInput);
        SEGMENT$SDL_StartTextInputWithProperties = loader.apply("SDL_StartTextInputWithProperties");
        HANDLE$SDL_StartTextInputWithProperties = RawFunctionLoader.link(SEGMENT$SDL_StartTextInputWithProperties, Descriptors.DESCRIPTOR$SDL_StartTextInputWithProperties);
        SEGMENT$SDL_TextInputActive = loader.apply("SDL_TextInputActive");
        HANDLE$SDL_TextInputActive = RawFunctionLoader.link(SEGMENT$SDL_TextInputActive, Descriptors.DESCRIPTOR$SDL_TextInputActive);
        SEGMENT$SDL_StopTextInput = loader.apply("SDL_StopTextInput");
        HANDLE$SDL_StopTextInput = RawFunctionLoader.link(SEGMENT$SDL_StopTextInput, Descriptors.DESCRIPTOR$SDL_StopTextInput);
        SEGMENT$SDL_ClearComposition = loader.apply("SDL_ClearComposition");
        HANDLE$SDL_ClearComposition = RawFunctionLoader.link(SEGMENT$SDL_ClearComposition, Descriptors.DESCRIPTOR$SDL_ClearComposition);
        SEGMENT$SDL_SetTextInputArea = loader.apply("SDL_SetTextInputArea");
        HANDLE$SDL_SetTextInputArea = RawFunctionLoader.link(SEGMENT$SDL_SetTextInputArea, Descriptors.DESCRIPTOR$SDL_SetTextInputArea);
        SEGMENT$SDL_GetTextInputArea = loader.apply("SDL_GetTextInputArea");
        HANDLE$SDL_GetTextInputArea = RawFunctionLoader.link(SEGMENT$SDL_GetTextInputArea, Descriptors.DESCRIPTOR$SDL_GetTextInputArea);
        SEGMENT$SDL_HasScreenKeyboardSupport = loader.apply("SDL_HasScreenKeyboardSupport");
        HANDLE$SDL_HasScreenKeyboardSupport = RawFunctionLoader.link(SEGMENT$SDL_HasScreenKeyboardSupport, Descriptors.DESCRIPTOR$SDL_HasScreenKeyboardSupport);
        SEGMENT$SDL_ScreenKeyboardShown = loader.apply("SDL_ScreenKeyboardShown");
        HANDLE$SDL_ScreenKeyboardShown = RawFunctionLoader.link(SEGMENT$SDL_ScreenKeyboardShown, Descriptors.DESCRIPTOR$SDL_ScreenKeyboardShown);
        SEGMENT$SDL_LoadObject = loader.apply("SDL_LoadObject");
        HANDLE$SDL_LoadObject = RawFunctionLoader.link(SEGMENT$SDL_LoadObject, Descriptors.DESCRIPTOR$SDL_LoadObject);
        SEGMENT$SDL_LoadFunction = loader.apply("SDL_LoadFunction");
        HANDLE$SDL_LoadFunction = RawFunctionLoader.link(SEGMENT$SDL_LoadFunction, Descriptors.DESCRIPTOR$SDL_LoadFunction);
        SEGMENT$SDL_UnloadObject = loader.apply("SDL_UnloadObject");
        HANDLE$SDL_UnloadObject = RawFunctionLoader.link(SEGMENT$SDL_UnloadObject, Descriptors.DESCRIPTOR$SDL_UnloadObject);
        SEGMENT$SDL_GetPreferredLocales = loader.apply("SDL_GetPreferredLocales");
        HANDLE$SDL_GetPreferredLocales = RawFunctionLoader.link(SEGMENT$SDL_GetPreferredLocales, Descriptors.DESCRIPTOR$SDL_GetPreferredLocales);
        SEGMENT$SDL_SetLogPriorities = loader.apply("SDL_SetLogPriorities");
        HANDLE$SDL_SetLogPriorities = RawFunctionLoader.link(SEGMENT$SDL_SetLogPriorities, Descriptors.DESCRIPTOR$SDL_SetLogPriorities);
        SEGMENT$SDL_SetLogPriority = loader.apply("SDL_SetLogPriority");
        HANDLE$SDL_SetLogPriority = RawFunctionLoader.link(SEGMENT$SDL_SetLogPriority, Descriptors.DESCRIPTOR$SDL_SetLogPriority);
        SEGMENT$SDL_GetLogPriority = loader.apply("SDL_GetLogPriority");
        HANDLE$SDL_GetLogPriority = RawFunctionLoader.link(SEGMENT$SDL_GetLogPriority, Descriptors.DESCRIPTOR$SDL_GetLogPriority);
        SEGMENT$SDL_ResetLogPriorities = loader.apply("SDL_ResetLogPriorities");
        HANDLE$SDL_ResetLogPriorities = RawFunctionLoader.link(SEGMENT$SDL_ResetLogPriorities, Descriptors.DESCRIPTOR$SDL_ResetLogPriorities);
        SEGMENT$SDL_SetLogPriorityPrefix = loader.apply("SDL_SetLogPriorityPrefix");
        HANDLE$SDL_SetLogPriorityPrefix = RawFunctionLoader.link(SEGMENT$SDL_SetLogPriorityPrefix, Descriptors.DESCRIPTOR$SDL_SetLogPriorityPrefix);
        SEGMENT$SDL_GetDefaultLogOutputFunction = loader.apply("SDL_GetDefaultLogOutputFunction");
        HANDLE$SDL_GetDefaultLogOutputFunction = RawFunctionLoader.link(SEGMENT$SDL_GetDefaultLogOutputFunction, Descriptors.DESCRIPTOR$SDL_GetDefaultLogOutputFunction);
        SEGMENT$SDL_GetLogOutputFunction = loader.apply("SDL_GetLogOutputFunction");
        HANDLE$SDL_GetLogOutputFunction = RawFunctionLoader.link(SEGMENT$SDL_GetLogOutputFunction, Descriptors.DESCRIPTOR$SDL_GetLogOutputFunction);
        SEGMENT$SDL_SetLogOutputFunction = loader.apply("SDL_SetLogOutputFunction");
        HANDLE$SDL_SetLogOutputFunction = RawFunctionLoader.link(SEGMENT$SDL_SetLogOutputFunction, Descriptors.DESCRIPTOR$SDL_SetLogOutputFunction);
        SEGMENT$SDL_ShowMessageBox = loader.apply("SDL_ShowMessageBox");
        HANDLE$SDL_ShowMessageBox = RawFunctionLoader.link(SEGMENT$SDL_ShowMessageBox, Descriptors.DESCRIPTOR$SDL_ShowMessageBox);
        SEGMENT$SDL_ShowSimpleMessageBox = loader.apply("SDL_ShowSimpleMessageBox");
        HANDLE$SDL_ShowSimpleMessageBox = RawFunctionLoader.link(SEGMENT$SDL_ShowSimpleMessageBox, Descriptors.DESCRIPTOR$SDL_ShowSimpleMessageBox);
        SEGMENT$SDL_Metal_CreateView = loader.apply("SDL_Metal_CreateView");
        HANDLE$SDL_Metal_CreateView = RawFunctionLoader.link(SEGMENT$SDL_Metal_CreateView, Descriptors.DESCRIPTOR$SDL_Metal_CreateView);
        SEGMENT$SDL_Metal_DestroyView = loader.apply("SDL_Metal_DestroyView");
        HANDLE$SDL_Metal_DestroyView = RawFunctionLoader.link(SEGMENT$SDL_Metal_DestroyView, Descriptors.DESCRIPTOR$SDL_Metal_DestroyView);
        SEGMENT$SDL_Metal_GetLayer = loader.apply("SDL_Metal_GetLayer");
        HANDLE$SDL_Metal_GetLayer = RawFunctionLoader.link(SEGMENT$SDL_Metal_GetLayer, Descriptors.DESCRIPTOR$SDL_Metal_GetLayer);
        SEGMENT$SDL_OpenURL = loader.apply("SDL_OpenURL");
        HANDLE$SDL_OpenURL = RawFunctionLoader.link(SEGMENT$SDL_OpenURL, Descriptors.DESCRIPTOR$SDL_OpenURL);
        SEGMENT$SDL_HasMouse = loader.apply("SDL_HasMouse");
        HANDLE$SDL_HasMouse = RawFunctionLoader.link(SEGMENT$SDL_HasMouse, Descriptors.DESCRIPTOR$SDL_HasMouse);
        SEGMENT$SDL_GetMice = loader.apply("SDL_GetMice");
        HANDLE$SDL_GetMice = RawFunctionLoader.link(SEGMENT$SDL_GetMice, Descriptors.DESCRIPTOR$SDL_GetMice);
        SEGMENT$SDL_GetMouseNameForID = loader.apply("SDL_GetMouseNameForID");
        HANDLE$SDL_GetMouseNameForID = RawFunctionLoader.link(SEGMENT$SDL_GetMouseNameForID, Descriptors.DESCRIPTOR$SDL_GetMouseNameForID);
        SEGMENT$SDL_GetMouseFocus = loader.apply("SDL_GetMouseFocus");
        HANDLE$SDL_GetMouseFocus = RawFunctionLoader.link(SEGMENT$SDL_GetMouseFocus, Descriptors.DESCRIPTOR$SDL_GetMouseFocus);
        SEGMENT$SDL_GetMouseState = loader.apply("SDL_GetMouseState");
        HANDLE$SDL_GetMouseState = RawFunctionLoader.link(SEGMENT$SDL_GetMouseState, Descriptors.DESCRIPTOR$SDL_GetMouseState);
        SEGMENT$SDL_GetGlobalMouseState = loader.apply("SDL_GetGlobalMouseState");
        HANDLE$SDL_GetGlobalMouseState = RawFunctionLoader.link(SEGMENT$SDL_GetGlobalMouseState, Descriptors.DESCRIPTOR$SDL_GetGlobalMouseState);
        SEGMENT$SDL_GetRelativeMouseState = loader.apply("SDL_GetRelativeMouseState");
        HANDLE$SDL_GetRelativeMouseState = RawFunctionLoader.link(SEGMENT$SDL_GetRelativeMouseState, Descriptors.DESCRIPTOR$SDL_GetRelativeMouseState);
        SEGMENT$SDL_WarpMouseInWindow = loader.apply("SDL_WarpMouseInWindow");
        HANDLE$SDL_WarpMouseInWindow = RawFunctionLoader.link(SEGMENT$SDL_WarpMouseInWindow, Descriptors.DESCRIPTOR$SDL_WarpMouseInWindow);
        SEGMENT$SDL_WarpMouseGlobal = loader.apply("SDL_WarpMouseGlobal");
        HANDLE$SDL_WarpMouseGlobal = RawFunctionLoader.link(SEGMENT$SDL_WarpMouseGlobal, Descriptors.DESCRIPTOR$SDL_WarpMouseGlobal);
        SEGMENT$SDL_SetWindowRelativeMouseMode = loader.apply("SDL_SetWindowRelativeMouseMode");
        HANDLE$SDL_SetWindowRelativeMouseMode = RawFunctionLoader.link(SEGMENT$SDL_SetWindowRelativeMouseMode, Descriptors.DESCRIPTOR$SDL_SetWindowRelativeMouseMode);
        SEGMENT$SDL_GetWindowRelativeMouseMode = loader.apply("SDL_GetWindowRelativeMouseMode");
        HANDLE$SDL_GetWindowRelativeMouseMode = RawFunctionLoader.link(SEGMENT$SDL_GetWindowRelativeMouseMode, Descriptors.DESCRIPTOR$SDL_GetWindowRelativeMouseMode);
        SEGMENT$SDL_CaptureMouse = loader.apply("SDL_CaptureMouse");
        HANDLE$SDL_CaptureMouse = RawFunctionLoader.link(SEGMENT$SDL_CaptureMouse, Descriptors.DESCRIPTOR$SDL_CaptureMouse);
        SEGMENT$SDL_CreateCursor = loader.apply("SDL_CreateCursor");
        HANDLE$SDL_CreateCursor = RawFunctionLoader.link(SEGMENT$SDL_CreateCursor, Descriptors.DESCRIPTOR$SDL_CreateCursor);
        SEGMENT$SDL_CreateColorCursor = loader.apply("SDL_CreateColorCursor");
        HANDLE$SDL_CreateColorCursor = RawFunctionLoader.link(SEGMENT$SDL_CreateColorCursor, Descriptors.DESCRIPTOR$SDL_CreateColorCursor);
        SEGMENT$SDL_CreateSystemCursor = loader.apply("SDL_CreateSystemCursor");
        HANDLE$SDL_CreateSystemCursor = RawFunctionLoader.link(SEGMENT$SDL_CreateSystemCursor, Descriptors.DESCRIPTOR$SDL_CreateSystemCursor);
        SEGMENT$SDL_SetCursor = loader.apply("SDL_SetCursor");
        HANDLE$SDL_SetCursor = RawFunctionLoader.link(SEGMENT$SDL_SetCursor, Descriptors.DESCRIPTOR$SDL_SetCursor);
        SEGMENT$SDL_GetCursor = loader.apply("SDL_GetCursor");
        HANDLE$SDL_GetCursor = RawFunctionLoader.link(SEGMENT$SDL_GetCursor, Descriptors.DESCRIPTOR$SDL_GetCursor);
        SEGMENT$SDL_GetDefaultCursor = loader.apply("SDL_GetDefaultCursor");
        HANDLE$SDL_GetDefaultCursor = RawFunctionLoader.link(SEGMENT$SDL_GetDefaultCursor, Descriptors.DESCRIPTOR$SDL_GetDefaultCursor);
        SEGMENT$SDL_DestroyCursor = loader.apply("SDL_DestroyCursor");
        HANDLE$SDL_DestroyCursor = RawFunctionLoader.link(SEGMENT$SDL_DestroyCursor, Descriptors.DESCRIPTOR$SDL_DestroyCursor);
        SEGMENT$SDL_ShowCursor = loader.apply("SDL_ShowCursor");
        HANDLE$SDL_ShowCursor = RawFunctionLoader.link(SEGMENT$SDL_ShowCursor, Descriptors.DESCRIPTOR$SDL_ShowCursor);
        SEGMENT$SDL_HideCursor = loader.apply("SDL_HideCursor");
        HANDLE$SDL_HideCursor = RawFunctionLoader.link(SEGMENT$SDL_HideCursor, Descriptors.DESCRIPTOR$SDL_HideCursor);
        SEGMENT$SDL_CursorVisible = loader.apply("SDL_CursorVisible");
        HANDLE$SDL_CursorVisible = RawFunctionLoader.link(SEGMENT$SDL_CursorVisible, Descriptors.DESCRIPTOR$SDL_CursorVisible);
        SEGMENT$SDL_CreateMutex = loader.apply("SDL_CreateMutex");
        HANDLE$SDL_CreateMutex = RawFunctionLoader.link(SEGMENT$SDL_CreateMutex, Descriptors.DESCRIPTOR$SDL_CreateMutex);
        SEGMENT$SDL_LockMutex = loader.apply("SDL_LockMutex");
        HANDLE$SDL_LockMutex = RawFunctionLoader.link(SEGMENT$SDL_LockMutex, Descriptors.DESCRIPTOR$SDL_LockMutex);
        SEGMENT$SDL_TryLockMutex = loader.apply("SDL_TryLockMutex");
        HANDLE$SDL_TryLockMutex = RawFunctionLoader.link(SEGMENT$SDL_TryLockMutex, Descriptors.DESCRIPTOR$SDL_TryLockMutex);
        SEGMENT$SDL_UnlockMutex = loader.apply("SDL_UnlockMutex");
        HANDLE$SDL_UnlockMutex = RawFunctionLoader.link(SEGMENT$SDL_UnlockMutex, Descriptors.DESCRIPTOR$SDL_UnlockMutex);
        SEGMENT$SDL_DestroyMutex = loader.apply("SDL_DestroyMutex");
        HANDLE$SDL_DestroyMutex = RawFunctionLoader.link(SEGMENT$SDL_DestroyMutex, Descriptors.DESCRIPTOR$SDL_DestroyMutex);
        SEGMENT$SDL_CreateRWLock = loader.apply("SDL_CreateRWLock");
        HANDLE$SDL_CreateRWLock = RawFunctionLoader.link(SEGMENT$SDL_CreateRWLock, Descriptors.DESCRIPTOR$SDL_CreateRWLock);
        SEGMENT$SDL_LockRWLockForReading = loader.apply("SDL_LockRWLockForReading");
        HANDLE$SDL_LockRWLockForReading = RawFunctionLoader.link(SEGMENT$SDL_LockRWLockForReading, Descriptors.DESCRIPTOR$SDL_LockRWLockForReading);
        SEGMENT$SDL_LockRWLockForWriting = loader.apply("SDL_LockRWLockForWriting");
        HANDLE$SDL_LockRWLockForWriting = RawFunctionLoader.link(SEGMENT$SDL_LockRWLockForWriting, Descriptors.DESCRIPTOR$SDL_LockRWLockForWriting);
        SEGMENT$SDL_TryLockRWLockForReading = loader.apply("SDL_TryLockRWLockForReading");
        HANDLE$SDL_TryLockRWLockForReading = RawFunctionLoader.link(SEGMENT$SDL_TryLockRWLockForReading, Descriptors.DESCRIPTOR$SDL_TryLockRWLockForReading);
        SEGMENT$SDL_TryLockRWLockForWriting = loader.apply("SDL_TryLockRWLockForWriting");
        HANDLE$SDL_TryLockRWLockForWriting = RawFunctionLoader.link(SEGMENT$SDL_TryLockRWLockForWriting, Descriptors.DESCRIPTOR$SDL_TryLockRWLockForWriting);
        SEGMENT$SDL_UnlockRWLock = loader.apply("SDL_UnlockRWLock");
        HANDLE$SDL_UnlockRWLock = RawFunctionLoader.link(SEGMENT$SDL_UnlockRWLock, Descriptors.DESCRIPTOR$SDL_UnlockRWLock);
        SEGMENT$SDL_DestroyRWLock = loader.apply("SDL_DestroyRWLock");
        HANDLE$SDL_DestroyRWLock = RawFunctionLoader.link(SEGMENT$SDL_DestroyRWLock, Descriptors.DESCRIPTOR$SDL_DestroyRWLock);
        SEGMENT$SDL_CreateSemaphore = loader.apply("SDL_CreateSemaphore");
        HANDLE$SDL_CreateSemaphore = RawFunctionLoader.link(SEGMENT$SDL_CreateSemaphore, Descriptors.DESCRIPTOR$SDL_CreateSemaphore);
        SEGMENT$SDL_DestroySemaphore = loader.apply("SDL_DestroySemaphore");
        HANDLE$SDL_DestroySemaphore = RawFunctionLoader.link(SEGMENT$SDL_DestroySemaphore, Descriptors.DESCRIPTOR$SDL_DestroySemaphore);
        SEGMENT$SDL_WaitSemaphore = loader.apply("SDL_WaitSemaphore");
        HANDLE$SDL_WaitSemaphore = RawFunctionLoader.link(SEGMENT$SDL_WaitSemaphore, Descriptors.DESCRIPTOR$SDL_WaitSemaphore);
        SEGMENT$SDL_TryWaitSemaphore = loader.apply("SDL_TryWaitSemaphore");
        HANDLE$SDL_TryWaitSemaphore = RawFunctionLoader.link(SEGMENT$SDL_TryWaitSemaphore, Descriptors.DESCRIPTOR$SDL_TryWaitSemaphore);
        SEGMENT$SDL_WaitSemaphoreTimeout = loader.apply("SDL_WaitSemaphoreTimeout");
        HANDLE$SDL_WaitSemaphoreTimeout = RawFunctionLoader.link(SEGMENT$SDL_WaitSemaphoreTimeout, Descriptors.DESCRIPTOR$SDL_WaitSemaphoreTimeout);
        SEGMENT$SDL_SignalSemaphore = loader.apply("SDL_SignalSemaphore");
        HANDLE$SDL_SignalSemaphore = RawFunctionLoader.link(SEGMENT$SDL_SignalSemaphore, Descriptors.DESCRIPTOR$SDL_SignalSemaphore);
        SEGMENT$SDL_GetSemaphoreValue = loader.apply("SDL_GetSemaphoreValue");
        HANDLE$SDL_GetSemaphoreValue = RawFunctionLoader.link(SEGMENT$SDL_GetSemaphoreValue, Descriptors.DESCRIPTOR$SDL_GetSemaphoreValue);
        SEGMENT$SDL_CreateCondition = loader.apply("SDL_CreateCondition");
        HANDLE$SDL_CreateCondition = RawFunctionLoader.link(SEGMENT$SDL_CreateCondition, Descriptors.DESCRIPTOR$SDL_CreateCondition);
        SEGMENT$SDL_DestroyCondition = loader.apply("SDL_DestroyCondition");
        HANDLE$SDL_DestroyCondition = RawFunctionLoader.link(SEGMENT$SDL_DestroyCondition, Descriptors.DESCRIPTOR$SDL_DestroyCondition);
        SEGMENT$SDL_SignalCondition = loader.apply("SDL_SignalCondition");
        HANDLE$SDL_SignalCondition = RawFunctionLoader.link(SEGMENT$SDL_SignalCondition, Descriptors.DESCRIPTOR$SDL_SignalCondition);
        SEGMENT$SDL_BroadcastCondition = loader.apply("SDL_BroadcastCondition");
        HANDLE$SDL_BroadcastCondition = RawFunctionLoader.link(SEGMENT$SDL_BroadcastCondition, Descriptors.DESCRIPTOR$SDL_BroadcastCondition);
        SEGMENT$SDL_WaitCondition = loader.apply("SDL_WaitCondition");
        HANDLE$SDL_WaitCondition = RawFunctionLoader.link(SEGMENT$SDL_WaitCondition, Descriptors.DESCRIPTOR$SDL_WaitCondition);
        SEGMENT$SDL_WaitConditionTimeout = loader.apply("SDL_WaitConditionTimeout");
        HANDLE$SDL_WaitConditionTimeout = RawFunctionLoader.link(SEGMENT$SDL_WaitConditionTimeout, Descriptors.DESCRIPTOR$SDL_WaitConditionTimeout);
        SEGMENT$SDL_ShouldInit = loader.apply("SDL_ShouldInit");
        HANDLE$SDL_ShouldInit = RawFunctionLoader.link(SEGMENT$SDL_ShouldInit, Descriptors.DESCRIPTOR$SDL_ShouldInit);
        SEGMENT$SDL_ShouldQuit = loader.apply("SDL_ShouldQuit");
        HANDLE$SDL_ShouldQuit = RawFunctionLoader.link(SEGMENT$SDL_ShouldQuit, Descriptors.DESCRIPTOR$SDL_ShouldQuit);
        SEGMENT$SDL_SetInitialized = loader.apply("SDL_SetInitialized");
        HANDLE$SDL_SetInitialized = RawFunctionLoader.link(SEGMENT$SDL_SetInitialized, Descriptors.DESCRIPTOR$SDL_SetInitialized);
        SEGMENT$SDL_GetPixelFormatName = loader.apply("SDL_GetPixelFormatName");
        HANDLE$SDL_GetPixelFormatName = RawFunctionLoader.link(SEGMENT$SDL_GetPixelFormatName, Descriptors.DESCRIPTOR$SDL_GetPixelFormatName);
        SEGMENT$SDL_GetMasksForPixelFormat = loader.apply("SDL_GetMasksForPixelFormat");
        HANDLE$SDL_GetMasksForPixelFormat = RawFunctionLoader.link(SEGMENT$SDL_GetMasksForPixelFormat, Descriptors.DESCRIPTOR$SDL_GetMasksForPixelFormat);
        SEGMENT$SDL_GetPixelFormatForMasks = loader.apply("SDL_GetPixelFormatForMasks");
        HANDLE$SDL_GetPixelFormatForMasks = RawFunctionLoader.link(SEGMENT$SDL_GetPixelFormatForMasks, Descriptors.DESCRIPTOR$SDL_GetPixelFormatForMasks);
        SEGMENT$SDL_GetPixelFormatDetails = loader.apply("SDL_GetPixelFormatDetails");
        HANDLE$SDL_GetPixelFormatDetails = RawFunctionLoader.link(SEGMENT$SDL_GetPixelFormatDetails, Descriptors.DESCRIPTOR$SDL_GetPixelFormatDetails);
        SEGMENT$SDL_CreatePalette = loader.apply("SDL_CreatePalette");
        HANDLE$SDL_CreatePalette = RawFunctionLoader.link(SEGMENT$SDL_CreatePalette, Descriptors.DESCRIPTOR$SDL_CreatePalette);
        SEGMENT$SDL_SetPaletteColors = loader.apply("SDL_SetPaletteColors");
        HANDLE$SDL_SetPaletteColors = RawFunctionLoader.link(SEGMENT$SDL_SetPaletteColors, Descriptors.DESCRIPTOR$SDL_SetPaletteColors);
        SEGMENT$SDL_DestroyPalette = loader.apply("SDL_DestroyPalette");
        HANDLE$SDL_DestroyPalette = RawFunctionLoader.link(SEGMENT$SDL_DestroyPalette, Descriptors.DESCRIPTOR$SDL_DestroyPalette);
        SEGMENT$SDL_MapRGB = loader.apply("SDL_MapRGB");
        HANDLE$SDL_MapRGB = RawFunctionLoader.link(SEGMENT$SDL_MapRGB, Descriptors.DESCRIPTOR$SDL_MapRGB);
        SEGMENT$SDL_MapRGBA = loader.apply("SDL_MapRGBA");
        HANDLE$SDL_MapRGBA = RawFunctionLoader.link(SEGMENT$SDL_MapRGBA, Descriptors.DESCRIPTOR$SDL_MapRGBA);
        SEGMENT$SDL_GetRGB = loader.apply("SDL_GetRGB");
        HANDLE$SDL_GetRGB = RawFunctionLoader.link(SEGMENT$SDL_GetRGB, Descriptors.DESCRIPTOR$SDL_GetRGB);
        SEGMENT$SDL_GetRGBA = loader.apply("SDL_GetRGBA");
        HANDLE$SDL_GetRGBA = RawFunctionLoader.link(SEGMENT$SDL_GetRGBA, Descriptors.DESCRIPTOR$SDL_GetRGBA);
        SEGMENT$SDL_GetPlatform = loader.apply("SDL_GetPlatform");
        HANDLE$SDL_GetPlatform = RawFunctionLoader.link(SEGMENT$SDL_GetPlatform, Descriptors.DESCRIPTOR$SDL_GetPlatform);
        SEGMENT$SDL_GetPowerInfo = loader.apply("SDL_GetPowerInfo");
        HANDLE$SDL_GetPowerInfo = RawFunctionLoader.link(SEGMENT$SDL_GetPowerInfo, Descriptors.DESCRIPTOR$SDL_GetPowerInfo);
        SEGMENT$SDL_CreateProcess = loader.apply("SDL_CreateProcess");
        HANDLE$SDL_CreateProcess = RawFunctionLoader.link(SEGMENT$SDL_CreateProcess, Descriptors.DESCRIPTOR$SDL_CreateProcess);
        SEGMENT$SDL_CreateProcessWithProperties = loader.apply("SDL_CreateProcessWithProperties");
        HANDLE$SDL_CreateProcessWithProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateProcessWithProperties, Descriptors.DESCRIPTOR$SDL_CreateProcessWithProperties);
        SEGMENT$SDL_GetProcessProperties = loader.apply("SDL_GetProcessProperties");
        HANDLE$SDL_GetProcessProperties = RawFunctionLoader.link(SEGMENT$SDL_GetProcessProperties, Descriptors.DESCRIPTOR$SDL_GetProcessProperties);
        SEGMENT$SDL_ReadProcess = loader.apply("SDL_ReadProcess");
        HANDLE$SDL_ReadProcess = RawFunctionLoader.link(SEGMENT$SDL_ReadProcess, Descriptors.DESCRIPTOR$SDL_ReadProcess);
        SEGMENT$SDL_GetProcessInput = loader.apply("SDL_GetProcessInput");
        HANDLE$SDL_GetProcessInput = RawFunctionLoader.link(SEGMENT$SDL_GetProcessInput, Descriptors.DESCRIPTOR$SDL_GetProcessInput);
        SEGMENT$SDL_GetProcessOutput = loader.apply("SDL_GetProcessOutput");
        HANDLE$SDL_GetProcessOutput = RawFunctionLoader.link(SEGMENT$SDL_GetProcessOutput, Descriptors.DESCRIPTOR$SDL_GetProcessOutput);
        SEGMENT$SDL_KillProcess = loader.apply("SDL_KillProcess");
        HANDLE$SDL_KillProcess = RawFunctionLoader.link(SEGMENT$SDL_KillProcess, Descriptors.DESCRIPTOR$SDL_KillProcess);
        SEGMENT$SDL_WaitProcess = loader.apply("SDL_WaitProcess");
        HANDLE$SDL_WaitProcess = RawFunctionLoader.link(SEGMENT$SDL_WaitProcess, Descriptors.DESCRIPTOR$SDL_WaitProcess);
        SEGMENT$SDL_DestroyProcess = loader.apply("SDL_DestroyProcess");
        HANDLE$SDL_DestroyProcess = RawFunctionLoader.link(SEGMENT$SDL_DestroyProcess, Descriptors.DESCRIPTOR$SDL_DestroyProcess);
        SEGMENT$SDL_GetGlobalProperties = loader.apply("SDL_GetGlobalProperties");
        HANDLE$SDL_GetGlobalProperties = RawFunctionLoader.link(SEGMENT$SDL_GetGlobalProperties, Descriptors.DESCRIPTOR$SDL_GetGlobalProperties);
        SEGMENT$SDL_CreateProperties = loader.apply("SDL_CreateProperties");
        HANDLE$SDL_CreateProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateProperties, Descriptors.DESCRIPTOR$SDL_CreateProperties);
        SEGMENT$SDL_CopyProperties = loader.apply("SDL_CopyProperties");
        HANDLE$SDL_CopyProperties = RawFunctionLoader.link(SEGMENT$SDL_CopyProperties, Descriptors.DESCRIPTOR$SDL_CopyProperties);
        SEGMENT$SDL_LockProperties = loader.apply("SDL_LockProperties");
        HANDLE$SDL_LockProperties = RawFunctionLoader.link(SEGMENT$SDL_LockProperties, Descriptors.DESCRIPTOR$SDL_LockProperties);
        SEGMENT$SDL_UnlockProperties = loader.apply("SDL_UnlockProperties");
        HANDLE$SDL_UnlockProperties = RawFunctionLoader.link(SEGMENT$SDL_UnlockProperties, Descriptors.DESCRIPTOR$SDL_UnlockProperties);
        SEGMENT$SDL_SetPointerPropertyWithCleanup = loader.apply("SDL_SetPointerPropertyWithCleanup");
        HANDLE$SDL_SetPointerPropertyWithCleanup = RawFunctionLoader.link(SEGMENT$SDL_SetPointerPropertyWithCleanup, Descriptors.DESCRIPTOR$SDL_SetPointerPropertyWithCleanup);
        SEGMENT$SDL_SetPointerProperty = loader.apply("SDL_SetPointerProperty");
        HANDLE$SDL_SetPointerProperty = RawFunctionLoader.link(SEGMENT$SDL_SetPointerProperty, Descriptors.DESCRIPTOR$SDL_SetPointerProperty);
        SEGMENT$SDL_SetStringProperty = loader.apply("SDL_SetStringProperty");
        HANDLE$SDL_SetStringProperty = RawFunctionLoader.link(SEGMENT$SDL_SetStringProperty, Descriptors.DESCRIPTOR$SDL_SetStringProperty);
        SEGMENT$SDL_SetNumberProperty = loader.apply("SDL_SetNumberProperty");
        HANDLE$SDL_SetNumberProperty = RawFunctionLoader.link(SEGMENT$SDL_SetNumberProperty, Descriptors.DESCRIPTOR$SDL_SetNumberProperty);
        SEGMENT$SDL_SetFloatProperty = loader.apply("SDL_SetFloatProperty");
        HANDLE$SDL_SetFloatProperty = RawFunctionLoader.link(SEGMENT$SDL_SetFloatProperty, Descriptors.DESCRIPTOR$SDL_SetFloatProperty);
        SEGMENT$SDL_SetBooleanProperty = loader.apply("SDL_SetBooleanProperty");
        HANDLE$SDL_SetBooleanProperty = RawFunctionLoader.link(SEGMENT$SDL_SetBooleanProperty, Descriptors.DESCRIPTOR$SDL_SetBooleanProperty);
        SEGMENT$SDL_HasProperty = loader.apply("SDL_HasProperty");
        HANDLE$SDL_HasProperty = RawFunctionLoader.link(SEGMENT$SDL_HasProperty, Descriptors.DESCRIPTOR$SDL_HasProperty);
        SEGMENT$SDL_GetPropertyType = loader.apply("SDL_GetPropertyType");
        HANDLE$SDL_GetPropertyType = RawFunctionLoader.link(SEGMENT$SDL_GetPropertyType, Descriptors.DESCRIPTOR$SDL_GetPropertyType);
        SEGMENT$SDL_GetPointerProperty = loader.apply("SDL_GetPointerProperty");
        HANDLE$SDL_GetPointerProperty = RawFunctionLoader.link(SEGMENT$SDL_GetPointerProperty, Descriptors.DESCRIPTOR$SDL_GetPointerProperty);
        SEGMENT$SDL_GetStringProperty = loader.apply("SDL_GetStringProperty");
        HANDLE$SDL_GetStringProperty = RawFunctionLoader.link(SEGMENT$SDL_GetStringProperty, Descriptors.DESCRIPTOR$SDL_GetStringProperty);
        SEGMENT$SDL_GetNumberProperty = loader.apply("SDL_GetNumberProperty");
        HANDLE$SDL_GetNumberProperty = RawFunctionLoader.link(SEGMENT$SDL_GetNumberProperty, Descriptors.DESCRIPTOR$SDL_GetNumberProperty);
        SEGMENT$SDL_GetFloatProperty = loader.apply("SDL_GetFloatProperty");
        HANDLE$SDL_GetFloatProperty = RawFunctionLoader.link(SEGMENT$SDL_GetFloatProperty, Descriptors.DESCRIPTOR$SDL_GetFloatProperty);
        SEGMENT$SDL_GetBooleanProperty = loader.apply("SDL_GetBooleanProperty");
        HANDLE$SDL_GetBooleanProperty = RawFunctionLoader.link(SEGMENT$SDL_GetBooleanProperty, Descriptors.DESCRIPTOR$SDL_GetBooleanProperty);
        SEGMENT$SDL_ClearProperty = loader.apply("SDL_ClearProperty");
        HANDLE$SDL_ClearProperty = RawFunctionLoader.link(SEGMENT$SDL_ClearProperty, Descriptors.DESCRIPTOR$SDL_ClearProperty);
        SEGMENT$SDL_EnumerateProperties = loader.apply("SDL_EnumerateProperties");
        HANDLE$SDL_EnumerateProperties = RawFunctionLoader.link(SEGMENT$SDL_EnumerateProperties, Descriptors.DESCRIPTOR$SDL_EnumerateProperties);
        SEGMENT$SDL_DestroyProperties = loader.apply("SDL_DestroyProperties");
        HANDLE$SDL_DestroyProperties = RawFunctionLoader.link(SEGMENT$SDL_DestroyProperties, Descriptors.DESCRIPTOR$SDL_DestroyProperties);
        SEGMENT$SDL_HasRectIntersection = loader.apply("SDL_HasRectIntersection");
        HANDLE$SDL_HasRectIntersection = RawFunctionLoader.link(SEGMENT$SDL_HasRectIntersection, Descriptors.DESCRIPTOR$SDL_HasRectIntersection);
        SEGMENT$SDL_GetRectIntersection = loader.apply("SDL_GetRectIntersection");
        HANDLE$SDL_GetRectIntersection = RawFunctionLoader.link(SEGMENT$SDL_GetRectIntersection, Descriptors.DESCRIPTOR$SDL_GetRectIntersection);
        SEGMENT$SDL_GetRectUnion = loader.apply("SDL_GetRectUnion");
        HANDLE$SDL_GetRectUnion = RawFunctionLoader.link(SEGMENT$SDL_GetRectUnion, Descriptors.DESCRIPTOR$SDL_GetRectUnion);
        SEGMENT$SDL_GetRectEnclosingPoints = loader.apply("SDL_GetRectEnclosingPoints");
        HANDLE$SDL_GetRectEnclosingPoints = RawFunctionLoader.link(SEGMENT$SDL_GetRectEnclosingPoints, Descriptors.DESCRIPTOR$SDL_GetRectEnclosingPoints);
        SEGMENT$SDL_GetRectAndLineIntersection = loader.apply("SDL_GetRectAndLineIntersection");
        HANDLE$SDL_GetRectAndLineIntersection = RawFunctionLoader.link(SEGMENT$SDL_GetRectAndLineIntersection, Descriptors.DESCRIPTOR$SDL_GetRectAndLineIntersection);
        SEGMENT$SDL_HasRectIntersectionFloat = loader.apply("SDL_HasRectIntersectionFloat");
        HANDLE$SDL_HasRectIntersectionFloat = RawFunctionLoader.link(SEGMENT$SDL_HasRectIntersectionFloat, Descriptors.DESCRIPTOR$SDL_HasRectIntersectionFloat);
        SEGMENT$SDL_GetRectIntersectionFloat = loader.apply("SDL_GetRectIntersectionFloat");
        HANDLE$SDL_GetRectIntersectionFloat = RawFunctionLoader.link(SEGMENT$SDL_GetRectIntersectionFloat, Descriptors.DESCRIPTOR$SDL_GetRectIntersectionFloat);
        SEGMENT$SDL_GetRectUnionFloat = loader.apply("SDL_GetRectUnionFloat");
        HANDLE$SDL_GetRectUnionFloat = RawFunctionLoader.link(SEGMENT$SDL_GetRectUnionFloat, Descriptors.DESCRIPTOR$SDL_GetRectUnionFloat);
        SEGMENT$SDL_GetRectEnclosingPointsFloat = loader.apply("SDL_GetRectEnclosingPointsFloat");
        HANDLE$SDL_GetRectEnclosingPointsFloat = RawFunctionLoader.link(SEGMENT$SDL_GetRectEnclosingPointsFloat, Descriptors.DESCRIPTOR$SDL_GetRectEnclosingPointsFloat);
        SEGMENT$SDL_GetRectAndLineIntersectionFloat = loader.apply("SDL_GetRectAndLineIntersectionFloat");
        HANDLE$SDL_GetRectAndLineIntersectionFloat = RawFunctionLoader.link(SEGMENT$SDL_GetRectAndLineIntersectionFloat, Descriptors.DESCRIPTOR$SDL_GetRectAndLineIntersectionFloat);
        SEGMENT$SDL_GetNumRenderDrivers = loader.apply("SDL_GetNumRenderDrivers");
        HANDLE$SDL_GetNumRenderDrivers = RawFunctionLoader.link(SEGMENT$SDL_GetNumRenderDrivers, Descriptors.DESCRIPTOR$SDL_GetNumRenderDrivers);
        SEGMENT$SDL_GetRenderDriver = loader.apply("SDL_GetRenderDriver");
        HANDLE$SDL_GetRenderDriver = RawFunctionLoader.link(SEGMENT$SDL_GetRenderDriver, Descriptors.DESCRIPTOR$SDL_GetRenderDriver);
        SEGMENT$SDL_CreateWindowAndRenderer = loader.apply("SDL_CreateWindowAndRenderer");
        HANDLE$SDL_CreateWindowAndRenderer = RawFunctionLoader.link(SEGMENT$SDL_CreateWindowAndRenderer, Descriptors.DESCRIPTOR$SDL_CreateWindowAndRenderer);
        SEGMENT$SDL_CreateRenderer = loader.apply("SDL_CreateRenderer");
        HANDLE$SDL_CreateRenderer = RawFunctionLoader.link(SEGMENT$SDL_CreateRenderer, Descriptors.DESCRIPTOR$SDL_CreateRenderer);
        SEGMENT$SDL_CreateRendererWithProperties = loader.apply("SDL_CreateRendererWithProperties");
        HANDLE$SDL_CreateRendererWithProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateRendererWithProperties, Descriptors.DESCRIPTOR$SDL_CreateRendererWithProperties);
        SEGMENT$SDL_CreateSoftwareRenderer = loader.apply("SDL_CreateSoftwareRenderer");
        HANDLE$SDL_CreateSoftwareRenderer = RawFunctionLoader.link(SEGMENT$SDL_CreateSoftwareRenderer, Descriptors.DESCRIPTOR$SDL_CreateSoftwareRenderer);
        SEGMENT$SDL_GetRenderer = loader.apply("SDL_GetRenderer");
        HANDLE$SDL_GetRenderer = RawFunctionLoader.link(SEGMENT$SDL_GetRenderer, Descriptors.DESCRIPTOR$SDL_GetRenderer);
        SEGMENT$SDL_GetRenderWindow = loader.apply("SDL_GetRenderWindow");
        HANDLE$SDL_GetRenderWindow = RawFunctionLoader.link(SEGMENT$SDL_GetRenderWindow, Descriptors.DESCRIPTOR$SDL_GetRenderWindow);
        SEGMENT$SDL_GetRendererName = loader.apply("SDL_GetRendererName");
        HANDLE$SDL_GetRendererName = RawFunctionLoader.link(SEGMENT$SDL_GetRendererName, Descriptors.DESCRIPTOR$SDL_GetRendererName);
        SEGMENT$SDL_GetRendererProperties = loader.apply("SDL_GetRendererProperties");
        HANDLE$SDL_GetRendererProperties = RawFunctionLoader.link(SEGMENT$SDL_GetRendererProperties, Descriptors.DESCRIPTOR$SDL_GetRendererProperties);
        SEGMENT$SDL_GetRenderOutputSize = loader.apply("SDL_GetRenderOutputSize");
        HANDLE$SDL_GetRenderOutputSize = RawFunctionLoader.link(SEGMENT$SDL_GetRenderOutputSize, Descriptors.DESCRIPTOR$SDL_GetRenderOutputSize);
        SEGMENT$SDL_GetCurrentRenderOutputSize = loader.apply("SDL_GetCurrentRenderOutputSize");
        HANDLE$SDL_GetCurrentRenderOutputSize = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentRenderOutputSize, Descriptors.DESCRIPTOR$SDL_GetCurrentRenderOutputSize);
        SEGMENT$SDL_CreateTexture = loader.apply("SDL_CreateTexture");
        HANDLE$SDL_CreateTexture = RawFunctionLoader.link(SEGMENT$SDL_CreateTexture, Descriptors.DESCRIPTOR$SDL_CreateTexture);
        SEGMENT$SDL_CreateTextureFromSurface = loader.apply("SDL_CreateTextureFromSurface");
        HANDLE$SDL_CreateTextureFromSurface = RawFunctionLoader.link(SEGMENT$SDL_CreateTextureFromSurface, Descriptors.DESCRIPTOR$SDL_CreateTextureFromSurface);
        SEGMENT$SDL_CreateTextureWithProperties = loader.apply("SDL_CreateTextureWithProperties");
        HANDLE$SDL_CreateTextureWithProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateTextureWithProperties, Descriptors.DESCRIPTOR$SDL_CreateTextureWithProperties);
        SEGMENT$SDL_GetTextureProperties = loader.apply("SDL_GetTextureProperties");
        HANDLE$SDL_GetTextureProperties = RawFunctionLoader.link(SEGMENT$SDL_GetTextureProperties, Descriptors.DESCRIPTOR$SDL_GetTextureProperties);
        SEGMENT$SDL_GetRendererFromTexture = loader.apply("SDL_GetRendererFromTexture");
        HANDLE$SDL_GetRendererFromTexture = RawFunctionLoader.link(SEGMENT$SDL_GetRendererFromTexture, Descriptors.DESCRIPTOR$SDL_GetRendererFromTexture);
        SEGMENT$SDL_GetTextureSize = loader.apply("SDL_GetTextureSize");
        HANDLE$SDL_GetTextureSize = RawFunctionLoader.link(SEGMENT$SDL_GetTextureSize, Descriptors.DESCRIPTOR$SDL_GetTextureSize);
        SEGMENT$SDL_SetTextureColorMod = loader.apply("SDL_SetTextureColorMod");
        HANDLE$SDL_SetTextureColorMod = RawFunctionLoader.link(SEGMENT$SDL_SetTextureColorMod, Descriptors.DESCRIPTOR$SDL_SetTextureColorMod);
        SEGMENT$SDL_SetTextureColorModFloat = loader.apply("SDL_SetTextureColorModFloat");
        HANDLE$SDL_SetTextureColorModFloat = RawFunctionLoader.link(SEGMENT$SDL_SetTextureColorModFloat, Descriptors.DESCRIPTOR$SDL_SetTextureColorModFloat);
        SEGMENT$SDL_GetTextureColorMod = loader.apply("SDL_GetTextureColorMod");
        HANDLE$SDL_GetTextureColorMod = RawFunctionLoader.link(SEGMENT$SDL_GetTextureColorMod, Descriptors.DESCRIPTOR$SDL_GetTextureColorMod);
        SEGMENT$SDL_GetTextureColorModFloat = loader.apply("SDL_GetTextureColorModFloat");
        HANDLE$SDL_GetTextureColorModFloat = RawFunctionLoader.link(SEGMENT$SDL_GetTextureColorModFloat, Descriptors.DESCRIPTOR$SDL_GetTextureColorModFloat);
        SEGMENT$SDL_SetTextureAlphaMod = loader.apply("SDL_SetTextureAlphaMod");
        HANDLE$SDL_SetTextureAlphaMod = RawFunctionLoader.link(SEGMENT$SDL_SetTextureAlphaMod, Descriptors.DESCRIPTOR$SDL_SetTextureAlphaMod);
        SEGMENT$SDL_SetTextureAlphaModFloat = loader.apply("SDL_SetTextureAlphaModFloat");
        HANDLE$SDL_SetTextureAlphaModFloat = RawFunctionLoader.link(SEGMENT$SDL_SetTextureAlphaModFloat, Descriptors.DESCRIPTOR$SDL_SetTextureAlphaModFloat);
        SEGMENT$SDL_GetTextureAlphaMod = loader.apply("SDL_GetTextureAlphaMod");
        HANDLE$SDL_GetTextureAlphaMod = RawFunctionLoader.link(SEGMENT$SDL_GetTextureAlphaMod, Descriptors.DESCRIPTOR$SDL_GetTextureAlphaMod);
        SEGMENT$SDL_GetTextureAlphaModFloat = loader.apply("SDL_GetTextureAlphaModFloat");
        HANDLE$SDL_GetTextureAlphaModFloat = RawFunctionLoader.link(SEGMENT$SDL_GetTextureAlphaModFloat, Descriptors.DESCRIPTOR$SDL_GetTextureAlphaModFloat);
        SEGMENT$SDL_SetTextureBlendMode = loader.apply("SDL_SetTextureBlendMode");
        HANDLE$SDL_SetTextureBlendMode = RawFunctionLoader.link(SEGMENT$SDL_SetTextureBlendMode, Descriptors.DESCRIPTOR$SDL_SetTextureBlendMode);
        SEGMENT$SDL_GetTextureBlendMode = loader.apply("SDL_GetTextureBlendMode");
        HANDLE$SDL_GetTextureBlendMode = RawFunctionLoader.link(SEGMENT$SDL_GetTextureBlendMode, Descriptors.DESCRIPTOR$SDL_GetTextureBlendMode);
        SEGMENT$SDL_SetTextureScaleMode = loader.apply("SDL_SetTextureScaleMode");
        HANDLE$SDL_SetTextureScaleMode = RawFunctionLoader.link(SEGMENT$SDL_SetTextureScaleMode, Descriptors.DESCRIPTOR$SDL_SetTextureScaleMode);
        SEGMENT$SDL_GetTextureScaleMode = loader.apply("SDL_GetTextureScaleMode");
        HANDLE$SDL_GetTextureScaleMode = RawFunctionLoader.link(SEGMENT$SDL_GetTextureScaleMode, Descriptors.DESCRIPTOR$SDL_GetTextureScaleMode);
        SEGMENT$SDL_UpdateTexture = loader.apply("SDL_UpdateTexture");
        HANDLE$SDL_UpdateTexture = RawFunctionLoader.link(SEGMENT$SDL_UpdateTexture, Descriptors.DESCRIPTOR$SDL_UpdateTexture);
        SEGMENT$SDL_UpdateYUVTexture = loader.apply("SDL_UpdateYUVTexture");
        HANDLE$SDL_UpdateYUVTexture = RawFunctionLoader.link(SEGMENT$SDL_UpdateYUVTexture, Descriptors.DESCRIPTOR$SDL_UpdateYUVTexture);
        SEGMENT$SDL_UpdateNVTexture = loader.apply("SDL_UpdateNVTexture");
        HANDLE$SDL_UpdateNVTexture = RawFunctionLoader.link(SEGMENT$SDL_UpdateNVTexture, Descriptors.DESCRIPTOR$SDL_UpdateNVTexture);
        SEGMENT$SDL_LockTexture = loader.apply("SDL_LockTexture");
        HANDLE$SDL_LockTexture = RawFunctionLoader.link(SEGMENT$SDL_LockTexture, Descriptors.DESCRIPTOR$SDL_LockTexture);
        SEGMENT$SDL_LockTextureToSurface = loader.apply("SDL_LockTextureToSurface");
        HANDLE$SDL_LockTextureToSurface = RawFunctionLoader.link(SEGMENT$SDL_LockTextureToSurface, Descriptors.DESCRIPTOR$SDL_LockTextureToSurface);
        SEGMENT$SDL_UnlockTexture = loader.apply("SDL_UnlockTexture");
        HANDLE$SDL_UnlockTexture = RawFunctionLoader.link(SEGMENT$SDL_UnlockTexture, Descriptors.DESCRIPTOR$SDL_UnlockTexture);
        SEGMENT$SDL_SetRenderTarget = loader.apply("SDL_SetRenderTarget");
        HANDLE$SDL_SetRenderTarget = RawFunctionLoader.link(SEGMENT$SDL_SetRenderTarget, Descriptors.DESCRIPTOR$SDL_SetRenderTarget);
        SEGMENT$SDL_GetRenderTarget = loader.apply("SDL_GetRenderTarget");
        HANDLE$SDL_GetRenderTarget = RawFunctionLoader.link(SEGMENT$SDL_GetRenderTarget, Descriptors.DESCRIPTOR$SDL_GetRenderTarget);
        SEGMENT$SDL_SetRenderLogicalPresentation = loader.apply("SDL_SetRenderLogicalPresentation");
        HANDLE$SDL_SetRenderLogicalPresentation = RawFunctionLoader.link(SEGMENT$SDL_SetRenderLogicalPresentation, Descriptors.DESCRIPTOR$SDL_SetRenderLogicalPresentation);
        SEGMENT$SDL_GetRenderLogicalPresentation = loader.apply("SDL_GetRenderLogicalPresentation");
        HANDLE$SDL_GetRenderLogicalPresentation = RawFunctionLoader.link(SEGMENT$SDL_GetRenderLogicalPresentation, Descriptors.DESCRIPTOR$SDL_GetRenderLogicalPresentation);
        SEGMENT$SDL_GetRenderLogicalPresentationRect = loader.apply("SDL_GetRenderLogicalPresentationRect");
        HANDLE$SDL_GetRenderLogicalPresentationRect = RawFunctionLoader.link(SEGMENT$SDL_GetRenderLogicalPresentationRect, Descriptors.DESCRIPTOR$SDL_GetRenderLogicalPresentationRect);
        SEGMENT$SDL_RenderCoordinatesFromWindow = loader.apply("SDL_RenderCoordinatesFromWindow");
        HANDLE$SDL_RenderCoordinatesFromWindow = RawFunctionLoader.link(SEGMENT$SDL_RenderCoordinatesFromWindow, Descriptors.DESCRIPTOR$SDL_RenderCoordinatesFromWindow);
        SEGMENT$SDL_RenderCoordinatesToWindow = loader.apply("SDL_RenderCoordinatesToWindow");
        HANDLE$SDL_RenderCoordinatesToWindow = RawFunctionLoader.link(SEGMENT$SDL_RenderCoordinatesToWindow, Descriptors.DESCRIPTOR$SDL_RenderCoordinatesToWindow);
        SEGMENT$SDL_ConvertEventToRenderCoordinates = loader.apply("SDL_ConvertEventToRenderCoordinates");
        HANDLE$SDL_ConvertEventToRenderCoordinates = RawFunctionLoader.link(SEGMENT$SDL_ConvertEventToRenderCoordinates, Descriptors.DESCRIPTOR$SDL_ConvertEventToRenderCoordinates);
        SEGMENT$SDL_SetRenderViewport = loader.apply("SDL_SetRenderViewport");
        HANDLE$SDL_SetRenderViewport = RawFunctionLoader.link(SEGMENT$SDL_SetRenderViewport, Descriptors.DESCRIPTOR$SDL_SetRenderViewport);
        SEGMENT$SDL_GetRenderViewport = loader.apply("SDL_GetRenderViewport");
        HANDLE$SDL_GetRenderViewport = RawFunctionLoader.link(SEGMENT$SDL_GetRenderViewport, Descriptors.DESCRIPTOR$SDL_GetRenderViewport);
        SEGMENT$SDL_RenderViewportSet = loader.apply("SDL_RenderViewportSet");
        HANDLE$SDL_RenderViewportSet = RawFunctionLoader.link(SEGMENT$SDL_RenderViewportSet, Descriptors.DESCRIPTOR$SDL_RenderViewportSet);
        SEGMENT$SDL_GetRenderSafeArea = loader.apply("SDL_GetRenderSafeArea");
        HANDLE$SDL_GetRenderSafeArea = RawFunctionLoader.link(SEGMENT$SDL_GetRenderSafeArea, Descriptors.DESCRIPTOR$SDL_GetRenderSafeArea);
        SEGMENT$SDL_SetRenderClipRect = loader.apply("SDL_SetRenderClipRect");
        HANDLE$SDL_SetRenderClipRect = RawFunctionLoader.link(SEGMENT$SDL_SetRenderClipRect, Descriptors.DESCRIPTOR$SDL_SetRenderClipRect);
        SEGMENT$SDL_GetRenderClipRect = loader.apply("SDL_GetRenderClipRect");
        HANDLE$SDL_GetRenderClipRect = RawFunctionLoader.link(SEGMENT$SDL_GetRenderClipRect, Descriptors.DESCRIPTOR$SDL_GetRenderClipRect);
        SEGMENT$SDL_RenderClipEnabled = loader.apply("SDL_RenderClipEnabled");
        HANDLE$SDL_RenderClipEnabled = RawFunctionLoader.link(SEGMENT$SDL_RenderClipEnabled, Descriptors.DESCRIPTOR$SDL_RenderClipEnabled);
        SEGMENT$SDL_SetRenderScale = loader.apply("SDL_SetRenderScale");
        HANDLE$SDL_SetRenderScale = RawFunctionLoader.link(SEGMENT$SDL_SetRenderScale, Descriptors.DESCRIPTOR$SDL_SetRenderScale);
        SEGMENT$SDL_GetRenderScale = loader.apply("SDL_GetRenderScale");
        HANDLE$SDL_GetRenderScale = RawFunctionLoader.link(SEGMENT$SDL_GetRenderScale, Descriptors.DESCRIPTOR$SDL_GetRenderScale);
        SEGMENT$SDL_SetRenderDrawColor = loader.apply("SDL_SetRenderDrawColor");
        HANDLE$SDL_SetRenderDrawColor = RawFunctionLoader.link(SEGMENT$SDL_SetRenderDrawColor, Descriptors.DESCRIPTOR$SDL_SetRenderDrawColor);
        SEGMENT$SDL_SetRenderDrawColorFloat = loader.apply("SDL_SetRenderDrawColorFloat");
        HANDLE$SDL_SetRenderDrawColorFloat = RawFunctionLoader.link(SEGMENT$SDL_SetRenderDrawColorFloat, Descriptors.DESCRIPTOR$SDL_SetRenderDrawColorFloat);
        SEGMENT$SDL_GetRenderDrawColor = loader.apply("SDL_GetRenderDrawColor");
        HANDLE$SDL_GetRenderDrawColor = RawFunctionLoader.link(SEGMENT$SDL_GetRenderDrawColor, Descriptors.DESCRIPTOR$SDL_GetRenderDrawColor);
        SEGMENT$SDL_GetRenderDrawColorFloat = loader.apply("SDL_GetRenderDrawColorFloat");
        HANDLE$SDL_GetRenderDrawColorFloat = RawFunctionLoader.link(SEGMENT$SDL_GetRenderDrawColorFloat, Descriptors.DESCRIPTOR$SDL_GetRenderDrawColorFloat);
        SEGMENT$SDL_SetRenderColorScale = loader.apply("SDL_SetRenderColorScale");
        HANDLE$SDL_SetRenderColorScale = RawFunctionLoader.link(SEGMENT$SDL_SetRenderColorScale, Descriptors.DESCRIPTOR$SDL_SetRenderColorScale);
        SEGMENT$SDL_GetRenderColorScale = loader.apply("SDL_GetRenderColorScale");
        HANDLE$SDL_GetRenderColorScale = RawFunctionLoader.link(SEGMENT$SDL_GetRenderColorScale, Descriptors.DESCRIPTOR$SDL_GetRenderColorScale);
        SEGMENT$SDL_SetRenderDrawBlendMode = loader.apply("SDL_SetRenderDrawBlendMode");
        HANDLE$SDL_SetRenderDrawBlendMode = RawFunctionLoader.link(SEGMENT$SDL_SetRenderDrawBlendMode, Descriptors.DESCRIPTOR$SDL_SetRenderDrawBlendMode);
        SEGMENT$SDL_GetRenderDrawBlendMode = loader.apply("SDL_GetRenderDrawBlendMode");
        HANDLE$SDL_GetRenderDrawBlendMode = RawFunctionLoader.link(SEGMENT$SDL_GetRenderDrawBlendMode, Descriptors.DESCRIPTOR$SDL_GetRenderDrawBlendMode);
        SEGMENT$SDL_RenderClear = loader.apply("SDL_RenderClear");
        HANDLE$SDL_RenderClear = RawFunctionLoader.link(SEGMENT$SDL_RenderClear, Descriptors.DESCRIPTOR$SDL_RenderClear);
        SEGMENT$SDL_RenderPoint = loader.apply("SDL_RenderPoint");
        HANDLE$SDL_RenderPoint = RawFunctionLoader.link(SEGMENT$SDL_RenderPoint, Descriptors.DESCRIPTOR$SDL_RenderPoint);
        SEGMENT$SDL_RenderPoints = loader.apply("SDL_RenderPoints");
        HANDLE$SDL_RenderPoints = RawFunctionLoader.link(SEGMENT$SDL_RenderPoints, Descriptors.DESCRIPTOR$SDL_RenderPoints);
        SEGMENT$SDL_RenderLine = loader.apply("SDL_RenderLine");
        HANDLE$SDL_RenderLine = RawFunctionLoader.link(SEGMENT$SDL_RenderLine, Descriptors.DESCRIPTOR$SDL_RenderLine);
        SEGMENT$SDL_RenderLines = loader.apply("SDL_RenderLines");
        HANDLE$SDL_RenderLines = RawFunctionLoader.link(SEGMENT$SDL_RenderLines, Descriptors.DESCRIPTOR$SDL_RenderLines);
        SEGMENT$SDL_RenderRect = loader.apply("SDL_RenderRect");
        HANDLE$SDL_RenderRect = RawFunctionLoader.link(SEGMENT$SDL_RenderRect, Descriptors.DESCRIPTOR$SDL_RenderRect);
        SEGMENT$SDL_RenderRects = loader.apply("SDL_RenderRects");
        HANDLE$SDL_RenderRects = RawFunctionLoader.link(SEGMENT$SDL_RenderRects, Descriptors.DESCRIPTOR$SDL_RenderRects);
        SEGMENT$SDL_RenderFillRect = loader.apply("SDL_RenderFillRect");
        HANDLE$SDL_RenderFillRect = RawFunctionLoader.link(SEGMENT$SDL_RenderFillRect, Descriptors.DESCRIPTOR$SDL_RenderFillRect);
        SEGMENT$SDL_RenderFillRects = loader.apply("SDL_RenderFillRects");
        HANDLE$SDL_RenderFillRects = RawFunctionLoader.link(SEGMENT$SDL_RenderFillRects, Descriptors.DESCRIPTOR$SDL_RenderFillRects);
        SEGMENT$SDL_RenderTexture = loader.apply("SDL_RenderTexture");
        HANDLE$SDL_RenderTexture = RawFunctionLoader.link(SEGMENT$SDL_RenderTexture, Descriptors.DESCRIPTOR$SDL_RenderTexture);
        SEGMENT$SDL_RenderTextureRotated = loader.apply("SDL_RenderTextureRotated");
        HANDLE$SDL_RenderTextureRotated = RawFunctionLoader.link(SEGMENT$SDL_RenderTextureRotated, Descriptors.DESCRIPTOR$SDL_RenderTextureRotated);
        SEGMENT$SDL_RenderTextureAffine = loader.apply("SDL_RenderTextureAffine");
        HANDLE$SDL_RenderTextureAffine = RawFunctionLoader.link(SEGMENT$SDL_RenderTextureAffine, Descriptors.DESCRIPTOR$SDL_RenderTextureAffine);
        SEGMENT$SDL_RenderTextureTiled = loader.apply("SDL_RenderTextureTiled");
        HANDLE$SDL_RenderTextureTiled = RawFunctionLoader.link(SEGMENT$SDL_RenderTextureTiled, Descriptors.DESCRIPTOR$SDL_RenderTextureTiled);
        SEGMENT$SDL_RenderTexture9Grid = loader.apply("SDL_RenderTexture9Grid");
        HANDLE$SDL_RenderTexture9Grid = RawFunctionLoader.link(SEGMENT$SDL_RenderTexture9Grid, Descriptors.DESCRIPTOR$SDL_RenderTexture9Grid);
        SEGMENT$SDL_RenderGeometry = loader.apply("SDL_RenderGeometry");
        HANDLE$SDL_RenderGeometry = RawFunctionLoader.link(SEGMENT$SDL_RenderGeometry, Descriptors.DESCRIPTOR$SDL_RenderGeometry);
        SEGMENT$SDL_RenderGeometryRaw = loader.apply("SDL_RenderGeometryRaw");
        HANDLE$SDL_RenderGeometryRaw = RawFunctionLoader.link(SEGMENT$SDL_RenderGeometryRaw, Descriptors.DESCRIPTOR$SDL_RenderGeometryRaw);
        SEGMENT$SDL_RenderReadPixels = loader.apply("SDL_RenderReadPixels");
        HANDLE$SDL_RenderReadPixels = RawFunctionLoader.link(SEGMENT$SDL_RenderReadPixels, Descriptors.DESCRIPTOR$SDL_RenderReadPixels);
        SEGMENT$SDL_RenderPresent = loader.apply("SDL_RenderPresent");
        HANDLE$SDL_RenderPresent = RawFunctionLoader.link(SEGMENT$SDL_RenderPresent, Descriptors.DESCRIPTOR$SDL_RenderPresent);
        SEGMENT$SDL_DestroyTexture = loader.apply("SDL_DestroyTexture");
        HANDLE$SDL_DestroyTexture = RawFunctionLoader.link(SEGMENT$SDL_DestroyTexture, Descriptors.DESCRIPTOR$SDL_DestroyTexture);
        SEGMENT$SDL_DestroyRenderer = loader.apply("SDL_DestroyRenderer");
        HANDLE$SDL_DestroyRenderer = RawFunctionLoader.link(SEGMENT$SDL_DestroyRenderer, Descriptors.DESCRIPTOR$SDL_DestroyRenderer);
        SEGMENT$SDL_FlushRenderer = loader.apply("SDL_FlushRenderer");
        HANDLE$SDL_FlushRenderer = RawFunctionLoader.link(SEGMENT$SDL_FlushRenderer, Descriptors.DESCRIPTOR$SDL_FlushRenderer);
        SEGMENT$SDL_GetRenderMetalLayer = loader.apply("SDL_GetRenderMetalLayer");
        HANDLE$SDL_GetRenderMetalLayer = RawFunctionLoader.link(SEGMENT$SDL_GetRenderMetalLayer, Descriptors.DESCRIPTOR$SDL_GetRenderMetalLayer);
        SEGMENT$SDL_GetRenderMetalCommandEncoder = loader.apply("SDL_GetRenderMetalCommandEncoder");
        HANDLE$SDL_GetRenderMetalCommandEncoder = RawFunctionLoader.link(SEGMENT$SDL_GetRenderMetalCommandEncoder, Descriptors.DESCRIPTOR$SDL_GetRenderMetalCommandEncoder);
        SEGMENT$SDL_AddVulkanRenderSemaphores = loader.apply("SDL_AddVulkanRenderSemaphores");
        HANDLE$SDL_AddVulkanRenderSemaphores = RawFunctionLoader.link(SEGMENT$SDL_AddVulkanRenderSemaphores, Descriptors.DESCRIPTOR$SDL_AddVulkanRenderSemaphores);
        SEGMENT$SDL_SetRenderVSync = loader.apply("SDL_SetRenderVSync");
        HANDLE$SDL_SetRenderVSync = RawFunctionLoader.link(SEGMENT$SDL_SetRenderVSync, Descriptors.DESCRIPTOR$SDL_SetRenderVSync);
        SEGMENT$SDL_GetRenderVSync = loader.apply("SDL_GetRenderVSync");
        HANDLE$SDL_GetRenderVSync = RawFunctionLoader.link(SEGMENT$SDL_GetRenderVSync, Descriptors.DESCRIPTOR$SDL_GetRenderVSync);
        SEGMENT$SDL_RenderDebugText = loader.apply("SDL_RenderDebugText");
        HANDLE$SDL_RenderDebugText = RawFunctionLoader.link(SEGMENT$SDL_RenderDebugText, Descriptors.DESCRIPTOR$SDL_RenderDebugText);
        SEGMENT$SDL_GetSensors = loader.apply("SDL_GetSensors");
        HANDLE$SDL_GetSensors = RawFunctionLoader.link(SEGMENT$SDL_GetSensors, Descriptors.DESCRIPTOR$SDL_GetSensors);
        SEGMENT$SDL_GetSensorNameForID = loader.apply("SDL_GetSensorNameForID");
        HANDLE$SDL_GetSensorNameForID = RawFunctionLoader.link(SEGMENT$SDL_GetSensorNameForID, Descriptors.DESCRIPTOR$SDL_GetSensorNameForID);
        SEGMENT$SDL_GetSensorTypeForID = loader.apply("SDL_GetSensorTypeForID");
        HANDLE$SDL_GetSensorTypeForID = RawFunctionLoader.link(SEGMENT$SDL_GetSensorTypeForID, Descriptors.DESCRIPTOR$SDL_GetSensorTypeForID);
        SEGMENT$SDL_GetSensorNonPortableTypeForID = loader.apply("SDL_GetSensorNonPortableTypeForID");
        HANDLE$SDL_GetSensorNonPortableTypeForID = RawFunctionLoader.link(SEGMENT$SDL_GetSensorNonPortableTypeForID, Descriptors.DESCRIPTOR$SDL_GetSensorNonPortableTypeForID);
        SEGMENT$SDL_OpenSensor = loader.apply("SDL_OpenSensor");
        HANDLE$SDL_OpenSensor = RawFunctionLoader.link(SEGMENT$SDL_OpenSensor, Descriptors.DESCRIPTOR$SDL_OpenSensor);
        SEGMENT$SDL_GetSensorFromID = loader.apply("SDL_GetSensorFromID");
        HANDLE$SDL_GetSensorFromID = RawFunctionLoader.link(SEGMENT$SDL_GetSensorFromID, Descriptors.DESCRIPTOR$SDL_GetSensorFromID);
        SEGMENT$SDL_GetSensorProperties = loader.apply("SDL_GetSensorProperties");
        HANDLE$SDL_GetSensorProperties = RawFunctionLoader.link(SEGMENT$SDL_GetSensorProperties, Descriptors.DESCRIPTOR$SDL_GetSensorProperties);
        SEGMENT$SDL_GetSensorName = loader.apply("SDL_GetSensorName");
        HANDLE$SDL_GetSensorName = RawFunctionLoader.link(SEGMENT$SDL_GetSensorName, Descriptors.DESCRIPTOR$SDL_GetSensorName);
        SEGMENT$SDL_GetSensorType = loader.apply("SDL_GetSensorType");
        HANDLE$SDL_GetSensorType = RawFunctionLoader.link(SEGMENT$SDL_GetSensorType, Descriptors.DESCRIPTOR$SDL_GetSensorType);
        SEGMENT$SDL_GetSensorNonPortableType = loader.apply("SDL_GetSensorNonPortableType");
        HANDLE$SDL_GetSensorNonPortableType = RawFunctionLoader.link(SEGMENT$SDL_GetSensorNonPortableType, Descriptors.DESCRIPTOR$SDL_GetSensorNonPortableType);
        SEGMENT$SDL_GetSensorID = loader.apply("SDL_GetSensorID");
        HANDLE$SDL_GetSensorID = RawFunctionLoader.link(SEGMENT$SDL_GetSensorID, Descriptors.DESCRIPTOR$SDL_GetSensorID);
        SEGMENT$SDL_GetSensorData = loader.apply("SDL_GetSensorData");
        HANDLE$SDL_GetSensorData = RawFunctionLoader.link(SEGMENT$SDL_GetSensorData, Descriptors.DESCRIPTOR$SDL_GetSensorData);
        SEGMENT$SDL_CloseSensor = loader.apply("SDL_CloseSensor");
        HANDLE$SDL_CloseSensor = RawFunctionLoader.link(SEGMENT$SDL_CloseSensor, Descriptors.DESCRIPTOR$SDL_CloseSensor);
        SEGMENT$SDL_UpdateSensors = loader.apply("SDL_UpdateSensors");
        HANDLE$SDL_UpdateSensors = RawFunctionLoader.link(SEGMENT$SDL_UpdateSensors, Descriptors.DESCRIPTOR$SDL_UpdateSensors);
        SEGMENT$SDL_OpenTitleStorage = loader.apply("SDL_OpenTitleStorage");
        HANDLE$SDL_OpenTitleStorage = RawFunctionLoader.link(SEGMENT$SDL_OpenTitleStorage, Descriptors.DESCRIPTOR$SDL_OpenTitleStorage);
        SEGMENT$SDL_OpenUserStorage = loader.apply("SDL_OpenUserStorage");
        HANDLE$SDL_OpenUserStorage = RawFunctionLoader.link(SEGMENT$SDL_OpenUserStorage, Descriptors.DESCRIPTOR$SDL_OpenUserStorage);
        SEGMENT$SDL_OpenFileStorage = loader.apply("SDL_OpenFileStorage");
        HANDLE$SDL_OpenFileStorage = RawFunctionLoader.link(SEGMENT$SDL_OpenFileStorage, Descriptors.DESCRIPTOR$SDL_OpenFileStorage);
        SEGMENT$SDL_OpenStorage = loader.apply("SDL_OpenStorage");
        HANDLE$SDL_OpenStorage = RawFunctionLoader.link(SEGMENT$SDL_OpenStorage, Descriptors.DESCRIPTOR$SDL_OpenStorage);
        SEGMENT$SDL_CloseStorage = loader.apply("SDL_CloseStorage");
        HANDLE$SDL_CloseStorage = RawFunctionLoader.link(SEGMENT$SDL_CloseStorage, Descriptors.DESCRIPTOR$SDL_CloseStorage);
        SEGMENT$SDL_StorageReady = loader.apply("SDL_StorageReady");
        HANDLE$SDL_StorageReady = RawFunctionLoader.link(SEGMENT$SDL_StorageReady, Descriptors.DESCRIPTOR$SDL_StorageReady);
        SEGMENT$SDL_GetStorageFileSize = loader.apply("SDL_GetStorageFileSize");
        HANDLE$SDL_GetStorageFileSize = RawFunctionLoader.link(SEGMENT$SDL_GetStorageFileSize, Descriptors.DESCRIPTOR$SDL_GetStorageFileSize);
        SEGMENT$SDL_ReadStorageFile = loader.apply("SDL_ReadStorageFile");
        HANDLE$SDL_ReadStorageFile = RawFunctionLoader.link(SEGMENT$SDL_ReadStorageFile, Descriptors.DESCRIPTOR$SDL_ReadStorageFile);
        SEGMENT$SDL_WriteStorageFile = loader.apply("SDL_WriteStorageFile");
        HANDLE$SDL_WriteStorageFile = RawFunctionLoader.link(SEGMENT$SDL_WriteStorageFile, Descriptors.DESCRIPTOR$SDL_WriteStorageFile);
        SEGMENT$SDL_CreateStorageDirectory = loader.apply("SDL_CreateStorageDirectory");
        HANDLE$SDL_CreateStorageDirectory = RawFunctionLoader.link(SEGMENT$SDL_CreateStorageDirectory, Descriptors.DESCRIPTOR$SDL_CreateStorageDirectory);
        SEGMENT$SDL_EnumerateStorageDirectory = loader.apply("SDL_EnumerateStorageDirectory");
        HANDLE$SDL_EnumerateStorageDirectory = RawFunctionLoader.link(SEGMENT$SDL_EnumerateStorageDirectory, Descriptors.DESCRIPTOR$SDL_EnumerateStorageDirectory);
        SEGMENT$SDL_RemoveStoragePath = loader.apply("SDL_RemoveStoragePath");
        HANDLE$SDL_RemoveStoragePath = RawFunctionLoader.link(SEGMENT$SDL_RemoveStoragePath, Descriptors.DESCRIPTOR$SDL_RemoveStoragePath);
        SEGMENT$SDL_RenameStoragePath = loader.apply("SDL_RenameStoragePath");
        HANDLE$SDL_RenameStoragePath = RawFunctionLoader.link(SEGMENT$SDL_RenameStoragePath, Descriptors.DESCRIPTOR$SDL_RenameStoragePath);
        SEGMENT$SDL_CopyStorageFile = loader.apply("SDL_CopyStorageFile");
        HANDLE$SDL_CopyStorageFile = RawFunctionLoader.link(SEGMENT$SDL_CopyStorageFile, Descriptors.DESCRIPTOR$SDL_CopyStorageFile);
        SEGMENT$SDL_GetStoragePathInfo = loader.apply("SDL_GetStoragePathInfo");
        HANDLE$SDL_GetStoragePathInfo = RawFunctionLoader.link(SEGMENT$SDL_GetStoragePathInfo, Descriptors.DESCRIPTOR$SDL_GetStoragePathInfo);
        SEGMENT$SDL_GetStorageSpaceRemaining = loader.apply("SDL_GetStorageSpaceRemaining");
        HANDLE$SDL_GetStorageSpaceRemaining = RawFunctionLoader.link(SEGMENT$SDL_GetStorageSpaceRemaining, Descriptors.DESCRIPTOR$SDL_GetStorageSpaceRemaining);
        SEGMENT$SDL_GlobStorageDirectory = loader.apply("SDL_GlobStorageDirectory");
        HANDLE$SDL_GlobStorageDirectory = RawFunctionLoader.link(SEGMENT$SDL_GlobStorageDirectory, Descriptors.DESCRIPTOR$SDL_GlobStorageDirectory);
        SEGMENT$SDL_CreateSurface = loader.apply("SDL_CreateSurface");
        HANDLE$SDL_CreateSurface = RawFunctionLoader.link(SEGMENT$SDL_CreateSurface, Descriptors.DESCRIPTOR$SDL_CreateSurface);
        SEGMENT$SDL_CreateSurfaceFrom = loader.apply("SDL_CreateSurfaceFrom");
        HANDLE$SDL_CreateSurfaceFrom = RawFunctionLoader.link(SEGMENT$SDL_CreateSurfaceFrom, Descriptors.DESCRIPTOR$SDL_CreateSurfaceFrom);
        SEGMENT$SDL_DestroySurface = loader.apply("SDL_DestroySurface");
        HANDLE$SDL_DestroySurface = RawFunctionLoader.link(SEGMENT$SDL_DestroySurface, Descriptors.DESCRIPTOR$SDL_DestroySurface);
        SEGMENT$SDL_GetSurfaceProperties = loader.apply("SDL_GetSurfaceProperties");
        HANDLE$SDL_GetSurfaceProperties = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceProperties, Descriptors.DESCRIPTOR$SDL_GetSurfaceProperties);
        SEGMENT$SDL_SetSurfaceColorspace = loader.apply("SDL_SetSurfaceColorspace");
        HANDLE$SDL_SetSurfaceColorspace = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceColorspace, Descriptors.DESCRIPTOR$SDL_SetSurfaceColorspace);
        SEGMENT$SDL_GetSurfaceColorspace = loader.apply("SDL_GetSurfaceColorspace");
        HANDLE$SDL_GetSurfaceColorspace = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceColorspace, Descriptors.DESCRIPTOR$SDL_GetSurfaceColorspace);
        SEGMENT$SDL_CreateSurfacePalette = loader.apply("SDL_CreateSurfacePalette");
        HANDLE$SDL_CreateSurfacePalette = RawFunctionLoader.link(SEGMENT$SDL_CreateSurfacePalette, Descriptors.DESCRIPTOR$SDL_CreateSurfacePalette);
        SEGMENT$SDL_SetSurfacePalette = loader.apply("SDL_SetSurfacePalette");
        HANDLE$SDL_SetSurfacePalette = RawFunctionLoader.link(SEGMENT$SDL_SetSurfacePalette, Descriptors.DESCRIPTOR$SDL_SetSurfacePalette);
        SEGMENT$SDL_GetSurfacePalette = loader.apply("SDL_GetSurfacePalette");
        HANDLE$SDL_GetSurfacePalette = RawFunctionLoader.link(SEGMENT$SDL_GetSurfacePalette, Descriptors.DESCRIPTOR$SDL_GetSurfacePalette);
        SEGMENT$SDL_AddSurfaceAlternateImage = loader.apply("SDL_AddSurfaceAlternateImage");
        HANDLE$SDL_AddSurfaceAlternateImage = RawFunctionLoader.link(SEGMENT$SDL_AddSurfaceAlternateImage, Descriptors.DESCRIPTOR$SDL_AddSurfaceAlternateImage);
        SEGMENT$SDL_SurfaceHasAlternateImages = loader.apply("SDL_SurfaceHasAlternateImages");
        HANDLE$SDL_SurfaceHasAlternateImages = RawFunctionLoader.link(SEGMENT$SDL_SurfaceHasAlternateImages, Descriptors.DESCRIPTOR$SDL_SurfaceHasAlternateImages);
        SEGMENT$SDL_GetSurfaceImages = loader.apply("SDL_GetSurfaceImages");
        HANDLE$SDL_GetSurfaceImages = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceImages, Descriptors.DESCRIPTOR$SDL_GetSurfaceImages);
        SEGMENT$SDL_RemoveSurfaceAlternateImages = loader.apply("SDL_RemoveSurfaceAlternateImages");
        HANDLE$SDL_RemoveSurfaceAlternateImages = RawFunctionLoader.link(SEGMENT$SDL_RemoveSurfaceAlternateImages, Descriptors.DESCRIPTOR$SDL_RemoveSurfaceAlternateImages);
        SEGMENT$SDL_LockSurface = loader.apply("SDL_LockSurface");
        HANDLE$SDL_LockSurface = RawFunctionLoader.link(SEGMENT$SDL_LockSurface, Descriptors.DESCRIPTOR$SDL_LockSurface);
        SEGMENT$SDL_UnlockSurface = loader.apply("SDL_UnlockSurface");
        HANDLE$SDL_UnlockSurface = RawFunctionLoader.link(SEGMENT$SDL_UnlockSurface, Descriptors.DESCRIPTOR$SDL_UnlockSurface);
        SEGMENT$SDL_LoadBMP_IO = loader.apply("SDL_LoadBMP_IO");
        HANDLE$SDL_LoadBMP_IO = RawFunctionLoader.link(SEGMENT$SDL_LoadBMP_IO, Descriptors.DESCRIPTOR$SDL_LoadBMP_IO);
        SEGMENT$SDL_LoadBMP = loader.apply("SDL_LoadBMP");
        HANDLE$SDL_LoadBMP = RawFunctionLoader.link(SEGMENT$SDL_LoadBMP, Descriptors.DESCRIPTOR$SDL_LoadBMP);
        SEGMENT$SDL_SaveBMP_IO = loader.apply("SDL_SaveBMP_IO");
        HANDLE$SDL_SaveBMP_IO = RawFunctionLoader.link(SEGMENT$SDL_SaveBMP_IO, Descriptors.DESCRIPTOR$SDL_SaveBMP_IO);
        SEGMENT$SDL_SaveBMP = loader.apply("SDL_SaveBMP");
        HANDLE$SDL_SaveBMP = RawFunctionLoader.link(SEGMENT$SDL_SaveBMP, Descriptors.DESCRIPTOR$SDL_SaveBMP);
        SEGMENT$SDL_SetSurfaceRLE = loader.apply("SDL_SetSurfaceRLE");
        HANDLE$SDL_SetSurfaceRLE = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceRLE, Descriptors.DESCRIPTOR$SDL_SetSurfaceRLE);
        SEGMENT$SDL_SurfaceHasRLE = loader.apply("SDL_SurfaceHasRLE");
        HANDLE$SDL_SurfaceHasRLE = RawFunctionLoader.link(SEGMENT$SDL_SurfaceHasRLE, Descriptors.DESCRIPTOR$SDL_SurfaceHasRLE);
        SEGMENT$SDL_SetSurfaceColorKey = loader.apply("SDL_SetSurfaceColorKey");
        HANDLE$SDL_SetSurfaceColorKey = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceColorKey, Descriptors.DESCRIPTOR$SDL_SetSurfaceColorKey);
        SEGMENT$SDL_SurfaceHasColorKey = loader.apply("SDL_SurfaceHasColorKey");
        HANDLE$SDL_SurfaceHasColorKey = RawFunctionLoader.link(SEGMENT$SDL_SurfaceHasColorKey, Descriptors.DESCRIPTOR$SDL_SurfaceHasColorKey);
        SEGMENT$SDL_GetSurfaceColorKey = loader.apply("SDL_GetSurfaceColorKey");
        HANDLE$SDL_GetSurfaceColorKey = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceColorKey, Descriptors.DESCRIPTOR$SDL_GetSurfaceColorKey);
        SEGMENT$SDL_SetSurfaceColorMod = loader.apply("SDL_SetSurfaceColorMod");
        HANDLE$SDL_SetSurfaceColorMod = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceColorMod, Descriptors.DESCRIPTOR$SDL_SetSurfaceColorMod);
        SEGMENT$SDL_GetSurfaceColorMod = loader.apply("SDL_GetSurfaceColorMod");
        HANDLE$SDL_GetSurfaceColorMod = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceColorMod, Descriptors.DESCRIPTOR$SDL_GetSurfaceColorMod);
        SEGMENT$SDL_SetSurfaceAlphaMod = loader.apply("SDL_SetSurfaceAlphaMod");
        HANDLE$SDL_SetSurfaceAlphaMod = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceAlphaMod, Descriptors.DESCRIPTOR$SDL_SetSurfaceAlphaMod);
        SEGMENT$SDL_GetSurfaceAlphaMod = loader.apply("SDL_GetSurfaceAlphaMod");
        HANDLE$SDL_GetSurfaceAlphaMod = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceAlphaMod, Descriptors.DESCRIPTOR$SDL_GetSurfaceAlphaMod);
        SEGMENT$SDL_SetSurfaceBlendMode = loader.apply("SDL_SetSurfaceBlendMode");
        HANDLE$SDL_SetSurfaceBlendMode = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceBlendMode, Descriptors.DESCRIPTOR$SDL_SetSurfaceBlendMode);
        SEGMENT$SDL_GetSurfaceBlendMode = loader.apply("SDL_GetSurfaceBlendMode");
        HANDLE$SDL_GetSurfaceBlendMode = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceBlendMode, Descriptors.DESCRIPTOR$SDL_GetSurfaceBlendMode);
        SEGMENT$SDL_SetSurfaceClipRect = loader.apply("SDL_SetSurfaceClipRect");
        HANDLE$SDL_SetSurfaceClipRect = RawFunctionLoader.link(SEGMENT$SDL_SetSurfaceClipRect, Descriptors.DESCRIPTOR$SDL_SetSurfaceClipRect);
        SEGMENT$SDL_GetSurfaceClipRect = loader.apply("SDL_GetSurfaceClipRect");
        HANDLE$SDL_GetSurfaceClipRect = RawFunctionLoader.link(SEGMENT$SDL_GetSurfaceClipRect, Descriptors.DESCRIPTOR$SDL_GetSurfaceClipRect);
        SEGMENT$SDL_FlipSurface = loader.apply("SDL_FlipSurface");
        HANDLE$SDL_FlipSurface = RawFunctionLoader.link(SEGMENT$SDL_FlipSurface, Descriptors.DESCRIPTOR$SDL_FlipSurface);
        SEGMENT$SDL_DuplicateSurface = loader.apply("SDL_DuplicateSurface");
        HANDLE$SDL_DuplicateSurface = RawFunctionLoader.link(SEGMENT$SDL_DuplicateSurface, Descriptors.DESCRIPTOR$SDL_DuplicateSurface);
        SEGMENT$SDL_ScaleSurface = loader.apply("SDL_ScaleSurface");
        HANDLE$SDL_ScaleSurface = RawFunctionLoader.link(SEGMENT$SDL_ScaleSurface, Descriptors.DESCRIPTOR$SDL_ScaleSurface);
        SEGMENT$SDL_ConvertSurface = loader.apply("SDL_ConvertSurface");
        HANDLE$SDL_ConvertSurface = RawFunctionLoader.link(SEGMENT$SDL_ConvertSurface, Descriptors.DESCRIPTOR$SDL_ConvertSurface);
        SEGMENT$SDL_ConvertSurfaceAndColorspace = loader.apply("SDL_ConvertSurfaceAndColorspace");
        HANDLE$SDL_ConvertSurfaceAndColorspace = RawFunctionLoader.link(SEGMENT$SDL_ConvertSurfaceAndColorspace, Descriptors.DESCRIPTOR$SDL_ConvertSurfaceAndColorspace);
        SEGMENT$SDL_ConvertPixels = loader.apply("SDL_ConvertPixels");
        HANDLE$SDL_ConvertPixels = RawFunctionLoader.link(SEGMENT$SDL_ConvertPixels, Descriptors.DESCRIPTOR$SDL_ConvertPixels);
        SEGMENT$SDL_ConvertPixelsAndColorspace = loader.apply("SDL_ConvertPixelsAndColorspace");
        HANDLE$SDL_ConvertPixelsAndColorspace = RawFunctionLoader.link(SEGMENT$SDL_ConvertPixelsAndColorspace, Descriptors.DESCRIPTOR$SDL_ConvertPixelsAndColorspace);
        SEGMENT$SDL_PremultiplyAlpha = loader.apply("SDL_PremultiplyAlpha");
        HANDLE$SDL_PremultiplyAlpha = RawFunctionLoader.link(SEGMENT$SDL_PremultiplyAlpha, Descriptors.DESCRIPTOR$SDL_PremultiplyAlpha);
        SEGMENT$SDL_PremultiplySurfaceAlpha = loader.apply("SDL_PremultiplySurfaceAlpha");
        HANDLE$SDL_PremultiplySurfaceAlpha = RawFunctionLoader.link(SEGMENT$SDL_PremultiplySurfaceAlpha, Descriptors.DESCRIPTOR$SDL_PremultiplySurfaceAlpha);
        SEGMENT$SDL_ClearSurface = loader.apply("SDL_ClearSurface");
        HANDLE$SDL_ClearSurface = RawFunctionLoader.link(SEGMENT$SDL_ClearSurface, Descriptors.DESCRIPTOR$SDL_ClearSurface);
        SEGMENT$SDL_FillSurfaceRect = loader.apply("SDL_FillSurfaceRect");
        HANDLE$SDL_FillSurfaceRect = RawFunctionLoader.link(SEGMENT$SDL_FillSurfaceRect, Descriptors.DESCRIPTOR$SDL_FillSurfaceRect);
        SEGMENT$SDL_FillSurfaceRects = loader.apply("SDL_FillSurfaceRects");
        HANDLE$SDL_FillSurfaceRects = RawFunctionLoader.link(SEGMENT$SDL_FillSurfaceRects, Descriptors.DESCRIPTOR$SDL_FillSurfaceRects);
        SEGMENT$SDL_BlitSurface = loader.apply("SDL_BlitSurface");
        HANDLE$SDL_BlitSurface = RawFunctionLoader.link(SEGMENT$SDL_BlitSurface, Descriptors.DESCRIPTOR$SDL_BlitSurface);
        SEGMENT$SDL_BlitSurfaceUnchecked = loader.apply("SDL_BlitSurfaceUnchecked");
        HANDLE$SDL_BlitSurfaceUnchecked = RawFunctionLoader.link(SEGMENT$SDL_BlitSurfaceUnchecked, Descriptors.DESCRIPTOR$SDL_BlitSurfaceUnchecked);
        SEGMENT$SDL_BlitSurfaceScaled = loader.apply("SDL_BlitSurfaceScaled");
        HANDLE$SDL_BlitSurfaceScaled = RawFunctionLoader.link(SEGMENT$SDL_BlitSurfaceScaled, Descriptors.DESCRIPTOR$SDL_BlitSurfaceScaled);
        SEGMENT$SDL_BlitSurfaceUncheckedScaled = loader.apply("SDL_BlitSurfaceUncheckedScaled");
        HANDLE$SDL_BlitSurfaceUncheckedScaled = RawFunctionLoader.link(SEGMENT$SDL_BlitSurfaceUncheckedScaled, Descriptors.DESCRIPTOR$SDL_BlitSurfaceUncheckedScaled);
        SEGMENT$SDL_StretchSurface = loader.apply("SDL_StretchSurface");
        HANDLE$SDL_StretchSurface = RawFunctionLoader.link(SEGMENT$SDL_StretchSurface, Descriptors.DESCRIPTOR$SDL_StretchSurface);
        SEGMENT$SDL_BlitSurfaceTiled = loader.apply("SDL_BlitSurfaceTiled");
        HANDLE$SDL_BlitSurfaceTiled = RawFunctionLoader.link(SEGMENT$SDL_BlitSurfaceTiled, Descriptors.DESCRIPTOR$SDL_BlitSurfaceTiled);
        SEGMENT$SDL_BlitSurfaceTiledWithScale = loader.apply("SDL_BlitSurfaceTiledWithScale");
        HANDLE$SDL_BlitSurfaceTiledWithScale = RawFunctionLoader.link(SEGMENT$SDL_BlitSurfaceTiledWithScale, Descriptors.DESCRIPTOR$SDL_BlitSurfaceTiledWithScale);
        SEGMENT$SDL_BlitSurface9Grid = loader.apply("SDL_BlitSurface9Grid");
        HANDLE$SDL_BlitSurface9Grid = RawFunctionLoader.link(SEGMENT$SDL_BlitSurface9Grid, Descriptors.DESCRIPTOR$SDL_BlitSurface9Grid);
        SEGMENT$SDL_MapSurfaceRGB = loader.apply("SDL_MapSurfaceRGB");
        HANDLE$SDL_MapSurfaceRGB = RawFunctionLoader.link(SEGMENT$SDL_MapSurfaceRGB, Descriptors.DESCRIPTOR$SDL_MapSurfaceRGB);
        SEGMENT$SDL_MapSurfaceRGBA = loader.apply("SDL_MapSurfaceRGBA");
        HANDLE$SDL_MapSurfaceRGBA = RawFunctionLoader.link(SEGMENT$SDL_MapSurfaceRGBA, Descriptors.DESCRIPTOR$SDL_MapSurfaceRGBA);
        SEGMENT$SDL_ReadSurfacePixel = loader.apply("SDL_ReadSurfacePixel");
        HANDLE$SDL_ReadSurfacePixel = RawFunctionLoader.link(SEGMENT$SDL_ReadSurfacePixel, Descriptors.DESCRIPTOR$SDL_ReadSurfacePixel);
        SEGMENT$SDL_ReadSurfacePixelFloat = loader.apply("SDL_ReadSurfacePixelFloat");
        HANDLE$SDL_ReadSurfacePixelFloat = RawFunctionLoader.link(SEGMENT$SDL_ReadSurfacePixelFloat, Descriptors.DESCRIPTOR$SDL_ReadSurfacePixelFloat);
        SEGMENT$SDL_WriteSurfacePixel = loader.apply("SDL_WriteSurfacePixel");
        HANDLE$SDL_WriteSurfacePixel = RawFunctionLoader.link(SEGMENT$SDL_WriteSurfacePixel, Descriptors.DESCRIPTOR$SDL_WriteSurfacePixel);
        SEGMENT$SDL_WriteSurfacePixelFloat = loader.apply("SDL_WriteSurfacePixelFloat");
        HANDLE$SDL_WriteSurfacePixelFloat = RawFunctionLoader.link(SEGMENT$SDL_WriteSurfacePixelFloat, Descriptors.DESCRIPTOR$SDL_WriteSurfacePixelFloat);
        SEGMENT$SDL_SetWindowsMessageHook = loader.apply("SDL_SetWindowsMessageHook");
        HANDLE$SDL_SetWindowsMessageHook = RawFunctionLoader.link(SEGMENT$SDL_SetWindowsMessageHook, Descriptors.DESCRIPTOR$SDL_SetWindowsMessageHook);
        SEGMENT$SDL_GetDirect3D9AdapterIndex = loader.apply("SDL_GetDirect3D9AdapterIndex");
        HANDLE$SDL_GetDirect3D9AdapterIndex = RawFunctionLoader.link(SEGMENT$SDL_GetDirect3D9AdapterIndex, Descriptors.DESCRIPTOR$SDL_GetDirect3D9AdapterIndex);
        SEGMENT$SDL_GetDXGIOutputInfo = loader.apply("SDL_GetDXGIOutputInfo");
        HANDLE$SDL_GetDXGIOutputInfo = RawFunctionLoader.link(SEGMENT$SDL_GetDXGIOutputInfo, Descriptors.DESCRIPTOR$SDL_GetDXGIOutputInfo);
        SEGMENT$SDL_SetX11EventHook = loader.apply("SDL_SetX11EventHook");
        HANDLE$SDL_SetX11EventHook = RawFunctionLoader.link(SEGMENT$SDL_SetX11EventHook, Descriptors.DESCRIPTOR$SDL_SetX11EventHook);
        SEGMENT$SDL_SetLinuxThreadPriority = loader.apply("SDL_SetLinuxThreadPriority");
        HANDLE$SDL_SetLinuxThreadPriority = RawFunctionLoader.link(SEGMENT$SDL_SetLinuxThreadPriority, Descriptors.DESCRIPTOR$SDL_SetLinuxThreadPriority);
        SEGMENT$SDL_SetLinuxThreadPriorityAndPolicy = loader.apply("SDL_SetLinuxThreadPriorityAndPolicy");
        HANDLE$SDL_SetLinuxThreadPriorityAndPolicy = RawFunctionLoader.link(SEGMENT$SDL_SetLinuxThreadPriorityAndPolicy, Descriptors.DESCRIPTOR$SDL_SetLinuxThreadPriorityAndPolicy);
        SEGMENT$SDL_SetiOSAnimationCallback = loader.apply("SDL_SetiOSAnimationCallback");
        HANDLE$SDL_SetiOSAnimationCallback = RawFunctionLoader.link(SEGMENT$SDL_SetiOSAnimationCallback, Descriptors.DESCRIPTOR$SDL_SetiOSAnimationCallback);
        SEGMENT$SDL_SetiOSEventPump = loader.apply("SDL_SetiOSEventPump");
        HANDLE$SDL_SetiOSEventPump = RawFunctionLoader.link(SEGMENT$SDL_SetiOSEventPump, Descriptors.DESCRIPTOR$SDL_SetiOSEventPump);
        SEGMENT$SDL_GetAndroidJNIEnv = loader.apply("SDL_GetAndroidJNIEnv");
        HANDLE$SDL_GetAndroidJNIEnv = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidJNIEnv, Descriptors.DESCRIPTOR$SDL_GetAndroidJNIEnv);
        SEGMENT$SDL_GetAndroidActivity = loader.apply("SDL_GetAndroidActivity");
        HANDLE$SDL_GetAndroidActivity = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidActivity, Descriptors.DESCRIPTOR$SDL_GetAndroidActivity);
        SEGMENT$SDL_GetAndroidSDKVersion = loader.apply("SDL_GetAndroidSDKVersion");
        HANDLE$SDL_GetAndroidSDKVersion = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidSDKVersion, Descriptors.DESCRIPTOR$SDL_GetAndroidSDKVersion);
        SEGMENT$SDL_IsChromebook = loader.apply("SDL_IsChromebook");
        HANDLE$SDL_IsChromebook = RawFunctionLoader.link(SEGMENT$SDL_IsChromebook, Descriptors.DESCRIPTOR$SDL_IsChromebook);
        SEGMENT$SDL_IsDeXMode = loader.apply("SDL_IsDeXMode");
        HANDLE$SDL_IsDeXMode = RawFunctionLoader.link(SEGMENT$SDL_IsDeXMode, Descriptors.DESCRIPTOR$SDL_IsDeXMode);
        SEGMENT$SDL_SendAndroidBackButton = loader.apply("SDL_SendAndroidBackButton");
        HANDLE$SDL_SendAndroidBackButton = RawFunctionLoader.link(SEGMENT$SDL_SendAndroidBackButton, Descriptors.DESCRIPTOR$SDL_SendAndroidBackButton);
        SEGMENT$SDL_GetAndroidInternalStoragePath = loader.apply("SDL_GetAndroidInternalStoragePath");
        HANDLE$SDL_GetAndroidInternalStoragePath = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidInternalStoragePath, Descriptors.DESCRIPTOR$SDL_GetAndroidInternalStoragePath);
        SEGMENT$SDL_GetAndroidExternalStorageState = loader.apply("SDL_GetAndroidExternalStorageState");
        HANDLE$SDL_GetAndroidExternalStorageState = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidExternalStorageState, Descriptors.DESCRIPTOR$SDL_GetAndroidExternalStorageState);
        SEGMENT$SDL_GetAndroidExternalStoragePath = loader.apply("SDL_GetAndroidExternalStoragePath");
        HANDLE$SDL_GetAndroidExternalStoragePath = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidExternalStoragePath, Descriptors.DESCRIPTOR$SDL_GetAndroidExternalStoragePath);
        SEGMENT$SDL_GetAndroidCachePath = loader.apply("SDL_GetAndroidCachePath");
        HANDLE$SDL_GetAndroidCachePath = RawFunctionLoader.link(SEGMENT$SDL_GetAndroidCachePath, Descriptors.DESCRIPTOR$SDL_GetAndroidCachePath);
        SEGMENT$SDL_RequestAndroidPermission = loader.apply("SDL_RequestAndroidPermission");
        HANDLE$SDL_RequestAndroidPermission = RawFunctionLoader.link(SEGMENT$SDL_RequestAndroidPermission, Descriptors.DESCRIPTOR$SDL_RequestAndroidPermission);
        SEGMENT$SDL_ShowAndroidToast = loader.apply("SDL_ShowAndroidToast");
        HANDLE$SDL_ShowAndroidToast = RawFunctionLoader.link(SEGMENT$SDL_ShowAndroidToast, Descriptors.DESCRIPTOR$SDL_ShowAndroidToast);
        SEGMENT$SDL_SendAndroidMessage = loader.apply("SDL_SendAndroidMessage");
        HANDLE$SDL_SendAndroidMessage = RawFunctionLoader.link(SEGMENT$SDL_SendAndroidMessage, Descriptors.DESCRIPTOR$SDL_SendAndroidMessage);
        SEGMENT$SDL_IsTablet = loader.apply("SDL_IsTablet");
        HANDLE$SDL_IsTablet = RawFunctionLoader.link(SEGMENT$SDL_IsTablet, Descriptors.DESCRIPTOR$SDL_IsTablet);
        SEGMENT$SDL_IsTV = loader.apply("SDL_IsTV");
        HANDLE$SDL_IsTV = RawFunctionLoader.link(SEGMENT$SDL_IsTV, Descriptors.DESCRIPTOR$SDL_IsTV);
        SEGMENT$SDL_GetSandbox = loader.apply("SDL_GetSandbox");
        HANDLE$SDL_GetSandbox = RawFunctionLoader.link(SEGMENT$SDL_GetSandbox, Descriptors.DESCRIPTOR$SDL_GetSandbox);
        SEGMENT$SDL_OnApplicationWillTerminate = loader.apply("SDL_OnApplicationWillTerminate");
        HANDLE$SDL_OnApplicationWillTerminate = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationWillTerminate, Descriptors.DESCRIPTOR$SDL_OnApplicationWillTerminate);
        SEGMENT$SDL_OnApplicationDidReceiveMemoryWarning = loader.apply("SDL_OnApplicationDidReceiveMemoryWarning");
        HANDLE$SDL_OnApplicationDidReceiveMemoryWarning = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationDidReceiveMemoryWarning, Descriptors.DESCRIPTOR$SDL_OnApplicationDidReceiveMemoryWarning);
        SEGMENT$SDL_OnApplicationWillEnterBackground = loader.apply("SDL_OnApplicationWillEnterBackground");
        HANDLE$SDL_OnApplicationWillEnterBackground = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationWillEnterBackground, Descriptors.DESCRIPTOR$SDL_OnApplicationWillEnterBackground);
        SEGMENT$SDL_OnApplicationDidEnterBackground = loader.apply("SDL_OnApplicationDidEnterBackground");
        HANDLE$SDL_OnApplicationDidEnterBackground = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationDidEnterBackground, Descriptors.DESCRIPTOR$SDL_OnApplicationDidEnterBackground);
        SEGMENT$SDL_OnApplicationWillEnterForeground = loader.apply("SDL_OnApplicationWillEnterForeground");
        HANDLE$SDL_OnApplicationWillEnterForeground = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationWillEnterForeground, Descriptors.DESCRIPTOR$SDL_OnApplicationWillEnterForeground);
        SEGMENT$SDL_OnApplicationDidEnterForeground = loader.apply("SDL_OnApplicationDidEnterForeground");
        HANDLE$SDL_OnApplicationDidEnterForeground = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationDidEnterForeground, Descriptors.DESCRIPTOR$SDL_OnApplicationDidEnterForeground);
        SEGMENT$SDL_OnApplicationDidChangeStatusBarOrientation = loader.apply("SDL_OnApplicationDidChangeStatusBarOrientation");
        HANDLE$SDL_OnApplicationDidChangeStatusBarOrientation = RawFunctionLoader.link(SEGMENT$SDL_OnApplicationDidChangeStatusBarOrientation, Descriptors.DESCRIPTOR$SDL_OnApplicationDidChangeStatusBarOrientation);
        SEGMENT$SDL_GetGDKTaskQueue = loader.apply("SDL_GetGDKTaskQueue");
        HANDLE$SDL_GetGDKTaskQueue = RawFunctionLoader.link(SEGMENT$SDL_GetGDKTaskQueue, Descriptors.DESCRIPTOR$SDL_GetGDKTaskQueue);
        SEGMENT$SDL_GetGDKDefaultUser = loader.apply("SDL_GetGDKDefaultUser");
        HANDLE$SDL_GetGDKDefaultUser = RawFunctionLoader.link(SEGMENT$SDL_GetGDKDefaultUser, Descriptors.DESCRIPTOR$SDL_GetGDKDefaultUser);
        SEGMENT$SDL_CreateThread = loader.apply("SDL_CreateThread");
        HANDLE$SDL_CreateThread = RawFunctionLoader.link(SEGMENT$SDL_CreateThread, Descriptors.DESCRIPTOR$SDL_CreateThread);
        SEGMENT$SDL_CreateThreadWithProperties = loader.apply("SDL_CreateThreadWithProperties");
        HANDLE$SDL_CreateThreadWithProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateThreadWithProperties, Descriptors.DESCRIPTOR$SDL_CreateThreadWithProperties);
        SEGMENT$SDL_CreateThreadRuntime = loader.apply("SDL_CreateThreadRuntime");
        HANDLE$SDL_CreateThreadRuntime = RawFunctionLoader.link(SEGMENT$SDL_CreateThreadRuntime, Descriptors.DESCRIPTOR$SDL_CreateThreadRuntime);
        SEGMENT$SDL_CreateThreadWithPropertiesRuntime = loader.apply("SDL_CreateThreadWithPropertiesRuntime");
        HANDLE$SDL_CreateThreadWithPropertiesRuntime = RawFunctionLoader.link(SEGMENT$SDL_CreateThreadWithPropertiesRuntime, Descriptors.DESCRIPTOR$SDL_CreateThreadWithPropertiesRuntime);
        SEGMENT$SDL_GetThreadName = loader.apply("SDL_GetThreadName");
        HANDLE$SDL_GetThreadName = RawFunctionLoader.link(SEGMENT$SDL_GetThreadName, Descriptors.DESCRIPTOR$SDL_GetThreadName);
        SEGMENT$SDL_GetCurrentThreadID = loader.apply("SDL_GetCurrentThreadID");
        HANDLE$SDL_GetCurrentThreadID = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentThreadID, Descriptors.DESCRIPTOR$SDL_GetCurrentThreadID);
        SEGMENT$SDL_GetThreadID = loader.apply("SDL_GetThreadID");
        HANDLE$SDL_GetThreadID = RawFunctionLoader.link(SEGMENT$SDL_GetThreadID, Descriptors.DESCRIPTOR$SDL_GetThreadID);
        SEGMENT$SDL_SetCurrentThreadPriority = loader.apply("SDL_SetCurrentThreadPriority");
        HANDLE$SDL_SetCurrentThreadPriority = RawFunctionLoader.link(SEGMENT$SDL_SetCurrentThreadPriority, Descriptors.DESCRIPTOR$SDL_SetCurrentThreadPriority);
        SEGMENT$SDL_WaitThread = loader.apply("SDL_WaitThread");
        HANDLE$SDL_WaitThread = RawFunctionLoader.link(SEGMENT$SDL_WaitThread, Descriptors.DESCRIPTOR$SDL_WaitThread);
        SEGMENT$SDL_GetThreadState = loader.apply("SDL_GetThreadState");
        HANDLE$SDL_GetThreadState = RawFunctionLoader.link(SEGMENT$SDL_GetThreadState, Descriptors.DESCRIPTOR$SDL_GetThreadState);
        SEGMENT$SDL_DetachThread = loader.apply("SDL_DetachThread");
        HANDLE$SDL_DetachThread = RawFunctionLoader.link(SEGMENT$SDL_DetachThread, Descriptors.DESCRIPTOR$SDL_DetachThread);
        SEGMENT$SDL_GetTLS = loader.apply("SDL_GetTLS");
        HANDLE$SDL_GetTLS = RawFunctionLoader.link(SEGMENT$SDL_GetTLS, Descriptors.DESCRIPTOR$SDL_GetTLS);
        SEGMENT$SDL_SetTLS = loader.apply("SDL_SetTLS");
        HANDLE$SDL_SetTLS = RawFunctionLoader.link(SEGMENT$SDL_SetTLS, Descriptors.DESCRIPTOR$SDL_SetTLS);
        SEGMENT$SDL_CleanupTLS = loader.apply("SDL_CleanupTLS");
        HANDLE$SDL_CleanupTLS = RawFunctionLoader.link(SEGMENT$SDL_CleanupTLS, Descriptors.DESCRIPTOR$SDL_CleanupTLS);
        SEGMENT$SDL_GetDateTimeLocalePreferences = loader.apply("SDL_GetDateTimeLocalePreferences");
        HANDLE$SDL_GetDateTimeLocalePreferences = RawFunctionLoader.link(SEGMENT$SDL_GetDateTimeLocalePreferences, Descriptors.DESCRIPTOR$SDL_GetDateTimeLocalePreferences);
        SEGMENT$SDL_GetCurrentTime = loader.apply("SDL_GetCurrentTime");
        HANDLE$SDL_GetCurrentTime = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentTime, Descriptors.DESCRIPTOR$SDL_GetCurrentTime);
        SEGMENT$SDL_TimeToDateTime = loader.apply("SDL_TimeToDateTime");
        HANDLE$SDL_TimeToDateTime = RawFunctionLoader.link(SEGMENT$SDL_TimeToDateTime, Descriptors.DESCRIPTOR$SDL_TimeToDateTime);
        SEGMENT$SDL_DateTimeToTime = loader.apply("SDL_DateTimeToTime");
        HANDLE$SDL_DateTimeToTime = RawFunctionLoader.link(SEGMENT$SDL_DateTimeToTime, Descriptors.DESCRIPTOR$SDL_DateTimeToTime);
        SEGMENT$SDL_TimeToWindows = loader.apply("SDL_TimeToWindows");
        HANDLE$SDL_TimeToWindows = RawFunctionLoader.link(SEGMENT$SDL_TimeToWindows, Descriptors.DESCRIPTOR$SDL_TimeToWindows);
        SEGMENT$SDL_TimeFromWindows = loader.apply("SDL_TimeFromWindows");
        HANDLE$SDL_TimeFromWindows = RawFunctionLoader.link(SEGMENT$SDL_TimeFromWindows, Descriptors.DESCRIPTOR$SDL_TimeFromWindows);
        SEGMENT$SDL_GetDaysInMonth = loader.apply("SDL_GetDaysInMonth");
        HANDLE$SDL_GetDaysInMonth = RawFunctionLoader.link(SEGMENT$SDL_GetDaysInMonth, Descriptors.DESCRIPTOR$SDL_GetDaysInMonth);
        SEGMENT$SDL_GetDayOfYear = loader.apply("SDL_GetDayOfYear");
        HANDLE$SDL_GetDayOfYear = RawFunctionLoader.link(SEGMENT$SDL_GetDayOfYear, Descriptors.DESCRIPTOR$SDL_GetDayOfYear);
        SEGMENT$SDL_GetDayOfWeek = loader.apply("SDL_GetDayOfWeek");
        HANDLE$SDL_GetDayOfWeek = RawFunctionLoader.link(SEGMENT$SDL_GetDayOfWeek, Descriptors.DESCRIPTOR$SDL_GetDayOfWeek);
        SEGMENT$SDL_GetTicks = loader.apply("SDL_GetTicks");
        HANDLE$SDL_GetTicks = RawFunctionLoader.link(SEGMENT$SDL_GetTicks, Descriptors.DESCRIPTOR$SDL_GetTicks);
        SEGMENT$SDL_GetTicksNS = loader.apply("SDL_GetTicksNS");
        HANDLE$SDL_GetTicksNS = RawFunctionLoader.link(SEGMENT$SDL_GetTicksNS, Descriptors.DESCRIPTOR$SDL_GetTicksNS);
        SEGMENT$SDL_GetPerformanceCounter = loader.apply("SDL_GetPerformanceCounter");
        HANDLE$SDL_GetPerformanceCounter = RawFunctionLoader.link(SEGMENT$SDL_GetPerformanceCounter, Descriptors.DESCRIPTOR$SDL_GetPerformanceCounter);
        SEGMENT$SDL_GetPerformanceFrequency = loader.apply("SDL_GetPerformanceFrequency");
        HANDLE$SDL_GetPerformanceFrequency = RawFunctionLoader.link(SEGMENT$SDL_GetPerformanceFrequency, Descriptors.DESCRIPTOR$SDL_GetPerformanceFrequency);
        SEGMENT$SDL_Delay = loader.apply("SDL_Delay");
        HANDLE$SDL_Delay = RawFunctionLoader.link(SEGMENT$SDL_Delay, Descriptors.DESCRIPTOR$SDL_Delay);
        SEGMENT$SDL_DelayNS = loader.apply("SDL_DelayNS");
        HANDLE$SDL_DelayNS = RawFunctionLoader.link(SEGMENT$SDL_DelayNS, Descriptors.DESCRIPTOR$SDL_DelayNS);
        SEGMENT$SDL_DelayPrecise = loader.apply("SDL_DelayPrecise");
        HANDLE$SDL_DelayPrecise = RawFunctionLoader.link(SEGMENT$SDL_DelayPrecise, Descriptors.DESCRIPTOR$SDL_DelayPrecise);
        SEGMENT$SDL_AddTimer = loader.apply("SDL_AddTimer");
        HANDLE$SDL_AddTimer = RawFunctionLoader.link(SEGMENT$SDL_AddTimer, Descriptors.DESCRIPTOR$SDL_AddTimer);
        SEGMENT$SDL_AddTimerNS = loader.apply("SDL_AddTimerNS");
        HANDLE$SDL_AddTimerNS = RawFunctionLoader.link(SEGMENT$SDL_AddTimerNS, Descriptors.DESCRIPTOR$SDL_AddTimerNS);
        SEGMENT$SDL_RemoveTimer = loader.apply("SDL_RemoveTimer");
        HANDLE$SDL_RemoveTimer = RawFunctionLoader.link(SEGMENT$SDL_RemoveTimer, Descriptors.DESCRIPTOR$SDL_RemoveTimer);
        SEGMENT$SDL_CreateTray = loader.apply("SDL_CreateTray");
        HANDLE$SDL_CreateTray = RawFunctionLoader.link(SEGMENT$SDL_CreateTray, Descriptors.DESCRIPTOR$SDL_CreateTray);
        SEGMENT$SDL_SetTrayIcon = loader.apply("SDL_SetTrayIcon");
        HANDLE$SDL_SetTrayIcon = RawFunctionLoader.link(SEGMENT$SDL_SetTrayIcon, Descriptors.DESCRIPTOR$SDL_SetTrayIcon);
        SEGMENT$SDL_SetTrayTooltip = loader.apply("SDL_SetTrayTooltip");
        HANDLE$SDL_SetTrayTooltip = RawFunctionLoader.link(SEGMENT$SDL_SetTrayTooltip, Descriptors.DESCRIPTOR$SDL_SetTrayTooltip);
        SEGMENT$SDL_CreateTrayMenu = loader.apply("SDL_CreateTrayMenu");
        HANDLE$SDL_CreateTrayMenu = RawFunctionLoader.link(SEGMENT$SDL_CreateTrayMenu, Descriptors.DESCRIPTOR$SDL_CreateTrayMenu);
        SEGMENT$SDL_CreateTraySubmenu = loader.apply("SDL_CreateTraySubmenu");
        HANDLE$SDL_CreateTraySubmenu = RawFunctionLoader.link(SEGMENT$SDL_CreateTraySubmenu, Descriptors.DESCRIPTOR$SDL_CreateTraySubmenu);
        SEGMENT$SDL_GetTrayMenu = loader.apply("SDL_GetTrayMenu");
        HANDLE$SDL_GetTrayMenu = RawFunctionLoader.link(SEGMENT$SDL_GetTrayMenu, Descriptors.DESCRIPTOR$SDL_GetTrayMenu);
        SEGMENT$SDL_GetTraySubmenu = loader.apply("SDL_GetTraySubmenu");
        HANDLE$SDL_GetTraySubmenu = RawFunctionLoader.link(SEGMENT$SDL_GetTraySubmenu, Descriptors.DESCRIPTOR$SDL_GetTraySubmenu);
        SEGMENT$SDL_GetTrayEntries = loader.apply("SDL_GetTrayEntries");
        HANDLE$SDL_GetTrayEntries = RawFunctionLoader.link(SEGMENT$SDL_GetTrayEntries, Descriptors.DESCRIPTOR$SDL_GetTrayEntries);
        SEGMENT$SDL_RemoveTrayEntry = loader.apply("SDL_RemoveTrayEntry");
        HANDLE$SDL_RemoveTrayEntry = RawFunctionLoader.link(SEGMENT$SDL_RemoveTrayEntry, Descriptors.DESCRIPTOR$SDL_RemoveTrayEntry);
        SEGMENT$SDL_InsertTrayEntryAt = loader.apply("SDL_InsertTrayEntryAt");
        HANDLE$SDL_InsertTrayEntryAt = RawFunctionLoader.link(SEGMENT$SDL_InsertTrayEntryAt, Descriptors.DESCRIPTOR$SDL_InsertTrayEntryAt);
        SEGMENT$SDL_SetTrayEntryLabel = loader.apply("SDL_SetTrayEntryLabel");
        HANDLE$SDL_SetTrayEntryLabel = RawFunctionLoader.link(SEGMENT$SDL_SetTrayEntryLabel, Descriptors.DESCRIPTOR$SDL_SetTrayEntryLabel);
        SEGMENT$SDL_GetTrayEntryLabel = loader.apply("SDL_GetTrayEntryLabel");
        HANDLE$SDL_GetTrayEntryLabel = RawFunctionLoader.link(SEGMENT$SDL_GetTrayEntryLabel, Descriptors.DESCRIPTOR$SDL_GetTrayEntryLabel);
        SEGMENT$SDL_SetTrayEntryChecked = loader.apply("SDL_SetTrayEntryChecked");
        HANDLE$SDL_SetTrayEntryChecked = RawFunctionLoader.link(SEGMENT$SDL_SetTrayEntryChecked, Descriptors.DESCRIPTOR$SDL_SetTrayEntryChecked);
        SEGMENT$SDL_GetTrayEntryChecked = loader.apply("SDL_GetTrayEntryChecked");
        HANDLE$SDL_GetTrayEntryChecked = RawFunctionLoader.link(SEGMENT$SDL_GetTrayEntryChecked, Descriptors.DESCRIPTOR$SDL_GetTrayEntryChecked);
        SEGMENT$SDL_SetTrayEntryEnabled = loader.apply("SDL_SetTrayEntryEnabled");
        HANDLE$SDL_SetTrayEntryEnabled = RawFunctionLoader.link(SEGMENT$SDL_SetTrayEntryEnabled, Descriptors.DESCRIPTOR$SDL_SetTrayEntryEnabled);
        SEGMENT$SDL_GetTrayEntryEnabled = loader.apply("SDL_GetTrayEntryEnabled");
        HANDLE$SDL_GetTrayEntryEnabled = RawFunctionLoader.link(SEGMENT$SDL_GetTrayEntryEnabled, Descriptors.DESCRIPTOR$SDL_GetTrayEntryEnabled);
        SEGMENT$SDL_SetTrayEntryCallback = loader.apply("SDL_SetTrayEntryCallback");
        HANDLE$SDL_SetTrayEntryCallback = RawFunctionLoader.link(SEGMENT$SDL_SetTrayEntryCallback, Descriptors.DESCRIPTOR$SDL_SetTrayEntryCallback);
        SEGMENT$SDL_ClickTrayEntry = loader.apply("SDL_ClickTrayEntry");
        HANDLE$SDL_ClickTrayEntry = RawFunctionLoader.link(SEGMENT$SDL_ClickTrayEntry, Descriptors.DESCRIPTOR$SDL_ClickTrayEntry);
        SEGMENT$SDL_DestroyTray = loader.apply("SDL_DestroyTray");
        HANDLE$SDL_DestroyTray = RawFunctionLoader.link(SEGMENT$SDL_DestroyTray, Descriptors.DESCRIPTOR$SDL_DestroyTray);
        SEGMENT$SDL_GetTrayEntryParent = loader.apply("SDL_GetTrayEntryParent");
        HANDLE$SDL_GetTrayEntryParent = RawFunctionLoader.link(SEGMENT$SDL_GetTrayEntryParent, Descriptors.DESCRIPTOR$SDL_GetTrayEntryParent);
        SEGMENT$SDL_GetTrayMenuParentEntry = loader.apply("SDL_GetTrayMenuParentEntry");
        HANDLE$SDL_GetTrayMenuParentEntry = RawFunctionLoader.link(SEGMENT$SDL_GetTrayMenuParentEntry, Descriptors.DESCRIPTOR$SDL_GetTrayMenuParentEntry);
        SEGMENT$SDL_GetTrayMenuParentTray = loader.apply("SDL_GetTrayMenuParentTray");
        HANDLE$SDL_GetTrayMenuParentTray = RawFunctionLoader.link(SEGMENT$SDL_GetTrayMenuParentTray, Descriptors.DESCRIPTOR$SDL_GetTrayMenuParentTray);
        SEGMENT$SDL_UpdateTrays = loader.apply("SDL_UpdateTrays");
        HANDLE$SDL_UpdateTrays = RawFunctionLoader.link(SEGMENT$SDL_UpdateTrays, Descriptors.DESCRIPTOR$SDL_UpdateTrays);
        SEGMENT$SDL_GetTouchDevices = loader.apply("SDL_GetTouchDevices");
        HANDLE$SDL_GetTouchDevices = RawFunctionLoader.link(SEGMENT$SDL_GetTouchDevices, Descriptors.DESCRIPTOR$SDL_GetTouchDevices);
        SEGMENT$SDL_GetTouchDeviceName = loader.apply("SDL_GetTouchDeviceName");
        HANDLE$SDL_GetTouchDeviceName = RawFunctionLoader.link(SEGMENT$SDL_GetTouchDeviceName, Descriptors.DESCRIPTOR$SDL_GetTouchDeviceName);
        SEGMENT$SDL_GetTouchDeviceType = loader.apply("SDL_GetTouchDeviceType");
        HANDLE$SDL_GetTouchDeviceType = RawFunctionLoader.link(SEGMENT$SDL_GetTouchDeviceType, Descriptors.DESCRIPTOR$SDL_GetTouchDeviceType);
        SEGMENT$SDL_GetTouchFingers = loader.apply("SDL_GetTouchFingers");
        HANDLE$SDL_GetTouchFingers = RawFunctionLoader.link(SEGMENT$SDL_GetTouchFingers, Descriptors.DESCRIPTOR$SDL_GetTouchFingers);
        SEGMENT$SDL_GetVersion = loader.apply("SDL_GetVersion");
        HANDLE$SDL_GetVersion = RawFunctionLoader.link(SEGMENT$SDL_GetVersion, Descriptors.DESCRIPTOR$SDL_GetVersion);
        SEGMENT$SDL_GetRevision = loader.apply("SDL_GetRevision");
        HANDLE$SDL_GetRevision = RawFunctionLoader.link(SEGMENT$SDL_GetRevision, Descriptors.DESCRIPTOR$SDL_GetRevision);
        SEGMENT$SDL_GetNumVideoDrivers = loader.apply("SDL_GetNumVideoDrivers");
        HANDLE$SDL_GetNumVideoDrivers = RawFunctionLoader.link(SEGMENT$SDL_GetNumVideoDrivers, Descriptors.DESCRIPTOR$SDL_GetNumVideoDrivers);
        SEGMENT$SDL_GetVideoDriver = loader.apply("SDL_GetVideoDriver");
        HANDLE$SDL_GetVideoDriver = RawFunctionLoader.link(SEGMENT$SDL_GetVideoDriver, Descriptors.DESCRIPTOR$SDL_GetVideoDriver);
        SEGMENT$SDL_GetCurrentVideoDriver = loader.apply("SDL_GetCurrentVideoDriver");
        HANDLE$SDL_GetCurrentVideoDriver = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentVideoDriver, Descriptors.DESCRIPTOR$SDL_GetCurrentVideoDriver);
        SEGMENT$SDL_GetSystemTheme = loader.apply("SDL_GetSystemTheme");
        HANDLE$SDL_GetSystemTheme = RawFunctionLoader.link(SEGMENT$SDL_GetSystemTheme, Descriptors.DESCRIPTOR$SDL_GetSystemTheme);
        SEGMENT$SDL_GetDisplays = loader.apply("SDL_GetDisplays");
        HANDLE$SDL_GetDisplays = RawFunctionLoader.link(SEGMENT$SDL_GetDisplays, Descriptors.DESCRIPTOR$SDL_GetDisplays);
        SEGMENT$SDL_GetPrimaryDisplay = loader.apply("SDL_GetPrimaryDisplay");
        HANDLE$SDL_GetPrimaryDisplay = RawFunctionLoader.link(SEGMENT$SDL_GetPrimaryDisplay, Descriptors.DESCRIPTOR$SDL_GetPrimaryDisplay);
        SEGMENT$SDL_GetDisplayProperties = loader.apply("SDL_GetDisplayProperties");
        HANDLE$SDL_GetDisplayProperties = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayProperties, Descriptors.DESCRIPTOR$SDL_GetDisplayProperties);
        SEGMENT$SDL_GetDisplayName = loader.apply("SDL_GetDisplayName");
        HANDLE$SDL_GetDisplayName = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayName, Descriptors.DESCRIPTOR$SDL_GetDisplayName);
        SEGMENT$SDL_GetDisplayBounds = loader.apply("SDL_GetDisplayBounds");
        HANDLE$SDL_GetDisplayBounds = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayBounds, Descriptors.DESCRIPTOR$SDL_GetDisplayBounds);
        SEGMENT$SDL_GetDisplayUsableBounds = loader.apply("SDL_GetDisplayUsableBounds");
        HANDLE$SDL_GetDisplayUsableBounds = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayUsableBounds, Descriptors.DESCRIPTOR$SDL_GetDisplayUsableBounds);
        SEGMENT$SDL_GetNaturalDisplayOrientation = loader.apply("SDL_GetNaturalDisplayOrientation");
        HANDLE$SDL_GetNaturalDisplayOrientation = RawFunctionLoader.link(SEGMENT$SDL_GetNaturalDisplayOrientation, Descriptors.DESCRIPTOR$SDL_GetNaturalDisplayOrientation);
        SEGMENT$SDL_GetCurrentDisplayOrientation = loader.apply("SDL_GetCurrentDisplayOrientation");
        HANDLE$SDL_GetCurrentDisplayOrientation = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentDisplayOrientation, Descriptors.DESCRIPTOR$SDL_GetCurrentDisplayOrientation);
        SEGMENT$SDL_GetDisplayContentScale = loader.apply("SDL_GetDisplayContentScale");
        HANDLE$SDL_GetDisplayContentScale = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayContentScale, Descriptors.DESCRIPTOR$SDL_GetDisplayContentScale);
        SEGMENT$SDL_GetFullscreenDisplayModes = loader.apply("SDL_GetFullscreenDisplayModes");
        HANDLE$SDL_GetFullscreenDisplayModes = RawFunctionLoader.link(SEGMENT$SDL_GetFullscreenDisplayModes, Descriptors.DESCRIPTOR$SDL_GetFullscreenDisplayModes);
        SEGMENT$SDL_GetClosestFullscreenDisplayMode = loader.apply("SDL_GetClosestFullscreenDisplayMode");
        HANDLE$SDL_GetClosestFullscreenDisplayMode = RawFunctionLoader.link(SEGMENT$SDL_GetClosestFullscreenDisplayMode, Descriptors.DESCRIPTOR$SDL_GetClosestFullscreenDisplayMode);
        SEGMENT$SDL_GetDesktopDisplayMode = loader.apply("SDL_GetDesktopDisplayMode");
        HANDLE$SDL_GetDesktopDisplayMode = RawFunctionLoader.link(SEGMENT$SDL_GetDesktopDisplayMode, Descriptors.DESCRIPTOR$SDL_GetDesktopDisplayMode);
        SEGMENT$SDL_GetCurrentDisplayMode = loader.apply("SDL_GetCurrentDisplayMode");
        HANDLE$SDL_GetCurrentDisplayMode = RawFunctionLoader.link(SEGMENT$SDL_GetCurrentDisplayMode, Descriptors.DESCRIPTOR$SDL_GetCurrentDisplayMode);
        SEGMENT$SDL_GetDisplayForPoint = loader.apply("SDL_GetDisplayForPoint");
        HANDLE$SDL_GetDisplayForPoint = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayForPoint, Descriptors.DESCRIPTOR$SDL_GetDisplayForPoint);
        SEGMENT$SDL_GetDisplayForRect = loader.apply("SDL_GetDisplayForRect");
        HANDLE$SDL_GetDisplayForRect = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayForRect, Descriptors.DESCRIPTOR$SDL_GetDisplayForRect);
        SEGMENT$SDL_GetDisplayForWindow = loader.apply("SDL_GetDisplayForWindow");
        HANDLE$SDL_GetDisplayForWindow = RawFunctionLoader.link(SEGMENT$SDL_GetDisplayForWindow, Descriptors.DESCRIPTOR$SDL_GetDisplayForWindow);
        SEGMENT$SDL_GetWindowPixelDensity = loader.apply("SDL_GetWindowPixelDensity");
        HANDLE$SDL_GetWindowPixelDensity = RawFunctionLoader.link(SEGMENT$SDL_GetWindowPixelDensity, Descriptors.DESCRIPTOR$SDL_GetWindowPixelDensity);
        SEGMENT$SDL_GetWindowDisplayScale = loader.apply("SDL_GetWindowDisplayScale");
        HANDLE$SDL_GetWindowDisplayScale = RawFunctionLoader.link(SEGMENT$SDL_GetWindowDisplayScale, Descriptors.DESCRIPTOR$SDL_GetWindowDisplayScale);
        SEGMENT$SDL_SetWindowFullscreenMode = loader.apply("SDL_SetWindowFullscreenMode");
        HANDLE$SDL_SetWindowFullscreenMode = RawFunctionLoader.link(SEGMENT$SDL_SetWindowFullscreenMode, Descriptors.DESCRIPTOR$SDL_SetWindowFullscreenMode);
        SEGMENT$SDL_GetWindowFullscreenMode = loader.apply("SDL_GetWindowFullscreenMode");
        HANDLE$SDL_GetWindowFullscreenMode = RawFunctionLoader.link(SEGMENT$SDL_GetWindowFullscreenMode, Descriptors.DESCRIPTOR$SDL_GetWindowFullscreenMode);
        SEGMENT$SDL_GetWindowICCProfile = loader.apply("SDL_GetWindowICCProfile");
        HANDLE$SDL_GetWindowICCProfile = RawFunctionLoader.link(SEGMENT$SDL_GetWindowICCProfile, Descriptors.DESCRIPTOR$SDL_GetWindowICCProfile);
        SEGMENT$SDL_GetWindowPixelFormat = loader.apply("SDL_GetWindowPixelFormat");
        HANDLE$SDL_GetWindowPixelFormat = RawFunctionLoader.link(SEGMENT$SDL_GetWindowPixelFormat, Descriptors.DESCRIPTOR$SDL_GetWindowPixelFormat);
        SEGMENT$SDL_GetWindows = loader.apply("SDL_GetWindows");
        HANDLE$SDL_GetWindows = RawFunctionLoader.link(SEGMENT$SDL_GetWindows, Descriptors.DESCRIPTOR$SDL_GetWindows);
        SEGMENT$SDL_CreateWindow = loader.apply("SDL_CreateWindow");
        HANDLE$SDL_CreateWindow = RawFunctionLoader.link(SEGMENT$SDL_CreateWindow, Descriptors.DESCRIPTOR$SDL_CreateWindow);
        SEGMENT$SDL_CreatePopupWindow = loader.apply("SDL_CreatePopupWindow");
        HANDLE$SDL_CreatePopupWindow = RawFunctionLoader.link(SEGMENT$SDL_CreatePopupWindow, Descriptors.DESCRIPTOR$SDL_CreatePopupWindow);
        SEGMENT$SDL_CreateWindowWithProperties = loader.apply("SDL_CreateWindowWithProperties");
        HANDLE$SDL_CreateWindowWithProperties = RawFunctionLoader.link(SEGMENT$SDL_CreateWindowWithProperties, Descriptors.DESCRIPTOR$SDL_CreateWindowWithProperties);
        SEGMENT$SDL_GetWindowID = loader.apply("SDL_GetWindowID");
        HANDLE$SDL_GetWindowID = RawFunctionLoader.link(SEGMENT$SDL_GetWindowID, Descriptors.DESCRIPTOR$SDL_GetWindowID);
        SEGMENT$SDL_GetWindowFromID = loader.apply("SDL_GetWindowFromID");
        HANDLE$SDL_GetWindowFromID = RawFunctionLoader.link(SEGMENT$SDL_GetWindowFromID, Descriptors.DESCRIPTOR$SDL_GetWindowFromID);
        SEGMENT$SDL_GetWindowParent = loader.apply("SDL_GetWindowParent");
        HANDLE$SDL_GetWindowParent = RawFunctionLoader.link(SEGMENT$SDL_GetWindowParent, Descriptors.DESCRIPTOR$SDL_GetWindowParent);
        SEGMENT$SDL_GetWindowProperties = loader.apply("SDL_GetWindowProperties");
        HANDLE$SDL_GetWindowProperties = RawFunctionLoader.link(SEGMENT$SDL_GetWindowProperties, Descriptors.DESCRIPTOR$SDL_GetWindowProperties);
        SEGMENT$SDL_GetWindowFlags = loader.apply("SDL_GetWindowFlags");
        HANDLE$SDL_GetWindowFlags = RawFunctionLoader.link(SEGMENT$SDL_GetWindowFlags, Descriptors.DESCRIPTOR$SDL_GetWindowFlags);
        SEGMENT$SDL_SetWindowTitle = loader.apply("SDL_SetWindowTitle");
        HANDLE$SDL_SetWindowTitle = RawFunctionLoader.link(SEGMENT$SDL_SetWindowTitle, Descriptors.DESCRIPTOR$SDL_SetWindowTitle);
        SEGMENT$SDL_GetWindowTitle = loader.apply("SDL_GetWindowTitle");
        HANDLE$SDL_GetWindowTitle = RawFunctionLoader.link(SEGMENT$SDL_GetWindowTitle, Descriptors.DESCRIPTOR$SDL_GetWindowTitle);
        SEGMENT$SDL_SetWindowIcon = loader.apply("SDL_SetWindowIcon");
        HANDLE$SDL_SetWindowIcon = RawFunctionLoader.link(SEGMENT$SDL_SetWindowIcon, Descriptors.DESCRIPTOR$SDL_SetWindowIcon);
        SEGMENT$SDL_SetWindowPosition = loader.apply("SDL_SetWindowPosition");
        HANDLE$SDL_SetWindowPosition = RawFunctionLoader.link(SEGMENT$SDL_SetWindowPosition, Descriptors.DESCRIPTOR$SDL_SetWindowPosition);
        SEGMENT$SDL_GetWindowPosition = loader.apply("SDL_GetWindowPosition");
        HANDLE$SDL_GetWindowPosition = RawFunctionLoader.link(SEGMENT$SDL_GetWindowPosition, Descriptors.DESCRIPTOR$SDL_GetWindowPosition);
        SEGMENT$SDL_SetWindowSize = loader.apply("SDL_SetWindowSize");
        HANDLE$SDL_SetWindowSize = RawFunctionLoader.link(SEGMENT$SDL_SetWindowSize, Descriptors.DESCRIPTOR$SDL_SetWindowSize);
        SEGMENT$SDL_GetWindowSize = loader.apply("SDL_GetWindowSize");
        HANDLE$SDL_GetWindowSize = RawFunctionLoader.link(SEGMENT$SDL_GetWindowSize, Descriptors.DESCRIPTOR$SDL_GetWindowSize);
        SEGMENT$SDL_GetWindowSafeArea = loader.apply("SDL_GetWindowSafeArea");
        HANDLE$SDL_GetWindowSafeArea = RawFunctionLoader.link(SEGMENT$SDL_GetWindowSafeArea, Descriptors.DESCRIPTOR$SDL_GetWindowSafeArea);
        SEGMENT$SDL_SetWindowAspectRatio = loader.apply("SDL_SetWindowAspectRatio");
        HANDLE$SDL_SetWindowAspectRatio = RawFunctionLoader.link(SEGMENT$SDL_SetWindowAspectRatio, Descriptors.DESCRIPTOR$SDL_SetWindowAspectRatio);
        SEGMENT$SDL_GetWindowAspectRatio = loader.apply("SDL_GetWindowAspectRatio");
        HANDLE$SDL_GetWindowAspectRatio = RawFunctionLoader.link(SEGMENT$SDL_GetWindowAspectRatio, Descriptors.DESCRIPTOR$SDL_GetWindowAspectRatio);
        SEGMENT$SDL_GetWindowBordersSize = loader.apply("SDL_GetWindowBordersSize");
        HANDLE$SDL_GetWindowBordersSize = RawFunctionLoader.link(SEGMENT$SDL_GetWindowBordersSize, Descriptors.DESCRIPTOR$SDL_GetWindowBordersSize);
        SEGMENT$SDL_GetWindowSizeInPixels = loader.apply("SDL_GetWindowSizeInPixels");
        HANDLE$SDL_GetWindowSizeInPixels = RawFunctionLoader.link(SEGMENT$SDL_GetWindowSizeInPixels, Descriptors.DESCRIPTOR$SDL_GetWindowSizeInPixels);
        SEGMENT$SDL_SetWindowMinimumSize = loader.apply("SDL_SetWindowMinimumSize");
        HANDLE$SDL_SetWindowMinimumSize = RawFunctionLoader.link(SEGMENT$SDL_SetWindowMinimumSize, Descriptors.DESCRIPTOR$SDL_SetWindowMinimumSize);
        SEGMENT$SDL_GetWindowMinimumSize = loader.apply("SDL_GetWindowMinimumSize");
        HANDLE$SDL_GetWindowMinimumSize = RawFunctionLoader.link(SEGMENT$SDL_GetWindowMinimumSize, Descriptors.DESCRIPTOR$SDL_GetWindowMinimumSize);
        SEGMENT$SDL_SetWindowMaximumSize = loader.apply("SDL_SetWindowMaximumSize");
        HANDLE$SDL_SetWindowMaximumSize = RawFunctionLoader.link(SEGMENT$SDL_SetWindowMaximumSize, Descriptors.DESCRIPTOR$SDL_SetWindowMaximumSize);
        SEGMENT$SDL_GetWindowMaximumSize = loader.apply("SDL_GetWindowMaximumSize");
        HANDLE$SDL_GetWindowMaximumSize = RawFunctionLoader.link(SEGMENT$SDL_GetWindowMaximumSize, Descriptors.DESCRIPTOR$SDL_GetWindowMaximumSize);
        SEGMENT$SDL_SetWindowBordered = loader.apply("SDL_SetWindowBordered");
        HANDLE$SDL_SetWindowBordered = RawFunctionLoader.link(SEGMENT$SDL_SetWindowBordered, Descriptors.DESCRIPTOR$SDL_SetWindowBordered);
        SEGMENT$SDL_SetWindowResizable = loader.apply("SDL_SetWindowResizable");
        HANDLE$SDL_SetWindowResizable = RawFunctionLoader.link(SEGMENT$SDL_SetWindowResizable, Descriptors.DESCRIPTOR$SDL_SetWindowResizable);
        SEGMENT$SDL_SetWindowAlwaysOnTop = loader.apply("SDL_SetWindowAlwaysOnTop");
        HANDLE$SDL_SetWindowAlwaysOnTop = RawFunctionLoader.link(SEGMENT$SDL_SetWindowAlwaysOnTop, Descriptors.DESCRIPTOR$SDL_SetWindowAlwaysOnTop);
        SEGMENT$SDL_ShowWindow = loader.apply("SDL_ShowWindow");
        HANDLE$SDL_ShowWindow = RawFunctionLoader.link(SEGMENT$SDL_ShowWindow, Descriptors.DESCRIPTOR$SDL_ShowWindow);
        SEGMENT$SDL_HideWindow = loader.apply("SDL_HideWindow");
        HANDLE$SDL_HideWindow = RawFunctionLoader.link(SEGMENT$SDL_HideWindow, Descriptors.DESCRIPTOR$SDL_HideWindow);
        SEGMENT$SDL_RaiseWindow = loader.apply("SDL_RaiseWindow");
        HANDLE$SDL_RaiseWindow = RawFunctionLoader.link(SEGMENT$SDL_RaiseWindow, Descriptors.DESCRIPTOR$SDL_RaiseWindow);
        SEGMENT$SDL_MaximizeWindow = loader.apply("SDL_MaximizeWindow");
        HANDLE$SDL_MaximizeWindow = RawFunctionLoader.link(SEGMENT$SDL_MaximizeWindow, Descriptors.DESCRIPTOR$SDL_MaximizeWindow);
        SEGMENT$SDL_MinimizeWindow = loader.apply("SDL_MinimizeWindow");
        HANDLE$SDL_MinimizeWindow = RawFunctionLoader.link(SEGMENT$SDL_MinimizeWindow, Descriptors.DESCRIPTOR$SDL_MinimizeWindow);
        SEGMENT$SDL_RestoreWindow = loader.apply("SDL_RestoreWindow");
        HANDLE$SDL_RestoreWindow = RawFunctionLoader.link(SEGMENT$SDL_RestoreWindow, Descriptors.DESCRIPTOR$SDL_RestoreWindow);
        SEGMENT$SDL_SetWindowFullscreen = loader.apply("SDL_SetWindowFullscreen");
        HANDLE$SDL_SetWindowFullscreen = RawFunctionLoader.link(SEGMENT$SDL_SetWindowFullscreen, Descriptors.DESCRIPTOR$SDL_SetWindowFullscreen);
        SEGMENT$SDL_SyncWindow = loader.apply("SDL_SyncWindow");
        HANDLE$SDL_SyncWindow = RawFunctionLoader.link(SEGMENT$SDL_SyncWindow, Descriptors.DESCRIPTOR$SDL_SyncWindow);
        SEGMENT$SDL_WindowHasSurface = loader.apply("SDL_WindowHasSurface");
        HANDLE$SDL_WindowHasSurface = RawFunctionLoader.link(SEGMENT$SDL_WindowHasSurface, Descriptors.DESCRIPTOR$SDL_WindowHasSurface);
        SEGMENT$SDL_GetWindowSurface = loader.apply("SDL_GetWindowSurface");
        HANDLE$SDL_GetWindowSurface = RawFunctionLoader.link(SEGMENT$SDL_GetWindowSurface, Descriptors.DESCRIPTOR$SDL_GetWindowSurface);
        SEGMENT$SDL_SetWindowSurfaceVSync = loader.apply("SDL_SetWindowSurfaceVSync");
        HANDLE$SDL_SetWindowSurfaceVSync = RawFunctionLoader.link(SEGMENT$SDL_SetWindowSurfaceVSync, Descriptors.DESCRIPTOR$SDL_SetWindowSurfaceVSync);
        SEGMENT$SDL_GetWindowSurfaceVSync = loader.apply("SDL_GetWindowSurfaceVSync");
        HANDLE$SDL_GetWindowSurfaceVSync = RawFunctionLoader.link(SEGMENT$SDL_GetWindowSurfaceVSync, Descriptors.DESCRIPTOR$SDL_GetWindowSurfaceVSync);
        SEGMENT$SDL_UpdateWindowSurface = loader.apply("SDL_UpdateWindowSurface");
        HANDLE$SDL_UpdateWindowSurface = RawFunctionLoader.link(SEGMENT$SDL_UpdateWindowSurface, Descriptors.DESCRIPTOR$SDL_UpdateWindowSurface);
        SEGMENT$SDL_UpdateWindowSurfaceRects = loader.apply("SDL_UpdateWindowSurfaceRects");
        HANDLE$SDL_UpdateWindowSurfaceRects = RawFunctionLoader.link(SEGMENT$SDL_UpdateWindowSurfaceRects, Descriptors.DESCRIPTOR$SDL_UpdateWindowSurfaceRects);
        SEGMENT$SDL_DestroyWindowSurface = loader.apply("SDL_DestroyWindowSurface");
        HANDLE$SDL_DestroyWindowSurface = RawFunctionLoader.link(SEGMENT$SDL_DestroyWindowSurface, Descriptors.DESCRIPTOR$SDL_DestroyWindowSurface);
        SEGMENT$SDL_SetWindowKeyboardGrab = loader.apply("SDL_SetWindowKeyboardGrab");
        HANDLE$SDL_SetWindowKeyboardGrab = RawFunctionLoader.link(SEGMENT$SDL_SetWindowKeyboardGrab, Descriptors.DESCRIPTOR$SDL_SetWindowKeyboardGrab);
        SEGMENT$SDL_SetWindowMouseGrab = loader.apply("SDL_SetWindowMouseGrab");
        HANDLE$SDL_SetWindowMouseGrab = RawFunctionLoader.link(SEGMENT$SDL_SetWindowMouseGrab, Descriptors.DESCRIPTOR$SDL_SetWindowMouseGrab);
        SEGMENT$SDL_GetWindowKeyboardGrab = loader.apply("SDL_GetWindowKeyboardGrab");
        HANDLE$SDL_GetWindowKeyboardGrab = RawFunctionLoader.link(SEGMENT$SDL_GetWindowKeyboardGrab, Descriptors.DESCRIPTOR$SDL_GetWindowKeyboardGrab);
        SEGMENT$SDL_GetWindowMouseGrab = loader.apply("SDL_GetWindowMouseGrab");
        HANDLE$SDL_GetWindowMouseGrab = RawFunctionLoader.link(SEGMENT$SDL_GetWindowMouseGrab, Descriptors.DESCRIPTOR$SDL_GetWindowMouseGrab);
        SEGMENT$SDL_GetGrabbedWindow = loader.apply("SDL_GetGrabbedWindow");
        HANDLE$SDL_GetGrabbedWindow = RawFunctionLoader.link(SEGMENT$SDL_GetGrabbedWindow, Descriptors.DESCRIPTOR$SDL_GetGrabbedWindow);
        SEGMENT$SDL_SetWindowMouseRect = loader.apply("SDL_SetWindowMouseRect");
        HANDLE$SDL_SetWindowMouseRect = RawFunctionLoader.link(SEGMENT$SDL_SetWindowMouseRect, Descriptors.DESCRIPTOR$SDL_SetWindowMouseRect);
        SEGMENT$SDL_GetWindowMouseRect = loader.apply("SDL_GetWindowMouseRect");
        HANDLE$SDL_GetWindowMouseRect = RawFunctionLoader.link(SEGMENT$SDL_GetWindowMouseRect, Descriptors.DESCRIPTOR$SDL_GetWindowMouseRect);
        SEGMENT$SDL_SetWindowOpacity = loader.apply("SDL_SetWindowOpacity");
        HANDLE$SDL_SetWindowOpacity = RawFunctionLoader.link(SEGMENT$SDL_SetWindowOpacity, Descriptors.DESCRIPTOR$SDL_SetWindowOpacity);
        SEGMENT$SDL_GetWindowOpacity = loader.apply("SDL_GetWindowOpacity");
        HANDLE$SDL_GetWindowOpacity = RawFunctionLoader.link(SEGMENT$SDL_GetWindowOpacity, Descriptors.DESCRIPTOR$SDL_GetWindowOpacity);
        SEGMENT$SDL_SetWindowParent = loader.apply("SDL_SetWindowParent");
        HANDLE$SDL_SetWindowParent = RawFunctionLoader.link(SEGMENT$SDL_SetWindowParent, Descriptors.DESCRIPTOR$SDL_SetWindowParent);
        SEGMENT$SDL_SetWindowModal = loader.apply("SDL_SetWindowModal");
        HANDLE$SDL_SetWindowModal = RawFunctionLoader.link(SEGMENT$SDL_SetWindowModal, Descriptors.DESCRIPTOR$SDL_SetWindowModal);
        SEGMENT$SDL_SetWindowFocusable = loader.apply("SDL_SetWindowFocusable");
        HANDLE$SDL_SetWindowFocusable = RawFunctionLoader.link(SEGMENT$SDL_SetWindowFocusable, Descriptors.DESCRIPTOR$SDL_SetWindowFocusable);
        SEGMENT$SDL_ShowWindowSystemMenu = loader.apply("SDL_ShowWindowSystemMenu");
        HANDLE$SDL_ShowWindowSystemMenu = RawFunctionLoader.link(SEGMENT$SDL_ShowWindowSystemMenu, Descriptors.DESCRIPTOR$SDL_ShowWindowSystemMenu);
        SEGMENT$SDL_SetWindowHitTest = loader.apply("SDL_SetWindowHitTest");
        HANDLE$SDL_SetWindowHitTest = RawFunctionLoader.link(SEGMENT$SDL_SetWindowHitTest, Descriptors.DESCRIPTOR$SDL_SetWindowHitTest);
        SEGMENT$SDL_SetWindowShape = loader.apply("SDL_SetWindowShape");
        HANDLE$SDL_SetWindowShape = RawFunctionLoader.link(SEGMENT$SDL_SetWindowShape, Descriptors.DESCRIPTOR$SDL_SetWindowShape);
        SEGMENT$SDL_FlashWindow = loader.apply("SDL_FlashWindow");
        HANDLE$SDL_FlashWindow = RawFunctionLoader.link(SEGMENT$SDL_FlashWindow, Descriptors.DESCRIPTOR$SDL_FlashWindow);
        SEGMENT$SDL_DestroyWindow = loader.apply("SDL_DestroyWindow");
        HANDLE$SDL_DestroyWindow = RawFunctionLoader.link(SEGMENT$SDL_DestroyWindow, Descriptors.DESCRIPTOR$SDL_DestroyWindow);
        SEGMENT$SDL_ScreenSaverEnabled = loader.apply("SDL_ScreenSaverEnabled");
        HANDLE$SDL_ScreenSaverEnabled = RawFunctionLoader.link(SEGMENT$SDL_ScreenSaverEnabled, Descriptors.DESCRIPTOR$SDL_ScreenSaverEnabled);
        SEGMENT$SDL_EnableScreenSaver = loader.apply("SDL_EnableScreenSaver");
        HANDLE$SDL_EnableScreenSaver = RawFunctionLoader.link(SEGMENT$SDL_EnableScreenSaver, Descriptors.DESCRIPTOR$SDL_EnableScreenSaver);
        SEGMENT$SDL_DisableScreenSaver = loader.apply("SDL_DisableScreenSaver");
        HANDLE$SDL_DisableScreenSaver = RawFunctionLoader.link(SEGMENT$SDL_DisableScreenSaver, Descriptors.DESCRIPTOR$SDL_DisableScreenSaver);
        SEGMENT$SDL_GL_LoadLibrary = loader.apply("SDL_GL_LoadLibrary");
        HANDLE$SDL_GL_LoadLibrary = RawFunctionLoader.link(SEGMENT$SDL_GL_LoadLibrary, Descriptors.DESCRIPTOR$SDL_GL_LoadLibrary);
        SEGMENT$SDL_GL_GetProcAddress = loader.apply("SDL_GL_GetProcAddress");
        HANDLE$SDL_GL_GetProcAddress = RawFunctionLoader.link(SEGMENT$SDL_GL_GetProcAddress, Descriptors.DESCRIPTOR$SDL_GL_GetProcAddress);
        SEGMENT$SDL_EGL_GetProcAddress = loader.apply("SDL_EGL_GetProcAddress");
        HANDLE$SDL_EGL_GetProcAddress = RawFunctionLoader.link(SEGMENT$SDL_EGL_GetProcAddress, Descriptors.DESCRIPTOR$SDL_EGL_GetProcAddress);
        SEGMENT$SDL_GL_UnloadLibrary = loader.apply("SDL_GL_UnloadLibrary");
        HANDLE$SDL_GL_UnloadLibrary = RawFunctionLoader.link(SEGMENT$SDL_GL_UnloadLibrary, Descriptors.DESCRIPTOR$SDL_GL_UnloadLibrary);
        SEGMENT$SDL_GL_ExtensionSupported = loader.apply("SDL_GL_ExtensionSupported");
        HANDLE$SDL_GL_ExtensionSupported = RawFunctionLoader.link(SEGMENT$SDL_GL_ExtensionSupported, Descriptors.DESCRIPTOR$SDL_GL_ExtensionSupported);
        SEGMENT$SDL_GL_ResetAttributes = loader.apply("SDL_GL_ResetAttributes");
        HANDLE$SDL_GL_ResetAttributes = RawFunctionLoader.link(SEGMENT$SDL_GL_ResetAttributes, Descriptors.DESCRIPTOR$SDL_GL_ResetAttributes);
        SEGMENT$SDL_GL_SetAttribute = loader.apply("SDL_GL_SetAttribute");
        HANDLE$SDL_GL_SetAttribute = RawFunctionLoader.link(SEGMENT$SDL_GL_SetAttribute, Descriptors.DESCRIPTOR$SDL_GL_SetAttribute);
        SEGMENT$SDL_GL_GetAttribute = loader.apply("SDL_GL_GetAttribute");
        HANDLE$SDL_GL_GetAttribute = RawFunctionLoader.link(SEGMENT$SDL_GL_GetAttribute, Descriptors.DESCRIPTOR$SDL_GL_GetAttribute);
        SEGMENT$SDL_GL_CreateContext = loader.apply("SDL_GL_CreateContext");
        HANDLE$SDL_GL_CreateContext = RawFunctionLoader.link(SEGMENT$SDL_GL_CreateContext, Descriptors.DESCRIPTOR$SDL_GL_CreateContext);
        SEGMENT$SDL_GL_MakeCurrent = loader.apply("SDL_GL_MakeCurrent");
        HANDLE$SDL_GL_MakeCurrent = RawFunctionLoader.link(SEGMENT$SDL_GL_MakeCurrent, Descriptors.DESCRIPTOR$SDL_GL_MakeCurrent);
        SEGMENT$SDL_GL_GetCurrentWindow = loader.apply("SDL_GL_GetCurrentWindow");
        HANDLE$SDL_GL_GetCurrentWindow = RawFunctionLoader.link(SEGMENT$SDL_GL_GetCurrentWindow, Descriptors.DESCRIPTOR$SDL_GL_GetCurrentWindow);
        SEGMENT$SDL_GL_GetCurrentContext = loader.apply("SDL_GL_GetCurrentContext");
        HANDLE$SDL_GL_GetCurrentContext = RawFunctionLoader.link(SEGMENT$SDL_GL_GetCurrentContext, Descriptors.DESCRIPTOR$SDL_GL_GetCurrentContext);
        SEGMENT$SDL_EGL_GetCurrentDisplay = loader.apply("SDL_EGL_GetCurrentDisplay");
        HANDLE$SDL_EGL_GetCurrentDisplay = RawFunctionLoader.link(SEGMENT$SDL_EGL_GetCurrentDisplay, Descriptors.DESCRIPTOR$SDL_EGL_GetCurrentDisplay);
        SEGMENT$SDL_EGL_GetCurrentConfig = loader.apply("SDL_EGL_GetCurrentConfig");
        HANDLE$SDL_EGL_GetCurrentConfig = RawFunctionLoader.link(SEGMENT$SDL_EGL_GetCurrentConfig, Descriptors.DESCRIPTOR$SDL_EGL_GetCurrentConfig);
        SEGMENT$SDL_EGL_GetWindowSurface = loader.apply("SDL_EGL_GetWindowSurface");
        HANDLE$SDL_EGL_GetWindowSurface = RawFunctionLoader.link(SEGMENT$SDL_EGL_GetWindowSurface, Descriptors.DESCRIPTOR$SDL_EGL_GetWindowSurface);
        SEGMENT$SDL_EGL_SetAttributeCallbacks = loader.apply("SDL_EGL_SetAttributeCallbacks");
        HANDLE$SDL_EGL_SetAttributeCallbacks = RawFunctionLoader.link(SEGMENT$SDL_EGL_SetAttributeCallbacks, Descriptors.DESCRIPTOR$SDL_EGL_SetAttributeCallbacks);
        SEGMENT$SDL_GL_SetSwapInterval = loader.apply("SDL_GL_SetSwapInterval");
        HANDLE$SDL_GL_SetSwapInterval = RawFunctionLoader.link(SEGMENT$SDL_GL_SetSwapInterval, Descriptors.DESCRIPTOR$SDL_GL_SetSwapInterval);
        SEGMENT$SDL_GL_GetSwapInterval = loader.apply("SDL_GL_GetSwapInterval");
        HANDLE$SDL_GL_GetSwapInterval = RawFunctionLoader.link(SEGMENT$SDL_GL_GetSwapInterval, Descriptors.DESCRIPTOR$SDL_GL_GetSwapInterval);
        SEGMENT$SDL_GL_SwapWindow = loader.apply("SDL_GL_SwapWindow");
        HANDLE$SDL_GL_SwapWindow = RawFunctionLoader.link(SEGMENT$SDL_GL_SwapWindow, Descriptors.DESCRIPTOR$SDL_GL_SwapWindow);
        SEGMENT$SDL_GL_DestroyContext = loader.apply("SDL_GL_DestroyContext");
        HANDLE$SDL_GL_DestroyContext = RawFunctionLoader.link(SEGMENT$SDL_GL_DestroyContext, Descriptors.DESCRIPTOR$SDL_GL_DestroyContext);
    }

    // region command wrappers

    /// Allocate uninitialized memory.
    ///
    /// The allocated memory returned by this function must be freed with
    /// SDL_free().
    ///
    /// If `size` is 0, it will be set to 1.
    ///
    /// If the allocation is successful, the returned pointer is guaranteed to be
    /// aligned to either the *fundamental alignment* (`alignof(max_align_t)` in
    /// C11 and later) or `2 * sizeof(void *)`, whichever is smaller. Use
    /// SDL_aligned_alloc() if you need to allocate memory aligned to an alignment
    /// greater than this guarantee.
    ///
    /// @param size the size to allocate.
    /// @return a pointer to the allocated memory, or NULL if allocation failed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #free
    /// @see #calloc
    /// @see #realloc
    /// @see #aligned_alloc
    public @Pointer(comment="void*") MemorySegment malloc(
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_malloc);
        try {
            return (MemorySegment) hFunction.invokeExact(
                MemorySegment.ofAddress(size)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a zero-initialized array.
    ///
    /// The memory returned by this function must be freed with SDL_free().
    ///
    /// If either of `nmemb` or `size` is 0, they will both be set to 1.
    ///
    /// If the allocation is successful, the returned pointer is guaranteed to be
    /// aligned to either the *fundamental alignment* (`alignof(max_align_t)` in
    /// C11 and later) or `2 * sizeof(void *)`, whichever is smaller.
    ///
    /// @param nmemb the number of elements in the array.
    /// @param size the size of each element of the array.
    /// @return a pointer to the allocated array, or NULL if allocation failed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #free
    /// @see #malloc
    /// @see #realloc
    public @Pointer(comment="void*") MemorySegment calloc(
        long nmemb,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_calloc);
        try {
            return (MemorySegment) hFunction.invokeExact(
                MemorySegment.ofAddress(nmemb),
                MemorySegment.ofAddress(size)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Change the size of allocated memory.
    ///
    /// The memory returned by this function must be freed with SDL_free().
    ///
    /// If `size` is 0, it will be set to 1. Note that this is unlike some other C
    /// runtime `realloc` implementations, which may treat `realloc(mem, 0)` the
    /// same way as `free(mem)`.
    ///
    /// If `mem` is NULL, the behavior of this function is equivalent to
    /// SDL_malloc(). Otherwise, the function can have one of three possible
    /// outcomes:
    ///
    /// - If it returns the same pointer as `mem`, it means that `mem` was resized
    /// in place without freeing.
    /// - If it returns a different non-NULL pointer, it means that `mem` was freed
    /// and cannot be dereferenced anymore.
    /// - If it returns NULL (indicating failure), then `mem` will remain valid and
    /// must still be freed with SDL_free().
    ///
    /// If the allocation is successfully resized, the returned pointer is
    /// guaranteed to be aligned to either the *fundamental alignment*
    /// (`alignof(max_align_t)` in C11 and later) or `2 * sizeof(void *)`,
    /// whichever is smaller.
    ///
    /// @param mem a pointer to allocated memory to reallocate, or NULL.
    /// @param size the new size of the memory.
    /// @return a pointer to the newly allocated memory, or NULL if allocation
    /// failed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #free
    /// @see #malloc
    /// @see #calloc
    public @Pointer(comment="void*") MemorySegment realloc(
        @Pointer(comment="void*") MemorySegment mem,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_realloc);
        try {
            return (MemorySegment) hFunction.invokeExact(
                mem,
                MemorySegment.ofAddress(size)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free allocated memory.
    ///
    /// The pointer is no longer valid after this call and cannot be dereferenced
    /// anymore.
    ///
    /// If `mem` is NULL, this function does nothing.
    ///
    /// @param mem a pointer to allocated memory, or NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #malloc
    /// @see #calloc
    /// @see #realloc
    public void free(
        @Pointer(comment="void*") MemorySegment mem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_free);
        try {
            hFunction.invokeExact(
                mem
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the original set of SDL memory functions.
    ///
    /// This is what SDL_malloc and friends will use by default, if there has been
    /// no call to SDL_SetMemoryFunctions. This is not necessarily using the C
    /// runtime's `malloc` functions behind the scenes! Different platforms and
    /// build configurations might do any number of unexpected things.
    ///
    /// @param malloc_func filled with malloc function.
    /// @param calloc_func filled with calloc function.
    /// @param realloc_func filled with realloc function.
    /// @param free_func filled with free function.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void getOriginalMemoryFunctions(
        @Nullable PointerPtr malloc_func,
        @Nullable PointerPtr calloc_func,
        @Nullable PointerPtr realloc_func,
        @Nullable PointerPtr free_func
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetOriginalMemoryFunctions);
        try {
            hFunction.invokeExact(
                (MemorySegment) (malloc_func != null ? malloc_func.segment() : MemorySegment.NULL),
                (MemorySegment) (calloc_func != null ? calloc_func.segment() : MemorySegment.NULL),
                (MemorySegment) (realloc_func != null ? realloc_func.segment() : MemorySegment.NULL),
                (MemorySegment) (free_func != null ? free_func.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current set of SDL memory functions.
    ///
    /// @param malloc_func filled with malloc function.
    /// @param calloc_func filled with calloc function.
    /// @param realloc_func filled with realloc function.
    /// @param free_func filled with free function.
    ///
    /// @threadsafety This does not hold a lock, so do not call this in the
    /// unlikely event of a background thread calling
    /// SDL_SetMemoryFunctions simultaneously.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setMemoryFunctions
    /// @see #getOriginalMemoryFunctions
    public void getMemoryFunctions(
        @Nullable PointerPtr malloc_func,
        @Nullable PointerPtr calloc_func,
        @Nullable PointerPtr realloc_func,
        @Nullable PointerPtr free_func
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMemoryFunctions);
        try {
            hFunction.invokeExact(
                (MemorySegment) (malloc_func != null ? malloc_func.segment() : MemorySegment.NULL),
                (MemorySegment) (calloc_func != null ? calloc_func.segment() : MemorySegment.NULL),
                (MemorySegment) (realloc_func != null ? realloc_func.segment() : MemorySegment.NULL),
                (MemorySegment) (free_func != null ? free_func.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Replace SDL's memory allocation functions with a custom set.
    ///
    /// It is not safe to call this function once any allocations have been made,
    /// as future calls to SDL_free will use the new allocator, even if they came
    /// from an SDL_malloc made with the old one!
    ///
    /// If used, usually this needs to be the first call made into the SDL library,
    /// if not the very first thing done at program startup time.
    ///
    /// @param malloc_func custom malloc function.
    /// @param calloc_func custom calloc function.
    /// @param realloc_func custom realloc function.
    /// @param free_func custom free function.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, but one
    /// should not replace the memory functions once any allocations
    /// are made!
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMemoryFunctions
    /// @see #getOriginalMemoryFunctions
    public @NativeType("boolean") boolean setMemoryFunctions(
        @Pointer(comment="SDL_malloc_func") MemorySegment malloc_func,
        @Pointer(comment="SDL_calloc_func") MemorySegment calloc_func,
        @Pointer(comment="SDL_realloc_func") MemorySegment realloc_func,
        @Pointer(comment="SDL_free_func") MemorySegment free_func
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetMemoryFunctions);
        try {
            return (boolean) hFunction.invokeExact(
                malloc_func,
                calloc_func,
                realloc_func,
                free_func
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate memory aligned to a specific alignment.
    ///
    /// The memory returned by this function must be freed with SDL_aligned_free(),
    /// _not_ SDL_free().
    ///
    /// If `alignment` is less than the size of `void *`, it will be increased to
    /// match that.
    ///
    /// The returned memory address will be a multiple of the alignment value, and
    /// the size of the memory allocated will be a multiple of the alignment value.
    ///
    /// @param alignment the alignment of the memory.
    /// @param size the size to allocate.
    /// @return a pointer to the aligned memory, or NULL if allocation failed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #aligned_free
    public @Pointer(comment="void*") MemorySegment aligned_alloc(
        long alignment,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_aligned_alloc);
        try {
            return (MemorySegment) hFunction.invokeExact(
                MemorySegment.ofAddress(alignment),
                MemorySegment.ofAddress(size)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free memory allocated by SDL_aligned_alloc().
    ///
    /// The pointer is no longer valid after this call and cannot be dereferenced
    /// anymore.
    ///
    /// If `mem` is NULL, this function does nothing.
    ///
    /// @param mem a pointer previously returned by SDL_aligned_alloc(), or NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #aligned_alloc
    public void aligned_free(
        @Pointer(comment="void*") MemorySegment mem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_aligned_free);
        try {
            hFunction.invokeExact(
                mem
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of outstanding (unfreed) allocations.
    ///
    /// @return the number of allocations or -1 if allocation counting is
    /// disabled.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getNumAllocations() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumAllocations);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the process environment.
    ///
    /// This is initialized at application start and is not affected by setenv()
    /// and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and
    /// SDL_UnsetEnvironmentVariable() if you want to modify this environment, or
    /// SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist
    /// in the C runtime environment after SDL_Quit().
    ///
    /// @return a pointer to the environment for the process or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEnvironmentVariable
    /// @see #getEnvironmentVariables
    /// @see #setEnvironmentVariable
    /// @see #unsetEnvironmentVariable
    public SDL_Environment getEnvironment() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetEnvironment);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Environment(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a set of environment variables
    ///
    /// @param populated true to initialize it from the C runtime environment,
    /// false to create an empty environment.
    /// @return a pointer to the new environment or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety If `populated` is false, it is safe to call this function
    /// from any thread, otherwise it is safe if no other threads are
    /// calling setenv() or unsetenv()
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEnvironmentVariable
    /// @see #getEnvironmentVariables
    /// @see #setEnvironmentVariable
    /// @see #unsetEnvironmentVariable
    /// @see #destroyEnvironment
    public SDL_Environment createEnvironment(
        @NativeType("boolean") boolean populated
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateEnvironment);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                populated
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Environment(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of a variable in the environment.
    ///
    /// @param env the environment to query.
    /// @param name the name of the variable to get.
    /// @return a pointer to the value of the variable or NULL if it can't be
    /// found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEnvironment
    /// @see #createEnvironment
    /// @see #getEnvironmentVariables
    /// @see #setEnvironmentVariable
    /// @see #unsetEnvironmentVariable
    public BytePtr getEnvironmentVariable(
        @Nullable SDL_Environment env,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetEnvironmentVariable);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (env != null ? env.segment() : MemorySegment.NULL),
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get all variables in the environment.
    ///
    /// @param env the environment to query.
    /// @return a NULL terminated array of pointers to environment variables in
    /// the form "variable=value" or NULL on failure; call SDL_GetError()
    /// for more information. This is a single allocation that should be
    /// freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEnvironment
    /// @see #createEnvironment
    /// @see #getEnvironmentVariables
    /// @see #setEnvironmentVariable
    /// @see #unsetEnvironmentVariable
    public PointerPtr getEnvironmentVariables(
        @Nullable SDL_Environment env
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetEnvironmentVariables);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (env != null ? env.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the value of a variable in the environment.
    ///
    /// @param env the environment to modify.
    /// @param name the name of the variable to set.
    /// @param value the value of the variable to set.
    /// @param overwrite true to overwrite the variable if it exists, false to
    /// return success without setting the variable if it already
    /// exists.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEnvironment
    /// @see #createEnvironment
    /// @see #getEnvironmentVariable
    /// @see #getEnvironmentVariables
    /// @see #unsetEnvironmentVariable
    public @NativeType("boolean") boolean setEnvironmentVariable(
        @Nullable SDL_Environment env,
        @Nullable BytePtr name,
        @Nullable BytePtr value,
        @NativeType("boolean") boolean overwrite
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetEnvironmentVariable);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (env != null ? env.segment() : MemorySegment.NULL),
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL),
                overwrite
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear a variable from the environment.
    ///
    /// @param env the environment to modify.
    /// @param name the name of the variable to unset.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEnvironment
    /// @see #createEnvironment
    /// @see #getEnvironmentVariable
    /// @see #getEnvironmentVariables
    /// @see #setEnvironmentVariable
    /// @see #unsetEnvironmentVariable
    public @NativeType("boolean") boolean unsetEnvironmentVariable(
        @Nullable SDL_Environment env,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnsetEnvironmentVariable);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (env != null ? env.segment() : MemorySegment.NULL),
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a set of environment variables.
    ///
    /// @param env the environment to destroy.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the environment is no longer in use.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createEnvironment
    public void destroyEnvironment(
        @Nullable SDL_Environment env
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyEnvironment);
        try {
            hFunction.invokeExact(
                (MemorySegment) (env != null ? env.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of a variable in the environment.
    ///
    /// This function uses SDL's cached copy of the environment and is thread-safe.
    ///
    /// @param name the name of the variable to get.
    /// @return a pointer to the value of the variable or NULL if it can't be
    /// found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getenv(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_getenv);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of a variable in the environment.
    ///
    /// This function bypasses SDL's cached copy of the environment and is not
    /// thread-safe.
    ///
    /// @param name the name of the variable to get.
    /// @return a pointer to the value of the variable or NULL if it can't be
    /// found.
    ///
    /// @threadsafety This function is not thread safe, consider using SDL_getenv()
    /// instead.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getenv
    public BytePtr getenv_unsafe(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_getenv_unsafe);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the value of a variable in the environment.
    ///
    /// @param name the name of the variable to set.
    /// @param value the value of the variable to set.
    /// @param overwrite 1 to overwrite the variable if it exists, 0 to return
    /// success without setting the variable if it already exists.
    /// @return 0 on success, -1 on error.
    ///
    /// @threadsafety This function is not thread safe, consider using
    /// SDL_SetEnvironmentVariable() instead.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setEnvironmentVariable
    public int setenv_unsafe(
        @Nullable BytePtr name,
        @Nullable BytePtr value,
        int overwrite
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_setenv_unsafe);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL),
                overwrite
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear a variable from the environment.
    ///
    /// @param name the name of the variable to unset.
    /// @return 0 on success, -1 on error.
    ///
    /// @threadsafety This function is not thread safe, consider using
    /// SDL_UnsetEnvironmentVariable() instead.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #unsetEnvironmentVariable
    public int unsetenv_unsafe(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_unsetenv_unsafe);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sort an array.
    ///
    /// For example:
    ///
    /// ```c
    /// typedef struct {
    /// int key;
    /// const char *string;
    /// } data;
    ///
    /// int SDLCALL compare(const void *a, const void *b)
    /// {
    /// const data *A = (const data *)a;
    /// const data *B = (const data *)b;
    ///
    /// if (A-&amp;gt;n &amp;lt; B-&amp;gt;n) {
    /// return -1;
    /// } else if (B-&amp;gt;n &amp;lt; A-&amp;gt;n) {
    /// return 1;
    /// } else {
    /// return 0;
    /// }
    /// }
    ///
    /// data values[] = {
    /// { 3, "third" }, { 1, "first" }, { 2, "second" }
    /// };
    ///
    /// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);
    /// ```
    ///
    /// @param base a pointer to the start of the array.
    /// @param nmemb the number of elements in the array.
    /// @param size the size of the elements in the array.
    /// @param compare a function used to compare elements in the array.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bsearch
    /// @see #qsort_r
    public void qsort(
        @Pointer(comment="void*") MemorySegment base,
        long nmemb,
        long size,
        @Pointer(comment="SDL_CompareCallback") MemorySegment compare
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_qsort);
        try {
            hFunction.invokeExact(
                base,
                MemorySegment.ofAddress(nmemb),
                MemorySegment.ofAddress(size),
                compare
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a binary search on a previously sorted array.
    ///
    /// For example:
    ///
    /// ```c
    /// typedef struct {
    /// int key;
    /// const char *string;
    /// } data;
    ///
    /// int SDLCALL compare(const void *a, const void *b)
    /// {
    /// const data *A = (const data *)a;
    /// const data *B = (const data *)b;
    ///
    /// if (A-&amp;gt;n &amp;lt; B-&amp;gt;n) {
    /// return -1;
    /// } else if (B-&amp;gt;n &amp;lt; A-&amp;gt;n) {
    /// return 1;
    /// } else {
    /// return 0;
    /// }
    /// }
    ///
    /// data values[] = {
    /// { 1, "first" }, { 2, "second" }, { 3, "third" }
    /// };
    /// data key = { 2, NULL };
    ///
    /// data *result = SDL_bsearch(&amp;key, values, SDL_arraysize(values), sizeof(values[0]), compare);
    /// ```
    ///
    /// @param key a pointer to a key equal to the element being searched for.
    /// @param base a pointer to the start of the array.
    /// @param nmemb the number of elements in the array.
    /// @param size the size of the elements in the array.
    /// @param compare a function used to compare elements in the array.
    /// @return a pointer to the matching element in the array, or NULL if not
    /// found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bsearch_r
    /// @see #qsort
    public @Pointer(comment="void*") MemorySegment bsearch(
        @Pointer(comment="void*") MemorySegment key,
        @Pointer(comment="void*") MemorySegment base,
        long nmemb,
        long size,
        @Pointer(comment="SDL_CompareCallback") MemorySegment compare
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_bsearch);
        try {
            return (MemorySegment) hFunction.invokeExact(
                key,
                base,
                MemorySegment.ofAddress(nmemb),
                MemorySegment.ofAddress(size),
                compare
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sort an array, passing a userdata pointer to the compare function.
    ///
    /// For example:
    ///
    /// ```c
    /// typedef enum {
    /// sort_increasing,
    /// sort_decreasing,
    /// } sort_method;
    ///
    /// typedef struct {
    /// int key;
    /// const char *string;
    /// } data;
    ///
    /// int SDLCALL compare(const void *userdata, const void *a, const void *b)
    /// {
    /// sort_method method = (sort_method)(uintptr_t)userdata;
    /// const data *A = (const data *)a;
    /// const data *B = (const data *)b;
    ///
    /// if (A-&amp;gt;key &amp;lt; B-&amp;gt;key) {
    /// return (method == sort_increasing) ? -1 : 1;
    /// } else if (B-&amp;gt;key &amp;lt; A-&amp;gt;key) {
    /// return (method == sort_increasing) ? 1 : -1;
    /// } else {
    /// return 0;
    /// }
    /// }
    ///
    /// data values[] = {
    /// { 3, "third" }, { 1, "first" }, { 2, "second" }
    /// };
    ///
    /// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);
    /// ```
    ///
    /// @param base a pointer to the start of the array.
    /// @param nmemb the number of elements in the array.
    /// @param size the size of the elements in the array.
    /// @param compare a function used to compare elements in the array.
    /// @param userdata a pointer to pass to the compare function.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bsearch_r
    /// @see #qsort
    public void qsort_r(
        @Pointer(comment="void*") MemorySegment base,
        long nmemb,
        long size,
        @Pointer(comment="SDL_CompareCallback_r") MemorySegment compare,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_qsort_r);
        try {
            hFunction.invokeExact(
                base,
                MemorySegment.ofAddress(nmemb),
                MemorySegment.ofAddress(size),
                compare,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a binary search on a previously sorted array, passing a userdata
    /// pointer to the compare function.
    ///
    /// For example:
    ///
    /// ```c
    /// typedef enum {
    /// sort_increasing,
    /// sort_decreasing,
    /// } sort_method;
    ///
    /// typedef struct {
    /// int key;
    /// const char *string;
    /// } data;
    ///
    /// int SDLCALL compare(const void *userdata, const void *a, const void *b)
    /// {
    /// sort_method method = (sort_method)(uintptr_t)userdata;
    /// const data *A = (const data *)a;
    /// const data *B = (const data *)b;
    ///
    /// if (A-&amp;gt;key &amp;lt; B-&amp;gt;key) {
    /// return (method == sort_increasing) ? -1 : 1;
    /// } else if (B-&amp;gt;key &amp;lt; A-&amp;gt;key) {
    /// return (method == sort_increasing) ? 1 : -1;
    /// } else {
    /// return 0;
    /// }
    /// }
    ///
    /// data values[] = {
    /// { 1, "first" }, { 2, "second" }, { 3, "third" }
    /// };
    /// data key = { 2, NULL };
    ///
    /// data *result = SDL_bsearch_r(&amp;key, values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);
    /// ```
    ///
    /// @param key a pointer to a key equal to the element being searched for.
    /// @param base a pointer to the start of the array.
    /// @param nmemb the number of elements in the array.
    /// @param size the size of the elements in the array.
    /// @param compare a function used to compare elements in the array.
    /// @param userdata a pointer to pass to the compare function.
    /// @return a pointer to the matching element in the array, or NULL if not
    /// found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bsearch
    /// @see #qsort_r
    public @Pointer(comment="void*") MemorySegment bsearch_r(
        @Pointer(comment="void*") MemorySegment key,
        @Pointer(comment="void*") MemorySegment base,
        long nmemb,
        long size,
        @Pointer(comment="SDL_CompareCallback_r") MemorySegment compare,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_bsearch_r);
        try {
            return (MemorySegment) hFunction.invokeExact(
                key,
                base,
                MemorySegment.ofAddress(nmemb),
                MemorySegment.ofAddress(size),
                compare,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the absolute value of `x`.
    ///
    /// @param x an integer value.
    /// @return the absolute value of x.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int abs(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_abs);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if a character is alphabetic (a letter).
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// for English 'a-z' and 'A-Z' as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isalpha(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isalpha);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if a character is alphabetic (a letter) or a number.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// for English 'a-z', 'A-Z', and '0-9' as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isalnum(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isalnum);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is blank (a space or tab).
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// 0x20 (space) or 0x9 (tab) as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isblank(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isblank);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is a control character.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// 0 through 0x1F, and 0x7F, as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int iscntrl(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_iscntrl);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is a numeric digit.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// '0' (0x30) through '9' (0x39), as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isdigit(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isdigit);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is a hexadecimal digit.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// 'A' through 'F', 'a' through 'f', and '0' through '9', as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isxdigit(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isxdigit);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is a punctuation mark.
    ///
    /// **WARNING**: Regardless of system locale, this is equivalent to
    /// `((SDL_isgraph(x)) &amp;&amp; (!SDL_isalnum(x)))`.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isgraph
    /// @see #isalnum
    public int ispunct(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ispunct);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is whitespace.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat the
    /// following ASCII values as true:
    ///
    /// - space (0x20)
    /// - tab (0x09)
    /// - newline (0x0A)
    /// - vertical tab (0x0B)
    /// - form feed (0x0C)
    /// - return (0x0D)
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isspace(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isspace);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is upper case.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// 'A' through 'Z' as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isupper(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isupper);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is lower case.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// 'a' through 'z' as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int islower(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_islower);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is "printable".
    ///
    /// Be advised that "printable" has a definition that goes back to text
    /// terminals from the dawn of computing, making this a sort of special case
    /// function that is not suitable for Unicode (or most any) text management.
    ///
    /// **WARNING**: Regardless of system locale, this will only treat ASCII values
    /// ' ' (0x20) through '~' (0x7E) as true.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int isprint(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isprint);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report if a character is any "printable" except space.
    ///
    /// Be advised that "printable" has a definition that goes back to text
    /// terminals from the dawn of computing, making this a sort of special case
    /// function that is not suitable for Unicode (or most any) text management.
    ///
    /// **WARNING**: Regardless of system locale, this is equivalent to
    /// `(SDL_isprint(x)) &amp;&amp; ((x) != ' ')`.
    ///
    /// @param x character value to check.
    /// @return non-zero if x falls within the character class, zero otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isprint
    public int isgraph(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isgraph);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert low-ASCII English letters to uppercase.
    ///
    /// **WARNING**: Regardless of system locale, this will only convert ASCII
    /// values 'a' through 'z' to uppercase.
    ///
    /// This function returns the uppercase equivalent of `x`. If a character
    /// cannot be converted, or is already uppercase, this function returns `x`.
    ///
    /// @param x character value to check.
    /// @return capitalized version of x, or x if no conversion available.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int toupper(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_toupper);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert low-ASCII English letters to lowercase.
    ///
    /// **WARNING**: Regardless of system locale, this will only convert ASCII
    /// values 'A' through 'Z' to lowercase.
    ///
    /// This function returns the lowercase equivalent of `x`. If a character
    /// cannot be converted, or is already lowercase, this function returns `x`.
    ///
    /// @param x character value to check.
    /// @return lowercase version of x, or x if no conversion available.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int tolower(
        int x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_tolower);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate a CRC-16 value.
    ///
    /// https://en.wikipedia.org/wiki/Cyclic_redundancy_check
    ///
    /// This function can be called multiple times, to stream data to be
    /// checksummed in blocks. Each call must provide the previous CRC-16 return
    /// value to be updated with the next block. The first call to this function
    /// for a set of blocks should pass in a zero CRC value.
    ///
    /// @param crc the current checksum for this data set, or 0 for a new data set.
    /// @param data a new block of data to add to the checksum.
    /// @param len the size, in bytes, of the new block of data.
    /// @return a CRC-16 checksum value of all blocks in the data set.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint16") @Unsigned short crc16(
        @NativeType("Uint16") @Unsigned short crc,
        @Pointer(comment="void*") MemorySegment data,
        long len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_crc16);
        try {
            return (short) hFunction.invokeExact(
                crc,
                data,
                MemorySegment.ofAddress(len)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate a CRC-32 value.
    ///
    /// https://en.wikipedia.org/wiki/Cyclic_redundancy_check
    ///
    /// This function can be called multiple times, to stream data to be
    /// checksummed in blocks. Each call must provide the previous CRC-32 return
    /// value to be updated with the next block. The first call to this function
    /// for a set of blocks should pass in a zero CRC value.
    ///
    /// @param crc the current checksum for this data set, or 0 for a new data set.
    /// @param data a new block of data to add to the checksum.
    /// @param len the size, in bytes, of the new block of data.
    /// @return a CRC-32 checksum value of all blocks in the data set.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint32") @Unsigned int crc32(
        @NativeType("Uint32") @Unsigned int crc,
        @Pointer(comment="void*") MemorySegment data,
        long len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_crc32);
        try {
            return (int) hFunction.invokeExact(
                crc,
                data,
                MemorySegment.ofAddress(len)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate a 32-bit MurmurHash3 value for a block of data.
    ///
    /// https://en.wikipedia.org/wiki/MurmurHash
    ///
    /// A seed may be specified, which changes the final results consistently, but
    /// this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous
    /// result from this function back into itself as the next seed value to
    /// calculate a hash in chunks; it won't produce the same hash as it would if
    /// the same data was provided in a single call.
    ///
    /// If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not
    /// cryptographically secure, so it shouldn't be used for hashing top-secret
    /// data.
    ///
    /// @param data the data to be hashed.
    /// @param len the size of data, in bytes.
    /// @param seed a value that alters the final hash value.
    /// @return a Murmur3 32-bit hash value.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint32") @Unsigned int murmur3_32(
        @Pointer(comment="void*") MemorySegment data,
        long len,
        @NativeType("Uint32") @Unsigned int seed
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_murmur3_32);
        try {
            return (int) hFunction.invokeExact(
                data,
                MemorySegment.ofAddress(len),
                seed
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy non-overlapping memory.
    ///
    /// The memory regions must not overlap. If they do, use SDL_memmove() instead.
    ///
    /// @param dst The destination memory region. Must not be NULL, and must not
    /// overlap with `src`.
    /// @param src The source memory region. Must not be NULL, and must not overlap
    /// with `dst`.
    /// @param len The length in bytes of both `dst` and `src`.
    /// @return `dst`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #memmove
    public @Pointer(comment="void*") MemorySegment memcpy(
        @Pointer(comment="void*") MemorySegment dst,
        @Pointer(comment="void*") MemorySegment src,
        long len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_memcpy);
        try {
            return (MemorySegment) hFunction.invokeExact(
                dst,
                src,
                MemorySegment.ofAddress(len)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy memory ranges that might overlap.
    ///
    /// It is okay for the memory regions to overlap. If you are confident that the
    /// regions never overlap, using SDL_memcpy() may improve performance.
    ///
    /// @param dst The destination memory region. Must not be NULL.
    /// @param src The source memory region. Must not be NULL.
    /// @param len The length in bytes of both `dst` and `src`.
    /// @return `dst`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #memcpy
    public @Pointer(comment="void*") MemorySegment memmove(
        @Pointer(comment="void*") MemorySegment dst,
        @Pointer(comment="void*") MemorySegment src,
        long len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_memmove);
        try {
            return (MemorySegment) hFunction.invokeExact(
                dst,
                src,
                MemorySegment.ofAddress(len)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Initialize all bytes of buffer of memory to a specific value.
    ///
    /// This function will set `len` bytes, pointed to by `dst`, to the value
    /// specified in `c`.
    ///
    /// Despite `c` being an `int` instead of a `char`, this only operates on
    /// bytes; `c` must be a value between 0 and 255, inclusive.
    ///
    /// @param dst the destination memory region. Must not be NULL.
    /// @param c the byte value to set.
    /// @param len the length, in bytes, to set in `dst`.
    /// @return `dst`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="void*") MemorySegment memset(
        @Pointer(comment="void*") MemorySegment dst,
        int c,
        long len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_memset);
        try {
            return (MemorySegment) hFunction.invokeExact(
                dst,
                c,
                MemorySegment.ofAddress(len)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Initialize all 32-bit words of buffer of memory to a specific value.
    ///
    /// This function will set a buffer of `dwords` Uint32 values, pointed to by
    /// `dst`, to the value specified in `val`.
    ///
    /// Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited
    /// to a range of 0-255.
    ///
    /// @param dst the destination memory region. Must not be NULL.
    /// @param val the Uint32 value to set.
    /// @param dwords the number of Uint32 values to set in `dst`.
    /// @return `dst`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="void*") MemorySegment memset4(
        @Pointer(comment="void*") MemorySegment dst,
        @NativeType("Uint32") @Unsigned int val,
        long dwords
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_memset4);
        try {
            return (MemorySegment) hFunction.invokeExact(
                dst,
                val,
                MemorySegment.ofAddress(dwords)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two buffers of memory.
    ///
    /// @param s1 the first buffer to compare. NULL is not permitted!
    /// @param s2 the second buffer to compare. NULL is not permitted!
    /// @param len the number of bytes to compare between the buffers.
    /// @return less than zero if s1 is "less than" s2, greater than zero if s1 is
    /// "greater than" s2, and zero if the buffers match exactly for `len`
    /// bytes.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int memcmp(
        @Pointer(comment="void*") MemorySegment s1,
        @Pointer(comment="void*") MemorySegment s2,
        long len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_memcmp);
        try {
            return (int) hFunction.invokeExact(
                s1,
                s2,
                MemorySegment.ofAddress(len)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This works exactly like wcslen() but doesn't require access to a C runtime.
    ///
    /// Counts the number of wchar_t values in `wstr`, excluding the null
    /// terminator.
    ///
    /// Like SDL_strlen only counts bytes and not codepoints in a UTF-8 string,
    /// this counts wchar_t values in a string, even if the string's encoding is of
    /// variable width, like UTF-16.
    ///
    /// Also be aware that wchar_t is different sizes on different platforms (4
    /// bytes on Linux, 2 on Windows, etc).
    ///
    /// @param wstr The null-terminated wide string to read. Must not be NULL.
    /// @return the length (in wchar_t values, excluding the null terminator) of
    /// `wstr`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #wcsnlen
    /// @see #utf8strlen
    /// @see #utf8strnlen
    public long wcslen(
        @Pointer(comment="wchar_t*") MemorySegment wstr
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcslen);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                wstr
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This works exactly like wcsnlen() but doesn't require access to a C
    /// runtime.
    ///
    /// Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the
    /// null terminator.
    ///
    /// Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,
    /// this counts wchar_t values in a string, even if the string's encoding is of
    /// variable width, like UTF-16.
    ///
    /// Also be aware that wchar_t is different sizes on different platforms (4
    /// bytes on Linux, 2 on Windows, etc).
    ///
    /// Also, `maxlen` is a count of wide characters, not bytes!
    ///
    /// @param wstr The null-terminated wide string to read. Must not be NULL.
    /// @param maxlen The maximum amount of wide characters to count.
    /// @return the length (in wide characters, excluding the null terminator) of
    /// `wstr` but never more than `maxlen`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #wcslen
    /// @see #utf8strlen
    /// @see #utf8strnlen
    public long wcsnlen(
        @Pointer(comment="wchar_t*") MemorySegment wstr,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcsnlen);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                wstr,
                MemorySegment.ofAddress(maxlen)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a wide string.
    ///
    /// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then
    /// appends a null terminator.
    ///
    /// `src` and `dst` must not overlap.
    ///
    /// If `maxlen` is 0, no wide characters are copied and no null terminator is
    /// written.
    ///
    /// @param dst The destination buffer. Must not be NULL, and must not overlap
    /// with `src`.
    /// @param src The null-terminated wide string to copy. Must not be NULL, and
    /// must not overlap with `dst`.
    /// @param maxlen The length (in wide characters) of the destination buffer.
    /// @return the length (in wide characters, excluding the null terminator) of
    /// `src`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #wcslcat
    public long wcslcpy(
        @Pointer(comment="wchar_t*") MemorySegment dst,
        @Pointer(comment="wchar_t*") MemorySegment src,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcslcpy);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                dst,
                src,
                MemorySegment.ofAddress(maxlen)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Concatenate wide strings.
    ///
    /// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters
    /// from `src` to the end of the wide string in `dst`, then appends a null
    /// terminator.
    ///
    /// `src` and `dst` must not overlap.
    ///
    /// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is
    /// unmodified.
    ///
    /// @param dst The destination buffer already containing the first
    /// null-terminated wide string. Must not be NULL and must not
    /// overlap with `src`.
    /// @param src The second null-terminated wide string. Must not be NULL, and
    /// must not overlap with `dst`.
    /// @param maxlen The length (in wide characters) of the destination buffer.
    /// @return the length (in wide characters, excluding the null terminator) of
    /// the string in `dst` plus the length of `src`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #wcslcpy
    public long wcslcat(
        @Pointer(comment="wchar_t*") MemorySegment dst,
        @Pointer(comment="wchar_t*") MemorySegment src,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcslcat);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                dst,
                src,
                MemorySegment.ofAddress(maxlen)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a copy of a wide string.
    ///
    /// This allocates enough space for a null-terminated copy of `wstr`, using
    /// SDL_malloc, and then makes a copy of the string into this space.
    ///
    /// The returned string is owned by the caller, and should be passed to
    /// SDL_free when no longer needed.
    ///
    /// @param wstr the string to copy.
    /// @return a pointer to the newly-allocated wide string.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="wchar_t*") MemorySegment wcsdup(
        @Pointer(comment="wchar_t*") MemorySegment wstr
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcsdup);
        try {
            return (MemorySegment) hFunction.invokeExact(
                wstr
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a wide string for the first instance of a specific substring.
    ///
    /// The search ends once it finds the requested substring, or a null terminator
    /// byte to end the string.
    ///
    /// Note that this looks for strings of _wide characters_, not _codepoints_, so
    /// it's legal to search for malformed and incomplete UTF-16 sequences.
    ///
    /// @param haystack the wide string to search. Must not be NULL.
    /// @param needle the wide string to search for. Must not be NULL.
    /// @return a pointer to the first instance of `needle` in the string, or NULL
    /// if not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="wchar_t*") MemorySegment wcsstr(
        @Pointer(comment="wchar_t*") MemorySegment haystack,
        @Pointer(comment="wchar_t*") MemorySegment needle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcsstr);
        try {
            return (MemorySegment) hFunction.invokeExact(
                haystack,
                needle
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a wide string, up to n wide chars, for the first instance of a
    /// specific substring.
    ///
    /// The search ends once it finds the requested substring, or a null terminator
    /// value to end the string, or `maxlen` wide character have been examined. It
    /// is possible to use this function on a wide string without a null
    /// terminator.
    ///
    /// Note that this looks for strings of _wide characters_, not _codepoints_, so
    /// it's legal to search for malformed and incomplete UTF-16 sequences.
    ///
    /// @param haystack the wide string to search. Must not be NULL.
    /// @param needle the wide string to search for. Must not be NULL.
    /// @param maxlen the maximum number of wide characters to search in
    /// `haystack`.
    /// @return a pointer to the first instance of `needle` in the string, or NULL
    /// if not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="wchar_t*") MemorySegment wcsnstr(
        @Pointer(comment="wchar_t*") MemorySegment haystack,
        @Pointer(comment="wchar_t*") MemorySegment needle,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcsnstr);
        try {
            return (MemorySegment) hFunction.invokeExact(
                haystack,
                needle,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two null-terminated wide strings.
    ///
    /// This only compares wchar_t values until it hits a null-terminating
    /// character; it does not care if the string is well-formed UTF-16 (or UTF-32,
    /// depending on your platform's wchar_t size), or uses valid Unicode values.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int wcscmp(
        @Pointer(comment="wchar_t*") MemorySegment str1,
        @Pointer(comment="wchar_t*") MemorySegment str2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcscmp);
        try {
            return (int) hFunction.invokeExact(
                str1,
                str2
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two wide strings up to a number of wchar_t values.
    ///
    /// This only compares wchar_t values; it does not care if the string is
    /// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),
    /// or uses valid Unicode values.
    ///
    /// Note that while this function is intended to be used with UTF-16 (or
    /// UTF-32, depending on your platform's definition of wchar_t), it is
    /// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies
    /// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16
    /// sequence, it will only compare a portion of the final character.
    ///
    /// `maxlen` specifies a maximum number of wchar_t to compare; if the strings
    /// match to this number of wide chars (or both have matched to a
    /// null-terminator character before this count), they will be considered
    /// equal.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @param maxlen the maximum number of wchar_t to compare.
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int wcsncmp(
        @Pointer(comment="wchar_t*") MemorySegment str1,
        @Pointer(comment="wchar_t*") MemorySegment str2,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcsncmp);
        try {
            return (int) hFunction.invokeExact(
                str1,
                str2,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two null-terminated wide strings, case-insensitively.
    ///
    /// This will work with Unicode strings, using a technique called
    /// "case-folding" to handle the vast majority of case-sensitive human
    /// languages regardless of system locale. It can deal with expanding values: a
    /// German Eszett character can compare against two ASCII 's' chars and be
    /// considered a match, for example. A notable exception: it does not handle
    /// the Turkish 'i' character; human language is complicated!
    ///
    /// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
    /// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
    /// handles Unicode, it expects the string to be well-formed and not a
    /// null-terminated string of arbitrary bytes. Characters that are not valid
    /// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), which is to say two strings of random bits may turn out to
    /// match if they convert to the same amount of replacement characters.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int wcscasecmp(
        @Pointer(comment="wchar_t*") MemorySegment str1,
        @Pointer(comment="wchar_t*") MemorySegment str2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcscasecmp);
        try {
            return (int) hFunction.invokeExact(
                str1,
                str2
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two wide strings, case-insensitively, up to a number of wchar_t.
    ///
    /// This will work with Unicode strings, using a technique called
    /// "case-folding" to handle the vast majority of case-sensitive human
    /// languages regardless of system locale. It can deal with expanding values: a
    /// German Eszett character can compare against two ASCII 's' chars and be
    /// considered a match, for example. A notable exception: it does not handle
    /// the Turkish 'i' character; human language is complicated!
    ///
    /// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
    /// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
    /// handles Unicode, it expects the string to be well-formed and not a
    /// null-terminated string of arbitrary bytes. Characters that are not valid
    /// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), which is to say two strings of random bits may turn out to
    /// match if they convert to the same amount of replacement characters.
    ///
    /// Note that while this function might deal with variable-sized characters,
    /// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a
    /// multi-byte UTF-16 sequence, it may convert a portion of the final character
    /// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not
    /// to overflow a buffer.
    ///
    /// `maxlen` specifies a maximum number of wchar_t values to compare; if the
    /// strings match to this number of wchar_t (or both have matched to a
    /// null-terminator character before this number of bytes), they will be
    /// considered equal.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @param maxlen the maximum number of wchar_t values to compare.
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int wcsncasecmp(
        @Pointer(comment="wchar_t*") MemorySegment str1,
        @Pointer(comment="wchar_t*") MemorySegment str2,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcsncasecmp);
        try {
            return (int) hFunction.invokeExact(
                str1,
                str2,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse a `long` from a wide string.
    ///
    /// If `str` starts with whitespace, then those whitespace characters are
    /// skipped before attempting to parse the number.
    ///
    /// If the parsed number does not fit inside a `long`, the result is clamped to
    /// the minimum and maximum representable `long` values.
    ///
    /// @param str The null-terminated wide string to read. Must not be NULL.
    /// @param endp If not NULL, the address of the first invalid wide character
    /// (i.e. the next character after the parsed number) will be
    /// written to this pointer.
    /// @param base The base of the integer to read. Supported values are 0 and 2
    /// to 36 inclusive. If 0, the base will be inferred from the
    /// number's prefix (0x for hexadecimal, 0 for octal, decimal
    /// otherwise).
    /// @return the parsed `long`, or 0 if no number could be parsed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strtol
    public long wcstol(
        @Pointer(comment="wchar_t*") MemorySegment str,
        @Nullable PointerPtr endp,
        int base
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_wcstol);
        try {
            return (long) hFunction.invokeExact(
                str,
                (MemorySegment) (endp != null ? endp.segment() : MemorySegment.NULL),
                base
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This works exactly like strlen() but doesn't require access to a C runtime.
    ///
    /// Counts the bytes in `str`, excluding the null terminator.
    ///
    /// If you need the length of a UTF-8 string, consider using SDL_utf8strlen().
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @return the length (in bytes, excluding the null terminator) of `src`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strnlen
    /// @see #utf8strlen
    /// @see #utf8strnlen
    public long strlen(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strlen);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This works exactly like strnlen() but doesn't require access to a C
    /// runtime.
    ///
    /// Counts up to a maximum of `maxlen` bytes in `str`, excluding the null
    /// terminator.
    ///
    /// If you need the length of a UTF-8 string, consider using SDL_utf8strnlen().
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @param maxlen The maximum amount of bytes to count.
    /// @return the length (in bytes, excluding the null terminator) of `src` but
    /// never more than `maxlen`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strlen
    /// @see #utf8strlen
    /// @see #utf8strnlen
    public long strnlen(
        @Nullable BytePtr str,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strnlen);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a string.
    ///
    /// This function copies up to `maxlen` - 1 characters from `src` to `dst`,
    /// then appends a null terminator.
    ///
    /// If `maxlen` is 0, no characters are copied and no null terminator is
    /// written.
    ///
    /// If you want to copy an UTF-8 string but need to ensure that multi-byte
    /// sequences are not truncated, consider using SDL_utf8strlcpy().
    ///
    /// @param dst The destination buffer. Must not be NULL, and must not overlap
    /// with `src`.
    /// @param src The null-terminated string to copy. Must not be NULL, and must
    /// not overlap with `dst`.
    /// @param maxlen The length (in characters) of the destination buffer.
    /// @return the length (in characters, excluding the null terminator) of
    /// `src`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strlcat
    /// @see #utf8strlcpy
    public long strlcpy(
        @Nullable BytePtr dst,
        @Nullable BytePtr src,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strlcpy);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy an UTF-8 string.
    ///
    /// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while
    /// also ensuring that the string written to `dst` does not end in a truncated
    /// multi-byte sequence. Finally, it appends a null terminator.
    ///
    /// `src` and `dst` must not overlap.
    ///
    /// Note that unlike SDL_strlcpy(), this function returns the number of bytes
    /// written, not the length of `src`.
    ///
    /// @param dst The destination buffer. Must not be NULL, and must not overlap
    /// with `src`.
    /// @param src The null-terminated UTF-8 string to copy. Must not be NULL, and
    /// must not overlap with `dst`.
    /// @param dst_bytes The length (in bytes) of the destination buffer. Must not
    /// be 0.
    /// @return the number of bytes written, excluding the null terminator.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strlcpy
    public long utf8strlcpy(
        @Nullable BytePtr dst,
        @Nullable BytePtr src,
        long dst_bytes
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_utf8strlcpy);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(dst_bytes)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Concatenate strings.
    ///
    /// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from
    /// `src` to the end of the string in `dst`, then appends a null terminator.
    ///
    /// `src` and `dst` must not overlap.
    ///
    /// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is
    /// unmodified.
    ///
    /// @param dst The destination buffer already containing the first
    /// null-terminated string. Must not be NULL and must not overlap
    /// with `src`.
    /// @param src The second null-terminated string. Must not be NULL, and must
    /// not overlap with `dst`.
    /// @param maxlen The length (in characters) of the destination buffer.
    /// @return the length (in characters, excluding the null terminator) of the
    /// string in `dst` plus the length of `src`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strlcpy
    public long strlcat(
        @Nullable BytePtr dst,
        @Nullable BytePtr src,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strlcat);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a copy of a string.
    ///
    /// This allocates enough space for a null-terminated copy of `str`, using
    /// SDL_malloc, and then makes a copy of the string into this space.
    ///
    /// The returned string is owned by the caller, and should be passed to
    /// SDL_free when no longer needed.
    ///
    /// @param str the string to copy.
    /// @return a pointer to the newly-allocated string.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strdup(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strdup);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a copy of a string, up to n characters.
    ///
    /// This allocates enough space for a null-terminated copy of `str`, up to
    /// `maxlen` bytes, using SDL_malloc, and then makes a copy of the string into
    /// this space.
    ///
    /// If the string is longer than `maxlen` bytes, the returned string will be
    /// `maxlen` bytes long, plus a null-terminator character that isn't included
    /// in the count.
    ///
    /// The returned string is owned by the caller, and should be passed to
    /// SDL_free when no longer needed.
    ///
    /// @param str the string to copy.
    /// @param maxlen the maximum length of the copied string, not counting the
    /// null-terminator character.
    /// @return a pointer to the newly-allocated string.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strndup(
        @Nullable BytePtr str,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strndup);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Reverse a string's contents.
    ///
    /// This reverses a null-terminated string in-place. Only the content of the
    /// string is reversed; the null-terminator character remains at the end of the
    /// reversed string.
    ///
    /// **WARNING**: This function reverses the _bytes_ of the string, not the
    /// codepoints. If `str` is a UTF-8 string with Unicode codepoints &amp;gt; 127, this
    /// will ruin the string data. You should only use this function on strings
    /// that are completely comprised of low ASCII characters.
    ///
    /// @param str the string to reverse.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strrev(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strrev);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a string to uppercase.
    ///
    /// **WARNING**: Regardless of system locale, this will only convert ASCII
    /// values 'A' through 'Z' to uppercase.
    ///
    /// This function operates on a null-terminated string of bytes--even if it is
    /// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their
    /// uppercase equivalents in-place, returning the original `str` pointer.
    ///
    /// @param str the string to convert in-place. Can not be NULL.
    /// @return the `str` pointer passed into this function.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strlwr
    public BytePtr strupr(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strupr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a string to lowercase.
    ///
    /// **WARNING**: Regardless of system locale, this will only convert ASCII
    /// values 'A' through 'Z' to lowercase.
    ///
    /// This function operates on a null-terminated string of bytes--even if it is
    /// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their
    /// lowercase equivalents in-place, returning the original `str` pointer.
    ///
    /// @param str the string to convert in-place. Can not be NULL.
    /// @return the `str` pointer passed into this function.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #strupr
    public BytePtr strlwr(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strlwr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a string for the first instance of a specific byte.
    ///
    /// The search ends once it finds the requested byte value, or a null
    /// terminator byte to end the string.
    ///
    /// Note that this looks for _bytes_, not _characters_, so you cannot match
    /// against a Unicode codepoint &amp;gt; 255, regardless of character encoding.
    ///
    /// @param str the string to search. Must not be NULL.
    /// @param c the byte value to search for.
    /// @return a pointer to the first instance of `c` in the string, or NULL if
    /// not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strchr(
        @Nullable BytePtr str,
        int c
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strchr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                c
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a string for the last instance of a specific byte.
    ///
    /// The search must go until it finds a null terminator byte to end the string.
    ///
    /// Note that this looks for _bytes_, not _characters_, so you cannot match
    /// against a Unicode codepoint &amp;gt; 255, regardless of character encoding.
    ///
    /// @param str the string to search. Must not be NULL.
    /// @param c the byte value to search for.
    /// @return a pointer to the last instance of `c` in the string, or NULL if
    /// not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strrchr(
        @Nullable BytePtr str,
        int c
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strrchr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                c
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a string for the first instance of a specific substring.
    ///
    /// The search ends once it finds the requested substring, or a null terminator
    /// byte to end the string.
    ///
    /// Note that this looks for strings of _bytes_, not _characters_, so it's
    /// legal to search for malformed and incomplete UTF-8 sequences.
    ///
    /// @param haystack the string to search. Must not be NULL.
    /// @param needle the string to search for. Must not be NULL.
    /// @return a pointer to the first instance of `needle` in the string, or NULL
    /// if not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strstr(
        @Nullable BytePtr haystack,
        @Nullable BytePtr needle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strstr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (haystack != null ? haystack.segment() : MemorySegment.NULL),
                (MemorySegment) (needle != null ? needle.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a string, up to n bytes, for the first instance of a specific
    /// substring.
    ///
    /// The search ends once it finds the requested substring, or a null terminator
    /// byte to end the string, or `maxlen` bytes have been examined. It is
    /// possible to use this function on a string without a null terminator.
    ///
    /// Note that this looks for strings of _bytes_, not _characters_, so it's
    /// legal to search for malformed and incomplete UTF-8 sequences.
    ///
    /// @param haystack the string to search. Must not be NULL.
    /// @param needle the string to search for. Must not be NULL.
    /// @param maxlen the maximum number of bytes to search in `haystack`.
    /// @return a pointer to the first instance of `needle` in the string, or NULL
    /// if not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strnstr(
        @Nullable BytePtr haystack,
        @Nullable BytePtr needle,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strnstr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (haystack != null ? haystack.segment() : MemorySegment.NULL),
                (MemorySegment) (needle != null ? needle.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Search a UTF-8 string for the first instance of a specific substring,
    /// case-insensitively.
    ///
    /// This will work with Unicode strings, using a technique called
    /// "case-folding" to handle the vast majority of case-sensitive human
    /// languages regardless of system locale. It can deal with expanding values: a
    /// German Eszett character can compare against two ASCII 's' chars and be
    /// considered a match, for example. A notable exception: it does not handle
    /// the Turkish 'i' character; human language is complicated!
    ///
    /// Since this handles Unicode, it expects the strings to be well-formed UTF-8
    /// and not a null-terminated string of arbitrary bytes. Bytes that are not
    /// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), which is to say two strings of random bits may turn out to
    /// match if they convert to the same amount of replacement characters.
    ///
    /// @param haystack the string to search. Must not be NULL.
    /// @param needle the string to search for. Must not be NULL.
    /// @return a pointer to the first instance of `needle` in the string, or NULL
    /// if not found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strcasestr(
        @Nullable BytePtr haystack,
        @Nullable BytePtr needle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strcasestr);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (haystack != null ? haystack.segment() : MemorySegment.NULL),
                (MemorySegment) (needle != null ? needle.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This works exactly like strtok_r() but doesn't require access to a C
    /// runtime.
    ///
    /// Break a string up into a series of tokens.
    ///
    /// To start tokenizing a new string, `str` should be the non-NULL address of
    /// the string to start tokenizing. Future calls to get the next token from the
    /// same string should specify a NULL.
    ///
    /// Note that this function will overwrite pieces of `str` with null chars to
    /// split it into tokens. This function cannot be used with const/read-only
    /// strings!
    ///
    /// `saveptr` just needs to point to a `char *` that can be overwritten; SDL
    /// will use this to save tokenizing state between calls. It is initialized if
    /// `str` is non-NULL, and used to resume tokenizing when `str` is NULL.
    ///
    /// @param str the string to tokenize, or NULL to continue tokenizing.
    /// @param delim the delimiter string that separates tokens.
    /// @param saveptr pointer to a char *, used for ongoing state.
    /// @return A pointer to the next token, or NULL if no tokens remain.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strtok_r(
        @Nullable BytePtr str,
        @Nullable BytePtr delim,
        @Nullable PointerPtr saveptr
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strtok_r);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (delim != null ? delim.segment() : MemorySegment.NULL),
                (MemorySegment) (saveptr != null ? saveptr.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Count the number of codepoints in a UTF-8 string.
    ///
    /// Counts the _codepoints_, not _bytes_, in `str`, excluding the null
    /// terminator.
    ///
    /// If you need to count the bytes in a string instead, consider using
    /// SDL_strlen().
    ///
    /// Since this handles Unicode, it expects the strings to be well-formed UTF-8
    /// and not a null-terminated string of arbitrary bytes. Bytes that are not
    /// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
    /// count by several replacement characters.
    ///
    /// @param str The null-terminated UTF-8 string to read. Must not be NULL.
    /// @return The length (in codepoints, excluding the null terminator) of
    /// `src`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #utf8strnlen
    /// @see #strlen
    public long utf8strlen(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_utf8strlen);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Count the number of codepoints in a UTF-8 string, up to n bytes.
    ///
    /// Counts the _codepoints_, not _bytes_, in `str`, excluding the null
    /// terminator.
    ///
    /// If you need to count the bytes in a string instead, consider using
    /// SDL_strnlen().
    ///
    /// The counting stops at `bytes` bytes (not codepoints!). This seems
    /// counterintuitive, but makes it easy to express the total size of the
    /// string's buffer.
    ///
    /// Since this handles Unicode, it expects the strings to be well-formed UTF-8
    /// and not a null-terminated string of arbitrary bytes. Bytes that are not
    /// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
    /// count by several replacement characters.
    ///
    /// @param str The null-terminated UTF-8 string to read. Must not be NULL.
    /// @param bytes The maximum amount of bytes to count.
    /// @return The length (in codepoints, excluding the null terminator) of `src`
    /// but never more than `maxlen`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #utf8strlen
    /// @see #strnlen
    public long utf8strnlen(
        @Nullable BytePtr str,
        long bytes
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_utf8strnlen);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(bytes)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert an integer into a string.
    ///
    /// This requires a radix to specified for string format. Specifying 10
    /// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
    /// to 36.
    ///
    /// Note that this function will overflow a buffer if `str` is not large enough
    /// to hold the output! It may be safer to use SDL_snprintf to clamp output, or
    /// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
    /// much more space than you expect to use (and don't forget possible negative
    /// signs, null terminator bytes, etc).
    ///
    /// @param value the integer to convert.
    /// @param str the buffer to write the string into.
    /// @param radix the radix to use for string generation.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #uitoa
    /// @see #ltoa
    /// @see #lltoa
    public BytePtr itoa(
        int value,
        @Nullable BytePtr str,
        int radix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_itoa);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                value,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                radix
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert an unsigned integer into a string.
    ///
    /// This requires a radix to specified for string format. Specifying 10
    /// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
    /// to 36.
    ///
    /// Note that this function will overflow a buffer if `str` is not large enough
    /// to hold the output! It may be safer to use SDL_snprintf to clamp output, or
    /// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
    /// much more space than you expect to use (and don't forget null terminator
    /// bytes, etc).
    ///
    /// @param value the unsigned integer to convert.
    /// @param str the buffer to write the string into.
    /// @param radix the radix to use for string generation.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #itoa
    /// @see #ultoa
    /// @see #ulltoa
    public BytePtr uitoa(
        int value,
        @Nullable BytePtr str,
        int radix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_uitoa);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                value,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                radix
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a long integer into a string.
    ///
    /// This requires a radix to specified for string format. Specifying 10
    /// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
    /// to 36.
    ///
    /// Note that this function will overflow a buffer if `str` is not large enough
    /// to hold the output! It may be safer to use SDL_snprintf to clamp output, or
    /// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
    /// much more space than you expect to use (and don't forget possible negative
    /// signs, null terminator bytes, etc).
    ///
    /// @param value the long integer to convert.
    /// @param str the buffer to write the string into.
    /// @param radix the radix to use for string generation.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #ultoa
    /// @see #itoa
    /// @see #lltoa
    public BytePtr ltoa(
        long value,
        @Nullable BytePtr str,
        int radix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ltoa);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                value,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                radix
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert an unsigned long integer into a string.
    ///
    /// This requires a radix to specified for string format. Specifying 10
    /// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
    /// to 36.
    ///
    /// Note that this function will overflow a buffer if `str` is not large enough
    /// to hold the output! It may be safer to use SDL_snprintf to clamp output, or
    /// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
    /// much more space than you expect to use (and don't forget null terminator
    /// bytes, etc).
    ///
    /// @param value the unsigned long integer to convert.
    /// @param str the buffer to write the string into.
    /// @param radix the radix to use for string generation.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #ltoa
    /// @see #uitoa
    /// @see #ulltoa
    public BytePtr ultoa(
        long value,
        @Nullable BytePtr str,
        int radix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ultoa);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                value,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                radix
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a long long integer into a string.
    ///
    /// This requires a radix to specified for string format. Specifying 10
    /// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
    /// to 36.
    ///
    /// Note that this function will overflow a buffer if `str` is not large enough
    /// to hold the output! It may be safer to use SDL_snprintf to clamp output, or
    /// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
    /// much more space than you expect to use (and don't forget possible negative
    /// signs, null terminator bytes, etc).
    ///
    /// @param value the long long integer to convert.
    /// @param str the buffer to write the string into.
    /// @param radix the radix to use for string generation.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #ulltoa
    /// @see #itoa
    /// @see #ltoa
    public BytePtr lltoa(
        long value,
        @Nullable BytePtr str,
        int radix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_lltoa);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                value,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                radix
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert an unsigned long long integer into a string.
    ///
    /// This requires a radix to specified for string format. Specifying 10
    /// produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
    /// to 36.
    ///
    /// Note that this function will overflow a buffer if `str` is not large enough
    /// to hold the output! It may be safer to use SDL_snprintf to clamp output, or
    /// SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
    /// much more space than you expect to use (and don't forget null terminator
    /// bytes, etc).
    ///
    /// @param value the unsigned long long integer to convert.
    /// @param str the buffer to write the string into.
    /// @param radix the radix to use for string generation.
    /// @return `str`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lltoa
    /// @see #uitoa
    /// @see #ultoa
    public BytePtr ulltoa(
        long value,
        @Nullable BytePtr str,
        int radix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ulltoa);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                value,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                radix
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse an `int` from a string.
    ///
    /// The result of calling `SDL_atoi(str)` is equivalent to
    /// `(int)SDL_strtol(str, NULL, 10)`.
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @return the parsed `int`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atof
    /// @see #strtol
    /// @see #strtoul
    /// @see #strtoll
    /// @see #strtoull
    /// @see #strtod
    /// @see #itoa
    public int atoi(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_atoi);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse a `double` from a string.
    ///
    /// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,
    /// NULL)`.
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @return the parsed `double`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atoi
    /// @see #strtol
    /// @see #strtoul
    /// @see #strtoll
    /// @see #strtoull
    /// @see #strtod
    public double atof(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_atof);
        try {
            return (double) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse a `long` from a string.
    ///
    /// If `str` starts with whitespace, then those whitespace characters are
    /// skipped before attempting to parse the number.
    ///
    /// If the parsed number does not fit inside a `long`, the result is clamped to
    /// the minimum and maximum representable `long` values.
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @param endp If not NULL, the address of the first invalid character (i.e.
    /// the next character after the parsed number) will be written to
    /// this pointer.
    /// @param base The base of the integer to read. Supported values are 0 and 2
    /// to 36 inclusive. If 0, the base will be inferred from the
    /// number's prefix (0x for hexadecimal, 0 for octal, decimal
    /// otherwise).
    /// @return the parsed `long`, or 0 if no number could be parsed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atoi
    /// @see #atof
    /// @see #strtoul
    /// @see #strtoll
    /// @see #strtoull
    /// @see #strtod
    /// @see #ltoa
    /// @see #wcstol
    public long strtol(
        @Nullable BytePtr str,
        @Nullable PointerPtr endp,
        int base
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strtol);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (endp != null ? endp.segment() : MemorySegment.NULL),
                base
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse an `unsigned long` from a string.
    ///
    /// If `str` starts with whitespace, then those whitespace characters are
    /// skipped before attempting to parse the number.
    ///
    /// If the parsed number does not fit inside an `unsigned long`, the result is
    /// clamped to the maximum representable `unsigned long` value.
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @param endp If not NULL, the address of the first invalid character (i.e.
    /// the next character after the parsed number) will be written to
    /// this pointer.
    /// @param base The base of the integer to read. Supported values are 0 and 2
    /// to 36 inclusive. If 0, the base will be inferred from the
    /// number's prefix (0x for hexadecimal, 0 for octal, decimal
    /// otherwise).
    /// @return the parsed `unsigned long`, or 0 if no number could be parsed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atoi
    /// @see #atof
    /// @see #strtol
    /// @see #strtoll
    /// @see #strtoull
    /// @see #strtod
    /// @see #ultoa
    public long strtoul(
        @Nullable BytePtr str,
        @Nullable PointerPtr endp,
        int base
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strtoul);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (endp != null ? endp.segment() : MemorySegment.NULL),
                base
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse a `long long` from a string.
    ///
    /// If `str` starts with whitespace, then those whitespace characters are
    /// skipped before attempting to parse the number.
    ///
    /// If the parsed number does not fit inside a `long long`, the result is
    /// clamped to the minimum and maximum representable `long long` values.
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @param endp If not NULL, the address of the first invalid character (i.e.
    /// the next character after the parsed number) will be written to
    /// this pointer.
    /// @param base The base of the integer to read. Supported values are 0 and 2
    /// to 36 inclusive. If 0, the base will be inferred from the
    /// number's prefix (0x for hexadecimal, 0 for octal, decimal
    /// otherwise).
    /// @return the parsed `long long`, or 0 if no number could be parsed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atoi
    /// @see #atof
    /// @see #strtol
    /// @see #strtoul
    /// @see #strtoull
    /// @see #strtod
    /// @see #lltoa
    public long strtoll(
        @Nullable BytePtr str,
        @Nullable PointerPtr endp,
        int base
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strtoll);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (endp != null ? endp.segment() : MemorySegment.NULL),
                base
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse an `unsigned long long` from a string.
    ///
    /// If `str` starts with whitespace, then those whitespace characters are
    /// skipped before attempting to parse the number.
    ///
    /// If the parsed number does not fit inside an `unsigned long long`, the
    /// result is clamped to the maximum representable `unsigned long long` value.
    ///
    /// @param str The null-terminated string to read. Must not be NULL.
    /// @param endp If not NULL, the address of the first invalid character (i.e.
    /// the next character after the parsed number) will be written to
    /// this pointer.
    /// @param base The base of the integer to read. Supported values are 0 and 2
    /// to 36 inclusive. If 0, the base will be inferred from the
    /// number's prefix (0x for hexadecimal, 0 for octal, decimal
    /// otherwise).
    /// @return the parsed `unsigned long long`, or 0 if no number could be
    /// parsed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atoi
    /// @see #atof
    /// @see #strtol
    /// @see #strtoll
    /// @see #strtoul
    /// @see #strtod
    /// @see #ulltoa
    public long strtoull(
        @Nullable BytePtr str,
        @Nullable PointerPtr endp,
        int base
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strtoull);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (endp != null ? endp.segment() : MemorySegment.NULL),
                base
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Parse a `double` from a string.
    ///
    /// This function makes fewer guarantees than the C runtime `strtod`:
    ///
    /// - Only decimal notation is guaranteed to be supported. The handling of
    /// scientific and hexadecimal notation is unspecified.
    /// - Whether or not INF and NAN can be parsed is unspecified.
    /// - The precision of the result is unspecified.
    ///
    /// @param str the null-terminated string to read. Must not be NULL.
    /// @param endp if not NULL, the address of the first invalid character (i.e.
    /// the next character after the parsed number) will be written to
    /// this pointer.
    /// @return the parsed `double`, or 0 if no number could be parsed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atoi
    /// @see #atof
    /// @see #strtol
    /// @see #strtoll
    /// @see #strtoul
    /// @see #strtoull
    public double strtod(
        @Nullable BytePtr str,
        @Nullable PointerPtr endp
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strtod);
        try {
            return (double) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (endp != null ? endp.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two null-terminated UTF-8 strings.
    ///
    /// Due to the nature of UTF-8 encoding, this will work with Unicode strings,
    /// since effectively this function just compares bytes until it hits a
    /// null-terminating character. Also due to the nature of UTF-8, this can be
    /// used with SDL_qsort() to put strings in (roughly) alphabetical order.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int strcmp(
        @Nullable BytePtr str1,
        @Nullable BytePtr str2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strcmp);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str1 != null ? str1.segment() : MemorySegment.NULL),
                (MemorySegment) (str2 != null ? str2.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two UTF-8 strings up to a number of bytes.
    ///
    /// Due to the nature of UTF-8 encoding, this will work with Unicode strings,
    /// since effectively this function just compares bytes until it hits a
    /// null-terminating character. Also due to the nature of UTF-8, this can be
    /// used with SDL_qsort() to put strings in (roughly) alphabetical order.
    ///
    /// Note that while this function is intended to be used with UTF-8, it is
    /// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the
    /// limit lands in the middle of a multi-byte UTF-8 sequence, it will only
    /// compare a portion of the final character.
    ///
    /// `maxlen` specifies a maximum number of bytes to compare; if the strings
    /// match to this number of bytes (or both have matched to a null-terminator
    /// character before this number of bytes), they will be considered equal.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @param maxlen the maximum number of _bytes_ to compare.
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int strncmp(
        @Nullable BytePtr str1,
        @Nullable BytePtr str2,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strncmp);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str1 != null ? str1.segment() : MemorySegment.NULL),
                (MemorySegment) (str2 != null ? str2.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two null-terminated UTF-8 strings, case-insensitively.
    ///
    /// This will work with Unicode strings, using a technique called
    /// "case-folding" to handle the vast majority of case-sensitive human
    /// languages regardless of system locale. It can deal with expanding values: a
    /// German Eszett character can compare against two ASCII 's' chars and be
    /// considered a match, for example. A notable exception: it does not handle
    /// the Turkish 'i' character; human language is complicated!
    ///
    /// Since this handles Unicode, it expects the string to be well-formed UTF-8
    /// and not a null-terminated string of arbitrary bytes. Bytes that are not
    /// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), which is to say two strings of random bits may turn out to
    /// match if they convert to the same amount of replacement characters.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int strcasecmp(
        @Nullable BytePtr str1,
        @Nullable BytePtr str2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strcasecmp);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str1 != null ? str1.segment() : MemorySegment.NULL),
                (MemorySegment) (str2 != null ? str2.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compare two UTF-8 strings, case-insensitively, up to a number of bytes.
    ///
    /// This will work with Unicode strings, using a technique called
    /// "case-folding" to handle the vast majority of case-sensitive human
    /// languages regardless of system locale. It can deal with expanding values: a
    /// German Eszett character can compare against two ASCII 's' chars and be
    /// considered a match, for example. A notable exception: it does not handle
    /// the Turkish 'i' character; human language is complicated!
    ///
    /// Since this handles Unicode, it expects the string to be well-formed UTF-8
    /// and not a null-terminated string of arbitrary bytes. Bytes that are not
    /// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
    /// CHARACTER), which is to say two strings of random bits may turn out to
    /// match if they convert to the same amount of replacement characters.
    ///
    /// Note that while this function is intended to be used with UTF-8, `maxlen`
    /// specifies a _byte_ limit! If the limit lands in the middle of a multi-byte
    /// UTF-8 sequence, it may convert a portion of the final character to one or
    /// more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow
    /// a buffer.
    ///
    /// `maxlen` specifies a maximum number of bytes to compare; if the strings
    /// match to this number of bytes (or both have matched to a null-terminator
    /// character before this number of bytes), they will be considered equal.
    ///
    /// @param str1 the first string to compare. NULL is not permitted!
    /// @param str2 the second string to compare. NULL is not permitted!
    /// @param maxlen the maximum number of bytes to compare.
    /// @return less than zero if str1 is "less than" str2, greater than zero if
    /// str1 is "greater than" str2, and zero if the strings match
    /// exactly.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int strncasecmp(
        @Nullable BytePtr str1,
        @Nullable BytePtr str2,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strncasecmp);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str1 != null ? str1.segment() : MemorySegment.NULL),
                (MemorySegment) (str2 != null ? str2.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Searches a string for the first occurence of any character contained in a
    /// breakset, and returns a pointer from the string to that character.
    ///
    /// @param str The null-terminated string to be searched. Must not be NULL, and
    /// must not overlap with `breakset`.
    /// @param breakset A null-terminated string containing the list of characters
    /// to look for. Must not be NULL, and must not overlap with
    /// `str`.
    /// @return A pointer to the location, in str, of the first occurence of a
    /// character present in the breakset, or NULL if none is found.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr strpbrk(
        @Nullable BytePtr str,
        @Nullable BytePtr breakset
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_strpbrk);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL),
                (MemorySegment) (breakset != null ? breakset.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Decode a UTF-8 string, one Unicode codepoint at a time.
    ///
    /// This will return the first Unicode codepoint in the UTF-8 encoded string in
    /// `*pstr`, and then advance `*pstr` past any consumed bytes before returning.
    ///
    /// It will not access more than `*pslen` bytes from the string. `*pslen` will
    /// be adjusted, as well, subtracting the number of bytes consumed.
    ///
    /// `pslen` is allowed to be NULL, in which case the string _must_ be
    /// NULL-terminated, as the function will blindly read until it sees the NULL
    /// char.
    ///
    /// if `*pslen` is zero, it assumes the end of string is reached and returns a
    /// zero codepoint regardless of the contents of the string buffer.
    ///
    /// If the resulting codepoint is zero (a NULL terminator), or `*pslen` is
    /// zero, it will not advance `*pstr` or `*pslen` at all.
    ///
    /// Generally this function is called in a loop until it returns zero,
    /// adjusting its parameters each iteration.
    ///
    /// If an invalid UTF-8 sequence is encountered, this function returns
    /// SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte
    /// (which is to say, a multibyte sequence might produce several
    /// SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid
    /// UTF-8 sequence).
    ///
    /// Several things can generate invalid UTF-8 sequences, including overlong
    /// encodings, the use of UTF-16 surrogate values, and truncated data. Please
    /// refer to
    /// [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
    /// for details.
    ///
    /// @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
    /// @param pslen a pointer to the number of bytes in the string, to be read and
    /// adjusted. NULL is allowed.
    /// @return the first Unicode codepoint in the string.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint32") @Unsigned int stepUTF8(
        @Nullable PointerPtr pstr,
        @Nullable PointerPtr pslen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StepUTF8);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (pstr != null ? pstr.segment() : MemorySegment.NULL),
                (MemorySegment) (pslen != null ? pslen.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Decode a UTF-8 string in reverse, one Unicode codepoint at a time.
    ///
    /// This will go to the start of the previous Unicode codepoint in the string,
    /// move `*pstr` to that location and return that codepoint.
    ///
    /// If `*pstr` is already at the start of the string), it will not advance
    /// `*pstr` at all.
    ///
    /// Generally this function is called in a loop until it returns zero,
    /// adjusting its parameter each iteration.
    ///
    /// If an invalid UTF-8 sequence is encountered, this function returns
    /// SDL_INVALID_UNICODE_CODEPOINT.
    ///
    /// Several things can generate invalid UTF-8 sequences, including overlong
    /// encodings, the use of UTF-16 surrogate values, and truncated data. Please
    /// refer to
    /// [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
    /// for details.
    ///
    /// @param start a pointer to the beginning of the UTF-8 string.
    /// @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
    /// @return the previous Unicode codepoint in the string.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint32") @Unsigned int stepBackUTF8(
        @Nullable BytePtr start,
        @Nullable PointerPtr pstr
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StepBackUTF8);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (start != null ? start.segment() : MemorySegment.NULL),
                (MemorySegment) (pstr != null ? pstr.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a single Unicode codepoint to UTF-8.
    ///
    /// The buffer pointed to by `dst` must be at least 4 bytes long, as this
    /// function may generate between 1 and 4 bytes of output.
    ///
    /// This function returns the first byte _after_ the newly-written UTF-8
    /// sequence, which is useful for encoding multiple codepoints in a loop, or
    /// knowing where to write a NULL-terminator character to end the string (in
    /// either case, plan to have a buffer of _more_ than 4 bytes!).
    ///
    /// If `codepoint` is an invalid value (outside the Unicode range, or a UTF-16
    /// surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the
    /// codepoint instead, and not set an error.
    ///
    /// If `dst` is NULL, this returns NULL immediately without writing to the
    /// pointer and without setting an error.
    ///
    /// @param codepoint a Unicode codepoint to convert to UTF-8.
    /// @param dst the location to write the encoded UTF-8. Must point to at least
    /// 4 bytes!
    /// @return the first byte past the newly-written UTF-8 sequence.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr UCS4ToUTF8(
        @NativeType("Uint32") @Unsigned int codepoint,
        @Nullable BytePtr dst
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UCS4ToUTF8);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                codepoint,
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Seeds the pseudo-random number generator.
    ///
    /// Reusing the seed number will cause SDL_rand() to repeat the same stream of
    /// 'random' numbers.
    ///
    /// @param seed the value to use as a random number seed, or 0 to use
    /// SDL_GetPerformanceCounter().
    ///
    /// @threadsafety This should be called on the same thread that calls
    /// SDL_rand()
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rand
    /// @see #rand_bits
    /// @see #randf
    public void srand(
        @NativeType("Uint64") @Unsigned long seed
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_srand);
        try {
            hFunction.invokeExact(
                seed
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate a pseudo-random number less than n for positive n
    ///
    /// The method used is faster and of better quality than `rand() % n`. Odds are
    /// roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
    /// much worse as n gets bigger.
    ///
    /// Example: to simulate a d6 use `SDL_rand(6) + 1` The +1 converts 0..5 to
    /// 1..6
    ///
    /// If you want to generate a pseudo-random number in the full range of Sint32,
    /// you should use: (Sint32)SDL_rand_bits()
    ///
    /// If you want reproducible output, be sure to initialize with SDL_srand()
    /// first.
    ///
    /// There are no guarantees as to the quality of the random sequence produced,
    /// and this should not be used for security (cryptography, passwords) or where
    /// money is on the line (loot-boxes, casinos). There are many random number
    /// libraries available with different characteristics and you should pick one
    /// of those to meet any serious needs.
    ///
    /// @param n the number of possible outcomes. n must be positive.
    /// @return a random value in the range of [0 .. n-1].
    ///
    /// @threadsafety All calls should be made from a single thread
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #srand
    /// @see #randf
    public @NativeType("Sint32") int rand(
        @NativeType("Sint32") int n
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_rand);
        try {
            return (int) hFunction.invokeExact(
                n
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate a uniform pseudo-random floating point number less than 1.0
    ///
    /// If you want reproducible output, be sure to initialize with SDL_srand()
    /// first.
    ///
    /// There are no guarantees as to the quality of the random sequence produced,
    /// and this should not be used for security (cryptography, passwords) or where
    /// money is on the line (loot-boxes, casinos). There are many random number
    /// libraries available with different characteristics and you should pick one
    /// of those to meet any serious needs.
    ///
    /// @return a random value in the range of [0.0, 1.0).
    ///
    /// @threadsafety All calls should be made from a single thread
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #srand
    /// @see #rand
    public float randf() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_randf);
        try {
            return (float) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate 32 pseudo-random bits.
    ///
    /// You likely want to use SDL_rand() to get a psuedo-random number instead.
    ///
    /// There are no guarantees as to the quality of the random sequence produced,
    /// and this should not be used for security (cryptography, passwords) or where
    /// money is on the line (loot-boxes, casinos). There are many random number
    /// libraries available with different characteristics and you should pick one
    /// of those to meet any serious needs.
    ///
    /// @return a random value in the range of [0-SDL_MAX_UINT32].
    ///
    /// @threadsafety All calls should be made from a single thread
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rand
    /// @see #randf
    /// @see #srand
    public @NativeType("Uint32") @Unsigned int rand_bits() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_rand_bits);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate a pseudo-random number less than n for positive n
    ///
    /// The method used is faster and of better quality than `rand() % n`. Odds are
    /// roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
    /// much worse as n gets bigger.
    ///
    /// Example: to simulate a d6 use `SDL_rand_r(state, 6) + 1` The +1 converts
    /// 0..5 to 1..6
    ///
    /// If you want to generate a pseudo-random number in the full range of Sint32,
    /// you should use: (Sint32)SDL_rand_bits_r(state)
    ///
    /// There are no guarantees as to the quality of the random sequence produced,
    /// and this should not be used for security (cryptography, passwords) or where
    /// money is on the line (loot-boxes, casinos). There are many random number
    /// libraries available with different characteristics and you should pick one
    /// of those to meet any serious needs.
    ///
    /// @param state a pointer to the current random number state, this may not be
    /// NULL.
    /// @param n the number of possible outcomes. n must be positive.
    /// @return a random value in the range of [0 .. n-1].
    ///
    /// @threadsafety This function is thread-safe, as long as the state pointer
    /// isn't shared between threads.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rand
    /// @see #rand_bits_r
    /// @see #randf_r
    public @NativeType("Sint32") int rand_r(
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr state,
        @NativeType("Sint32") int n
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_rand_r);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL),
                n
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate a uniform pseudo-random floating point number less than 1.0
    ///
    /// If you want reproducible output, be sure to initialize with SDL_srand()
    /// first.
    ///
    /// There are no guarantees as to the quality of the random sequence produced,
    /// and this should not be used for security (cryptography, passwords) or where
    /// money is on the line (loot-boxes, casinos). There are many random number
    /// libraries available with different characteristics and you should pick one
    /// of those to meet any serious needs.
    ///
    /// @param state a pointer to the current random number state, this may not be
    /// NULL.
    /// @return a random value in the range of [0.0, 1.0).
    ///
    /// @threadsafety This function is thread-safe, as long as the state pointer
    /// isn't shared between threads.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rand_bits_r
    /// @see #rand_r
    /// @see #randf
    public float randf_r(
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr state
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_randf_r);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate 32 pseudo-random bits.
    ///
    /// You likely want to use SDL_rand_r() to get a psuedo-random number instead.
    ///
    /// There are no guarantees as to the quality of the random sequence produced,
    /// and this should not be used for security (cryptography, passwords) or where
    /// money is on the line (loot-boxes, casinos). There are many random number
    /// libraries available with different characteristics and you should pick one
    /// of those to meet any serious needs.
    ///
    /// @param state a pointer to the current random number state, this may not be
    /// NULL.
    /// @return a random value in the range of [0-SDL_MAX_UINT32].
    ///
    /// @threadsafety This function is thread-safe, as long as the state pointer
    /// isn't shared between threads.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rand_r
    /// @see #randf_r
    public @NativeType("Uint32") @Unsigned int rand_bits_r(
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr state
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_rand_bits_r);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc cosine of `x`.
    ///
    /// The definition of `y = acos(x)` is `x = cos(y)`.
    ///
    /// Domain: `-1 &amp;lt;= x &amp;lt;= 1`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= Pi`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_acosf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return arc cosine of `x`, in radians.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #acosf
    /// @see #asin
    /// @see #cos
    public double acos(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_acos);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc cosine of `x`.
    ///
    /// The definition of `y = acos(x)` is `x = cos(y)`.
    ///
    /// Domain: `-1 &amp;lt;= x &amp;lt;= 1`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= Pi`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_acos for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return arc cosine of `x`, in radians.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #acos
    /// @see #asinf
    /// @see #cosf
    public float acosf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_acosf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc sine of `x`.
    ///
    /// The definition of `y = asin(x)` is `x = sin(y)`.
    ///
    /// Domain: `-1 &amp;lt;= x &amp;lt;= 1`
    ///
    /// Range: `-Pi/2 &amp;lt;= y &amp;lt;= Pi/2`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_asinf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return arc sine of `x`, in radians.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #asinf
    /// @see #acos
    /// @see #sin
    public double asin(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_asin);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc sine of `x`.
    ///
    /// The definition of `y = asin(x)` is `x = sin(y)`.
    ///
    /// Domain: `-1 &amp;lt;= x &amp;lt;= 1`
    ///
    /// Range: `-Pi/2 &amp;lt;= y &amp;lt;= Pi/2`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_asin for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return arc sine of `x`, in radians.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #asin
    /// @see #acosf
    /// @see #sinf
    public float asinf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_asinf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc tangent of `x`.
    ///
    /// The definition of `y = atan(x)` is `x = tan(y)`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-Pi/2 &amp;lt;= y &amp;lt;= Pi/2`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_atanf for single-precision floats.
    ///
    /// To calculate the arc tangent of y / x, use SDL_atan2.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return arc tangent of of `x` in radians, or 0 if `x = 0`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atanf
    /// @see #atan2
    /// @see #tan
    public double atan(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_atan);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc tangent of `x`.
    ///
    /// The definition of `y = atan(x)` is `x = tan(y)`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-Pi/2 &amp;lt;= y &amp;lt;= Pi/2`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_atan for dboule-precision floats.
    ///
    /// To calculate the arc tangent of y / x, use SDL_atan2f.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return arc tangent of of `x` in radians, or 0 if `x = 0`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atan
    /// @see #atan2f
    /// @see #tanf
    public float atanf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_atanf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc tangent of `y / x`, using the signs of x and y to adjust
    /// the result's quadrant.
    ///
    /// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
    /// of z is determined based on the signs of x and y.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// Range: `-Pi/2 &amp;lt;= y &amp;lt;= Pi/2`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_atan2f for single-precision floats.
    ///
    /// To calculate the arc tangent of a single value, use SDL_atan.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param y floating point value of the numerator (y coordinate).
    /// @param x floating point value of the denominator (x coordinate).
    /// @return arc tangent of of `y / x` in radians, or, if `x = 0`, either
    /// `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atan2f
    /// @see #atan
    /// @see #tan
    public double atan2(
        double y,
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_atan2);
        try {
            return (double) hFunction.invokeExact(
                y,
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the arc tangent of `y / x`, using the signs of x and y to adjust
    /// the result's quadrant.
    ///
    /// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
    /// of z is determined based on the signs of x and y.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// Range: `-Pi/2 &amp;lt;= y &amp;lt;= Pi/2`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_atan2 for double-precision floats.
    ///
    /// To calculate the arc tangent of a single value, use SDL_atanf.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param y floating point value of the numerator (y coordinate).
    /// @param x floating point value of the denominator (x coordinate).
    /// @return arc tangent of of `y / x` in radians, or, if `x = 0`, either
    /// `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #atan2
    /// @see #atan
    /// @see #tan
    public float atan2f(
        float y,
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_atan2f);
        try {
            return (float) hFunction.invokeExact(
                y,
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the ceiling of `x`.
    ///
    /// The ceiling of `x` is the smallest integer `y` such that `y &amp;gt; x`, i.e `x`
    /// rounded up to the nearest integer.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_ceilf for single-precision floats.
    ///
    /// @param x floating point value.
    /// @return the ceiling of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #ceilf
    /// @see #floor
    /// @see #trunc
    /// @see #round
    /// @see #lround
    public double ceil(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ceil);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the ceiling of `x`.
    ///
    /// The ceiling of `x` is the smallest integer `y` such that `y &amp;gt; x`, i.e `x`
    /// rounded up to the nearest integer.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_ceil for double-precision floats.
    ///
    /// @param x floating point value.
    /// @return the ceiling of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #ceil
    /// @see #floorf
    /// @see #truncf
    /// @see #roundf
    /// @see #lroundf
    public float ceilf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ceilf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy the sign of one floating-point value to another.
    ///
    /// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, ``-INF &amp;lt;= y &amp;lt;= f``
    ///
    /// Range: `-INF &amp;lt;= z &amp;lt;= INF`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_copysignf for single-precision floats.
    ///
    /// @param x floating point value to use as the magnitude.
    /// @param y floating point value to use as the sign.
    /// @return the floating point value with the sign of y and the magnitude of
    /// x.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #copysignf
    /// @see #fabs
    public double copysign(
        double x,
        double y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_copysign);
        try {
            return (double) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy the sign of one floating-point value to another.
    ///
    /// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, ``-INF &amp;lt;= y &amp;lt;= f``
    ///
    /// Range: `-INF &amp;lt;= z &amp;lt;= INF`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_copysign for double-precision floats.
    ///
    /// @param x floating point value to use as the magnitude.
    /// @param y floating point value to use as the sign.
    /// @return the floating point value with the sign of y and the magnitude of
    /// x.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #copysign
    /// @see #fabsf
    public float copysignf(
        float x,
        float y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_copysignf);
        try {
            return (float) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the cosine of `x`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-1 &amp;lt;= y &amp;lt;= 1`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_cosf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value, in radians.
    /// @return cosine of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #cosf
    /// @see #acos
    /// @see #sin
    public double cos(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_cos);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the cosine of `x`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-1 &amp;lt;= y &amp;lt;= 1`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_cos for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value, in radians.
    /// @return cosine of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #cos
    /// @see #acosf
    /// @see #sinf
    public float cosf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_cosf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the exponential of `x`.
    ///
    /// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
    /// natural logarithm. The inverse is the natural logarithm, SDL_log.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= INF`
    ///
    /// The output will overflow if `exp(x)` is too large to be represented.
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_expf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return value of `e^x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #expf
    /// @see #log
    public double exp(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_exp);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the exponential of `x`.
    ///
    /// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
    /// natural logarithm. The inverse is the natural logarithm, SDL_logf.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= INF`
    ///
    /// The output will overflow if `exp(x)` is too large to be represented.
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_exp for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value.
    /// @return value of `e^x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #exp
    /// @see #logf
    public float expf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_expf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the absolute value of `x`
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_fabsf for single-precision floats.
    ///
    /// @param x floating point value to use as the magnitude.
    /// @return the absolute value of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #fabsf
    public double fabs(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_fabs);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the absolute value of `x`
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_fabs for double-precision floats.
    ///
    /// @param x floating point value to use as the magnitude.
    /// @return the absolute value of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #fabs
    public float fabsf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_fabsf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the floor of `x`.
    ///
    /// The floor of `x` is the largest integer `y` such that `y &amp;gt; x`, i.e `x`
    /// rounded down to the nearest integer.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_floorf for single-precision floats.
    ///
    /// @param x floating point value.
    /// @return the floor of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #floorf
    /// @see #ceil
    /// @see #trunc
    /// @see #round
    /// @see #lround
    public double floor(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_floor);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the floor of `x`.
    ///
    /// The floor of `x` is the largest integer `y` such that `y &amp;gt; x`, i.e `x`
    /// rounded down to the nearest integer.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_floor for double-precision floats.
    ///
    /// @param x floating point value.
    /// @return the floor of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #floor
    /// @see #ceilf
    /// @see #truncf
    /// @see #roundf
    /// @see #lroundf
    public float floorf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_floorf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Truncate `x` to an integer.
    ///
    /// Rounds `x` to the next closest integer to 0. This is equivalent to removing
    /// the fractional part of `x`, leaving only the integer part.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_truncf for single-precision floats.
    ///
    /// @param x floating point value.
    /// @return `x` truncated to an integer.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #truncf
    /// @see #fmod
    /// @see #ceil
    /// @see #floor
    /// @see #round
    /// @see #lround
    public double trunc(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_trunc);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Truncate `x` to an integer.
    ///
    /// Rounds `x` to the next closest integer to 0. This is equivalent to removing
    /// the fractional part of `x`, leaving only the integer part.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_trunc for double-precision floats.
    ///
    /// @param x floating point value.
    /// @return `x` truncated to an integer.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #trunc
    /// @see #fmodf
    /// @see #ceilf
    /// @see #floorf
    /// @see #roundf
    /// @see #lroundf
    public float truncf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_truncf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return the floating-point remainder of `x / y`
    ///
    /// Divides `x` by `y`, and returns the remainder.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `-INF &amp;lt;= y &amp;lt;= INF`, `y != 0`
    ///
    /// Range: `-y &amp;lt;= z &amp;lt;= y`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_fmodf for single-precision floats.
    ///
    /// @param x the numerator.
    /// @param y the denominator. Must not be 0.
    /// @return the remainder of `x / y`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #fmodf
    /// @see #modf
    /// @see #trunc
    /// @see #ceil
    /// @see #floor
    /// @see #round
    /// @see #lround
    public double fmod(
        double x,
        double y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_fmod);
        try {
            return (double) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return the floating-point remainder of `x / y`
    ///
    /// Divides `x` by `y`, and returns the remainder.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `-INF &amp;lt;= y &amp;lt;= INF`, `y != 0`
    ///
    /// Range: `-y &amp;lt;= z &amp;lt;= y`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_fmod for double-precision floats.
    ///
    /// @param x the numerator.
    /// @param y the denominator. Must not be 0.
    /// @return the remainder of `x / y`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #fmod
    /// @see #truncf
    /// @see #modff
    /// @see #ceilf
    /// @see #floorf
    /// @see #roundf
    /// @see #lroundf
    public float fmodf(
        float x,
        float y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_fmodf);
        try {
            return (float) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether the value is infinity.
    ///
    /// @param x double-precision floating point value.
    /// @return non-zero if the value is infinity, 0 otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isinff
    public int isinf(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isinf);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether the value is infinity.
    ///
    /// @param x floating point value.
    /// @return non-zero if the value is infinity, 0 otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isinf
    public int isinff(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isinff);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether the value is NaN.
    ///
    /// @param x double-precision floating point value.
    /// @return non-zero if the value is NaN, 0 otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isnanf
    public int isnan(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isnan);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether the value is NaN.
    ///
    /// @param x floating point value.
    /// @return non-zero if the value is NaN, 0 otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isnan
    public int isnanf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_isnanf);
        try {
            return (int) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the natural logarithm of `x`.
    ///
    /// Domain: `0 &amp;lt; x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// It is an error for `x` to be less than or equal to 0.
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_logf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value. Must be greater than 0.
    /// @return the natural logarithm of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #logf
    /// @see #log10
    /// @see #exp
    public double log(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_log);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the natural logarithm of `x`.
    ///
    /// Domain: `0 &amp;lt; x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// It is an error for `x` to be less than or equal to 0.
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_log for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value. Must be greater than 0.
    /// @return the natural logarithm of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #log
    /// @see #expf
    public float logf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_logf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the base-10 logarithm of `x`.
    ///
    /// Domain: `0 &amp;lt; x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// It is an error for `x` to be less than or equal to 0.
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_log10f for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value. Must be greater than 0.
    /// @return the logarithm of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #log10f
    /// @see #log
    /// @see #pow
    public double log10(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_log10);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the base-10 logarithm of `x`.
    ///
    /// Domain: `0 &amp;lt; x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// It is an error for `x` to be less than or equal to 0.
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_log10 for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value. Must be greater than 0.
    /// @return the logarithm of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #log10
    /// @see #logf
    /// @see #powf
    public float log10f(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_log10f);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Split `x` into integer and fractional parts
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_modff for single-precision floats.
    ///
    /// @param x floating point value.
    /// @param y output pointer to store the integer part of `x`.
    /// @return the fractional part of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #modff
    /// @see #trunc
    /// @see #fmod
    public double modf(
        double x,
        @Nullable DoublePtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_modf);
        try {
            return (double) hFunction.invokeExact(
                x,
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Split `x` into integer and fractional parts
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_modf for double-precision floats.
    ///
    /// @param x floating point value.
    /// @param y output pointer to store the integer part of `x`.
    /// @return the fractional part of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #modf
    /// @see #truncf
    /// @see #fmodf
    public float modff(
        float x,
        @Nullable FloatPtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_modff);
        try {
            return (float) hFunction.invokeExact(
                x,
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Raise `x` to the power `y`
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= z &amp;lt;= INF`
    ///
    /// If `y` is the base of the natural logarithm (e), consider using SDL_exp
    /// instead.
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_powf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x the base.
    /// @param y the exponent.
    /// @return `x` raised to the power `y`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #powf
    /// @see #exp
    /// @see #log
    public double pow(
        double x,
        double y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_pow);
        try {
            return (double) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Raise `x` to the power `y`
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= z &amp;lt;= INF`
    ///
    /// If `y` is the base of the natural logarithm (e), consider using SDL_exp
    /// instead.
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_pow for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x the base.
    /// @param y the exponent.
    /// @return `x` raised to the power `y`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pow
    /// @see #expf
    /// @see #logf
    public float powf(
        float x,
        float y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_powf);
        try {
            return (float) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Round `x` to the nearest integer.
    ///
    /// Rounds `x` to the nearest integer. Values halfway between integers will be
    /// rounded away from zero.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_roundf for single-precision floats. To get the result as an integer
    /// type, use SDL_lround.
    ///
    /// @param x floating point value.
    /// @return the nearest integer to `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #roundf
    /// @see #lround
    /// @see #floor
    /// @see #ceil
    /// @see #trunc
    public double round(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_round);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Round `x` to the nearest integer.
    ///
    /// Rounds `x` to the nearest integer. Values halfway between integers will be
    /// rounded away from zero.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`, y integer
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_round for double-precision floats. To get the result as an integer
    /// type, use SDL_lroundf.
    ///
    /// @param x floating point value.
    /// @return the nearest integer to `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #round
    /// @see #lroundf
    /// @see #floorf
    /// @see #ceilf
    /// @see #truncf
    public float roundf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_roundf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Round `x` to the nearest integer representable as a long
    ///
    /// Rounds `x` to the nearest integer. Values halfway between integers will be
    /// rounded away from zero.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `MIN_LONG &amp;lt;= y &amp;lt;= MAX_LONG`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_lroundf for single-precision floats. To get the result as a
    /// floating-point type, use SDL_round.
    ///
    /// @param x floating point value.
    /// @return the nearest integer to `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lroundf
    /// @see #round
    /// @see #floor
    /// @see #ceil
    /// @see #trunc
    public long lround(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_lround);
        try {
            return (long) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Round `x` to the nearest integer representable as a long
    ///
    /// Rounds `x` to the nearest integer. Values halfway between integers will be
    /// rounded away from zero.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `MIN_LONG &amp;lt;= y &amp;lt;= MAX_LONG`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_lround for double-precision floats. To get the result as a
    /// floating-point type, use SDL_roundf.
    ///
    /// @param x floating point value.
    /// @return the nearest integer to `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lround
    /// @see #roundf
    /// @see #floorf
    /// @see #ceilf
    /// @see #truncf
    public long lroundf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_lroundf);
        try {
            return (long) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Scale `x` by an integer power of two.
    ///
    /// Multiplies `x` by the `n`th power of the floating point radix (always 2).
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `n` integer
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_scalbnf for single-precision floats.
    ///
    /// @param x floating point value to be scaled.
    /// @param n integer exponent.
    /// @return `x * 2^n`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #scalbnf
    /// @see #pow
    public double scalbn(
        double x,
        int n
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_scalbn);
        try {
            return (double) hFunction.invokeExact(
                x,
                n
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Scale `x` by an integer power of two.
    ///
    /// Multiplies `x` by the `n`th power of the floating point radix (always 2).
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`, `n` integer
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_scalbn for double-precision floats.
    ///
    /// @param x floating point value to be scaled.
    /// @param n integer exponent.
    /// @return `x * 2^n`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #scalbn
    /// @see #powf
    public float scalbnf(
        float x,
        int n
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_scalbnf);
        try {
            return (float) hFunction.invokeExact(
                x,
                n
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the sine of `x`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-1 &amp;lt;= y &amp;lt;= 1`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_sinf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value, in radians.
    /// @return sine of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #sinf
    /// @see #asin
    /// @see #cos
    public double sin(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_sin);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the sine of `x`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-1 &amp;lt;= y &amp;lt;= 1`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_sin for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value, in radians.
    /// @return sine of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #sin
    /// @see #asinf
    /// @see #cosf
    public float sinf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_sinf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the square root of `x`.
    ///
    /// Domain: `0 &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_sqrtf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value. Must be greater than or equal to 0.
    /// @return square root of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #sqrtf
    public double sqrt(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_sqrt);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the square root of `x`.
    ///
    /// Domain: `0 &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `0 &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_sqrt for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value. Must be greater than or equal to 0.
    /// @return square root of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #sqrt
    public float sqrtf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_sqrtf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the tangent of `x`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on double-precision floating point values, use
    /// SDL_tanf for single-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value, in radians.
    /// @return tangent of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #tanf
    /// @see #sin
    /// @see #cos
    /// @see #atan
    /// @see #atan2
    public double tan(
        double x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_tan);
        try {
            return (double) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compute the tangent of `x`.
    ///
    /// Domain: `-INF &amp;lt;= x &amp;lt;= INF`
    ///
    /// Range: `-INF &amp;lt;= y &amp;lt;= INF`
    ///
    /// This function operates on single-precision floating point values, use
    /// SDL_tan for double-precision floats.
    ///
    /// This function may use a different approximation across different versions,
    /// platforms and configurations. i.e, it can return a different value given
    /// the same input on different machines or operating systems, or if SDL is
    /// updated.
    ///
    /// @param x floating point value, in radians.
    /// @return tangent of `x`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #tan
    /// @see #sinf
    /// @see #cosf
    /// @see #atanf
    /// @see #atan2f
    public float tanf(
        float x
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_tanf);
        try {
            return (float) hFunction.invokeExact(
                x
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This function allocates a context for the specified character set
    /// conversion.
    ///
    /// @param tocode The target character encoding, must not be NULL.
    /// @param fromcode The source character encoding, must not be NULL.
    /// @return a handle that must be freed with SDL_iconv_close, or
    /// SDL_ICONV_ERROR on failure.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #iconv
    /// @see #iconv_close
    /// @see #iconv_string
    public SDL_iconv_t iconv_open(
        @Nullable BytePtr tocode,
        @Nullable BytePtr fromcode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_iconv_open);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (tocode != null ? tocode.segment() : MemorySegment.NULL),
                (MemorySegment) (fromcode != null ? fromcode.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_iconv_t(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This function frees a context used for character set conversion.
    ///
    /// @param cd The character set conversion handle.
    /// @return 0 on success, or -1 on failure.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #iconv
    /// @see #iconv_open
    /// @see #iconv_string
    public int iconv_close(
        @Nullable SDL_iconv_t cd
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_iconv_close);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (cd != null ? cd.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// This function converts text between encodings, reading from and writing to
    /// a buffer.
    ///
    /// It returns the number of succesful conversions on success. On error,
    /// SDL_ICONV_E2BIG is returned when the output buffer is too small, or
    /// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,
    /// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is
    /// encountered.
    ///
    /// On exit:
    ///
    /// - inbuf will point to the beginning of the next multibyte sequence. On
    /// error, this is the location of the problematic input sequence. On
    /// success, this is the end of the input sequence.
    /// - inbytesleft will be set to the number of bytes left to convert, which
    /// will be 0 on success.
    /// - outbuf will point to the location where to store the next output byte.
    /// - outbytesleft will be set to the number of bytes left in the output
    /// buffer.
    ///
    /// @param cd The character set conversion context, created in
    /// SDL_iconv_open().
    /// @param inbuf Address of variable that points to the first character of the
    /// input sequence.
    /// @param inbytesleft The number of bytes in the input buffer.
    /// @param outbuf Address of variable that points to the output buffer.
    /// @param outbytesleft The number of bytes in the output buffer.
    /// @return the number of conversions on success, or a negative error code.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #iconv_open
    /// @see #iconv_close
    /// @see #iconv_string
    public long iconv(
        @Nullable SDL_iconv_t cd,
        @Nullable PointerPtr inbuf,
        @Nullable PointerPtr inbytesleft,
        @Nullable PointerPtr outbuf,
        @Nullable PointerPtr outbytesleft
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_iconv);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (cd != null ? cd.segment() : MemorySegment.NULL),
                (MemorySegment) (inbuf != null ? inbuf.segment() : MemorySegment.NULL),
                (MemorySegment) (inbytesleft != null ? inbytesleft.segment() : MemorySegment.NULL),
                (MemorySegment) (outbuf != null ? outbuf.segment() : MemorySegment.NULL),
                (MemorySegment) (outbytesleft != null ? outbytesleft.segment() : MemorySegment.NULL)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Helper function to convert a string's encoding in one call.
    ///
    /// This function converts a buffer or string between encodings in one pass.
    ///
    /// The string does not need to be NULL-terminated; this function operates on
    /// the number of bytes specified in `inbytesleft` whether there is a NULL
    /// character anywhere in the buffer.
    ///
    /// The returned string is owned by the caller, and should be passed to
    /// SDL_free when no longer needed.
    ///
    /// @param tocode the character encoding of the output string. Examples are
    /// "UTF-8", "UCS-4", etc.
    /// @param fromcode the character encoding of data in `inbuf`.
    /// @param inbuf the string to convert to a different encoding.
    /// @param inbytesleft the size of the input string _in bytes_.
    /// @return a new string, converted to the new encoding, or NULL on error.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #iconv_open
    /// @see #iconv_close
    /// @see #iconv
    public BytePtr iconv_string(
        @Nullable BytePtr tocode,
        @Nullable BytePtr fromcode,
        @Nullable BytePtr inbuf,
        long inbytesleft
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_iconv_string);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (tocode != null ? tocode.segment() : MemorySegment.NULL),
                (MemorySegment) (fromcode != null ? fromcode.segment() : MemorySegment.NULL),
                (MemorySegment) (inbuf != null ? inbuf.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(inbytesleft)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to create a new SDL_AsyncIO object for reading from
    /// and/or writing to a named file.
    ///
    /// The `mode` string understands the following values:
    ///
    /// - "r": Open a file for reading only. It must exist.
    /// - "w": Open a file for writing only. It will create missing files or
    /// truncate existing ones.
    /// - "r+": Open a file for update both reading and writing. The file must
    /// exist.
    /// - "w+": Create an empty file for both reading and writing. If a file with
    /// the same name already exists its content is erased and the file is
    /// treated as a new empty file.
    ///
    /// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode
    /// for appending, since you specify the position when starting a task.
    ///
    /// This function supports Unicode filenames, but they must be encoded in UTF-8
    /// format, regardless of the underlying operating system.
    ///
    /// This call is _not_ asynchronous; it will open the file before returning,
    /// under the assumption that doing so is generally a fast operation. Future
    /// reads and writes to the opened file will be async, however.
    ///
    /// @param file a UTF-8 string representing the filename to open.
    /// @param mode an ASCII string representing the mode to be used for opening
    /// the file.
    /// @return a pointer to the SDL_AsyncIO structure that is created or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeAsyncIO
    /// @see #readAsyncIO
    /// @see #writeAsyncIO
    public SDL_AsyncIO asyncIOFromFile(
        @Nullable BytePtr file,
        @Nullable BytePtr mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AsyncIOFromFile);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL),
                (MemorySegment) (mode != null ? mode.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_AsyncIO(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the size of the data stream in an SDL_AsyncIO.
    ///
    /// This call is _not_ asynchronous; it assumes that obtaining this info is a
    /// non-blocking operation in most reasonable cases.
    ///
    /// @param asyncio the SDL_AsyncIO to get the size of the data stream from.
    /// @return the size of the data stream in the SDL_IOStream on success or a
    /// negative error code on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Sint64") long getAsyncIOSize(
        @Nullable SDL_AsyncIO asyncio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAsyncIOSize);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (asyncio != null ? asyncio.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start an async read.
    ///
    /// This function reads up to `size` bytes from `offset` position in the data
    /// source to the area pointed at by `ptr`. This function may read less bytes
    /// than requested.
    ///
    /// This function returns as quickly as possible; it does not wait for the read
    /// to complete. On a successful return, this work will continue in the
    /// background. If the work begins, even failure is asynchronous: a failing
    /// return value from this function only means the work couldn't start at all.
    ///
    /// `ptr` must remain available until the work is done, and may be accessed by
    /// the system at any time until then. Do not allocate it on the stack, as this
    /// might take longer than the life of the calling function to complete!
    ///
    /// An SDL_AsyncIOQueue must be specified. The newly-created task will be added
    /// to it when it completes its work.
    ///
    /// @param asyncio a pointer to an SDL_AsyncIO structure.
    /// @param ptr a pointer to a buffer to read data into.
    /// @param offset the position to start reading in the data source.
    /// @param size the number of bytes to read from the data source.
    /// @param queue a queue to add the new SDL_AsyncIO to.
    /// @param userdata an app-defined pointer that will be provided with the task
    /// results.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #writeAsyncIO
    /// @see #createAsyncIOQueue
    public @NativeType("boolean") boolean readAsyncIO(
        @Nullable SDL_AsyncIO asyncio,
        @Pointer(comment="void*") MemorySegment ptr,
        @NativeType("Uint64") @Unsigned long offset,
        @NativeType("Uint64") @Unsigned long size,
        @Nullable SDL_AsyncIOQueue queue,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadAsyncIO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (asyncio != null ? asyncio.segment() : MemorySegment.NULL),
                ptr,
                offset,
                size,
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL),
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start an async write.
    ///
    /// This function writes `size` bytes from `offset` position in the data source
    /// to the area pointed at by `ptr`.
    ///
    /// This function returns as quickly as possible; it does not wait for the
    /// write to complete. On a successful return, this work will continue in the
    /// background. If the work begins, even failure is asynchronous: a failing
    /// return value from this function only means the work couldn't start at all.
    ///
    /// `ptr` must remain available until the work is done, and may be accessed by
    /// the system at any time until then. Do not allocate it on the stack, as this
    /// might take longer than the life of the calling function to complete!
    ///
    /// An SDL_AsyncIOQueue must be specified. The newly-created task will be added
    /// to it when it completes its work.
    ///
    /// @param asyncio a pointer to an SDL_AsyncIO structure.
    /// @param ptr a pointer to a buffer to write data from.
    /// @param offset the position to start writing to the data source.
    /// @param size the number of bytes to write to the data source.
    /// @param queue a queue to add the new SDL_AsyncIO to.
    /// @param userdata an app-defined pointer that will be provided with the task
    /// results.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #readAsyncIO
    /// @see #createAsyncIOQueue
    public @NativeType("boolean") boolean writeAsyncIO(
        @Nullable SDL_AsyncIO asyncio,
        @Pointer(comment="void*") MemorySegment ptr,
        @NativeType("Uint64") @Unsigned long offset,
        @NativeType("Uint64") @Unsigned long size,
        @Nullable SDL_AsyncIOQueue queue,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteAsyncIO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (asyncio != null ? asyncio.segment() : MemorySegment.NULL),
                ptr,
                offset,
                size,
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL),
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close and free any allocated resources for an async I/O object.
    ///
    /// Closing a file is _also_ an asynchronous task! If a write failure were to
    /// happen during the closing process, for example, the task results will
    /// report it as usual.
    ///
    /// Closing a file that has been written to does not guarantee the data has
    /// made it to physical media; it may remain in the operating system's file
    /// cache, for later writing to disk. This means that a successfully-closed
    /// file can be lost if the system crashes or loses power in this small window.
    /// To prevent this, call this function with the `flush` parameter set to true.
    /// This will make the operation take longer, and perhaps increase system load
    /// in general, but a successful result guarantees that the data has made it to
    /// physical storage. Don't use this for temporary files, caches, and
    /// unimportant data, and definitely use it for crucial irreplaceable files,
    /// like game saves.
    ///
    /// This function guarantees that the close will happen after any other pending
    /// tasks to `asyncio`, so it's safe to open a file, start several operations,
    /// close the file immediately, then check for all results later. This function
    /// will not block until the tasks have completed.
    ///
    /// Once this function returns true, `asyncio` is no longer valid, regardless
    /// of any future outcomes. Any completed tasks might still contain this
    /// pointer in their SDL_AsyncIOOutcome data, in case the app was using this
    /// value to track information, but it should not be used again.
    ///
    /// If this function returns false, the close wasn't started at all, and it's
    /// safe to attempt to close again later.
    ///
    /// An SDL_AsyncIOQueue must be specified. The newly-created task will be added
    /// to it when it completes its work.
    ///
    /// @param asyncio a pointer to an SDL_AsyncIO structure to close.
    /// @param flush true if data should sync to disk before the task completes.
    /// @param queue a queue to add the new SDL_AsyncIO to.
    /// @param userdata an app-defined pointer that will be provided with the task
    /// results.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, but two
    /// threads should not attempt to close the same object.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean closeAsyncIO(
        @Nullable SDL_AsyncIO asyncio,
        @NativeType("boolean") boolean flush,
        @Nullable SDL_AsyncIOQueue queue,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseAsyncIO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (asyncio != null ? asyncio.segment() : MemorySegment.NULL),
                flush,
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL),
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a task queue for tracking multiple I/O operations.
    ///
    /// Async I/O operations are assigned to a queue when started. The queue can be
    /// checked for completed tasks thereafter.
    ///
    /// @return a new task queue object or NULL if there was an error; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyAsyncIOQueue
    /// @see #getAsyncIOResult
    /// @see #waitAsyncIOResult
    public SDL_AsyncIOQueue createAsyncIOQueue() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateAsyncIOQueue);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_AsyncIOQueue(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a previously-created async I/O task queue.
    ///
    /// If there are still tasks pending for this queue, this call will block until
    /// those tasks are finished. All those tasks will be deallocated. Their
    /// results will be lost to the app.
    ///
    /// Any pending reads from SDL_LoadFileAsync() that are still in this queue
    /// will have their buffers deallocated by this function, to prevent a memory
    /// leak.
    ///
    /// Once this function is called, the queue is no longer valid and should not
    /// be used, including by other threads that might access it while destruction
    /// is blocking on pending tasks.
    ///
    /// Do not destroy a queue that still has threads waiting on it through
    /// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to
    /// unblock those threads, and take measures (such as SDL_WaitThread()) to make
    /// sure they have finished their wait and won't wait on the queue again.
    ///
    /// @param queue the task queue to destroy.
    ///
    /// @threadsafety It is safe to call this function from any thread, so long as
    /// no other thread is waiting on the queue with
    /// SDL_WaitAsyncIOResult.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void destroyAsyncIOQueue(
        @Nullable SDL_AsyncIOQueue queue
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyAsyncIOQueue);
        try {
            hFunction.invokeExact(
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query an async I/O task queue for completed tasks.
    ///
    /// If a task assigned to this queue has finished, this will return true and
    /// fill in `outcome` with the details of the task. If no task in the queue has
    /// finished, this function will return false. This function does not block.
    ///
    /// If a task has completed, this function will free its resources and the task
    /// pointer will no longer be valid. The task will be removed from the queue.
    ///
    /// It is safe for multiple threads to call this function on the same queue at
    /// once; a completed task will only go to one of the threads.
    ///
    /// @param queue the async I/O task queue to query.
    /// @param outcome details of a finished task will be written here. May not be
    /// NULL.
    /// @return true if a task has completed, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #waitAsyncIOResult
    public @NativeType("boolean") boolean getAsyncIOResult(
        @Nullable SDL_AsyncIOQueue queue,
        @Nullable @Pointer ISDL_AsyncIOOutcome outcome
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAsyncIOResult);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL),
                (MemorySegment) (outcome != null ? outcome.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Block until an async I/O task queue has a completed task.
    ///
    /// This function puts the calling thread to sleep until there a task assigned
    /// to the queue that has finished.
    ///
    /// If a task assigned to the queue has finished, this will return true and
    /// fill in `outcome` with the details of the task. If no task in the queue has
    /// finished, this function will return false.
    ///
    /// If a task has completed, this function will free its resources and the task
    /// pointer will no longer be valid. The task will be removed from the queue.
    ///
    /// It is safe for multiple threads to call this function on the same queue at
    /// once; a completed task will only go to one of the threads.
    ///
    /// Note that by the nature of various platforms, more than one waiting thread
    /// may wake to handle a single task, but only one will obtain it, so
    /// `timeoutMS` is a _maximum_ wait time, and this function may return false
    /// sooner.
    ///
    /// This function may return false if there was a system error, the OS
    /// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was
    /// called to wake up all waiting threads without a finished task.
    ///
    /// A timeout can be used to specify a maximum wait time, but rather than
    /// polling, it is possible to have a timeout of -1 to wait forever, and use
    /// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.
    ///
    /// @param queue the async I/O task queue to wait on.
    /// @param outcome details of a finished task will be written here. May not be
    /// NULL.
    /// @param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait
    /// indefinitely.
    /// @return true if task has completed, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #signalAsyncIOQueue
    public @NativeType("boolean") boolean waitAsyncIOResult(
        @Nullable SDL_AsyncIOQueue queue,
        @Nullable @Pointer ISDL_AsyncIOOutcome outcome,
        @NativeType("Sint32") int timeoutMS
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitAsyncIOResult);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL),
                (MemorySegment) (outcome != null ? outcome.segment() : MemorySegment.NULL),
                timeoutMS
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().
    ///
    /// This will unblock any threads that are sleeping in a call to
    /// SDL_WaitAsyncIOResult for the specified queue, and cause them to return
    /// from that function.
    ///
    /// This can be useful when destroying a queue to make sure nothing is touching
    /// it indefinitely. In this case, once this call completes, the caller should
    /// take measures to make sure any previously-blocked threads have returned
    /// from their wait and will not touch the queue again (perhaps by setting a
    /// flag to tell the threads to terminate and then using SDL_WaitThread() to
    /// make sure they've done so).
    ///
    /// @param queue the async I/O task queue to signal.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #waitAsyncIOResult
    public void signalAsyncIOQueue(
        @Nullable SDL_AsyncIOQueue queue
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SignalAsyncIOQueue);
        try {
            hFunction.invokeExact(
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load all the data from a file path, asynchronously.
    ///
    /// This function returns as quickly as possible; it does not wait for the read
    /// to complete. On a successful return, this work will continue in the
    /// background. If the work begins, even failure is asynchronous: a failing
    /// return value from this function only means the work couldn't start at all.
    ///
    /// The data is allocated with a zero byte at the end (null terminated) for
    /// convenience. This extra byte is not included in SDL_AsyncIOOutcome's
    /// bytes_transferred value.
    ///
    /// This function will allocate the buffer to contain the file. It must be
    /// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field
    /// after completion.
    ///
    /// An SDL_AsyncIOQueue must be specified. The newly-created task will be added
    /// to it when it completes its work.
    ///
    /// @param file the path to read all available data from.
    /// @param queue a queue to add the new SDL_AsyncIO to.
    /// @param userdata an app-defined pointer that will be provided with the task
    /// results.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadFile_IO
    public @NativeType("boolean") boolean loadFileAsync(
        @Nullable BytePtr file,
        @Nullable SDL_AsyncIOQueue queue,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadFileAsync);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL),
                (MemorySegment) (queue != null ? queue.segment() : MemorySegment.NULL),
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Try to lock a spin lock by setting it to a non-zero value.
    ///
    /// ***Please note that spinlocks are dangerous if you don't know what you're
    /// doing. Please be careful using any sort of spinlock!***
    ///
    /// @param lock a pointer to a lock variable.
    /// @return true if the lock succeeded, false if the lock is already held.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockSpinlock
    /// @see #unlockSpinlock
    public @NativeType("boolean") boolean tryLockSpinlock(
        @Nullable @Pointer(comment="SDL_SpinLock") IntPtr lock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TryLockSpinlock);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (lock != null ? lock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock a spin lock by setting it to a non-zero value.
    ///
    /// ***Please note that spinlocks are dangerous if you don't know what you're
    /// doing. Please be careful using any sort of spinlock!***
    ///
    /// @param lock a pointer to a lock variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #tryLockSpinlock
    /// @see #unlockSpinlock
    public void lockSpinlock(
        @Nullable @Pointer(comment="SDL_SpinLock") IntPtr lock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockSpinlock);
        try {
            hFunction.invokeExact(
                (MemorySegment) (lock != null ? lock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlock a spin lock by setting it to 0.
    ///
    /// Always returns immediately.
    ///
    /// ***Please note that spinlocks are dangerous if you don't know what you're
    /// doing. Please be careful using any sort of spinlock!***
    ///
    /// @param lock a pointer to a lock variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockSpinlock
    /// @see #tryLockSpinlock
    public void unlockSpinlock(
        @Nullable @Pointer(comment="SDL_SpinLock") IntPtr lock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockSpinlock);
        try {
            hFunction.invokeExact(
                (MemorySegment) (lock != null ? lock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Insert a memory release barrier (function version).
    ///
    /// Please refer to SDL_MemoryBarrierRelease for details. This is a function
    /// version, which might be useful if you need to use this functionality from a
    /// scripting language, etc. Also, some of the macro versions call this
    /// function behind the scenes, where more heavy lifting can happen inside of
    /// SDL. Generally, though, an app written in C/C++/etc should use the macro
    /// version, as it will be more efficient.
    ///
    /// @threadsafety Obviously this function is safe to use from any thread at any
    /// time, but if you find yourself needing this, you are probably
    /// dealing with some very sensitive code; be careful!
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_MemoryBarrierRelease`
    public void memoryBarrierReleaseFunction() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MemoryBarrierReleaseFunction);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Insert a memory acquire barrier (function version).
    ///
    /// Please refer to SDL_MemoryBarrierRelease for details. This is a function
    /// version, which might be useful if you need to use this functionality from a
    /// scripting language, etc. Also, some of the macro versions call this
    /// function behind the scenes, where more heavy lifting can happen inside of
    /// SDL. Generally, though, an app written in C/C++/etc should use the macro
    /// version, as it will be more efficient.
    ///
    /// @threadsafety Obviously this function is safe to use from any thread at any
    /// time, but if you find yourself needing this, you are probably
    /// dealing with some very sensitive code; be careful!
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_MemoryBarrierAcquire`
    public void memoryBarrierAcquireFunction() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MemoryBarrierAcquireFunction);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an atomic variable to a new value if it is currently an old value.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicInt variable to be modified.
    /// @param oldval the old value.
    /// @param newval the new value.
    /// @return true if the atomic variable was set, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAtomicInt
    /// @see #setAtomicInt
    public @NativeType("boolean") boolean compareAndSwapAtomicInt(
        @Nullable @Pointer ISDL_AtomicInt a,
        int oldval,
        int newval
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CompareAndSwapAtomicInt);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                oldval,
                newval
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an atomic variable to a value.
    ///
    /// This function also acts as a full memory barrier.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicInt variable to be modified.
    /// @param v the desired value.
    /// @return the previous value of the atomic variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAtomicInt
    public int setAtomicInt(
        @Nullable @Pointer ISDL_AtomicInt a,
        int v
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAtomicInt);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                v
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of an atomic variable.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicInt variable.
    /// @return the current value of an atomic variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAtomicInt
    public int getAtomicInt(
        @Nullable @Pointer ISDL_AtomicInt a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAtomicInt);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add to an atomic variable.
    ///
    /// This function also acts as a full memory barrier.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicInt variable to be modified.
    /// @param v the desired value to add.
    /// @return the previous value of the atomic variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_AtomicDecRef`
    /// @see `SDL_AtomicIncRef`
    public int addAtomicInt(
        @Nullable @Pointer ISDL_AtomicInt a,
        int v
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddAtomicInt);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                v
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an atomic variable to a new value if it is currently an old value.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicU32 variable to be modified.
    /// @param oldval the old value.
    /// @param newval the new value.
    /// @return true if the atomic variable was set, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAtomicU32
    /// @see #setAtomicU32
    public @NativeType("boolean") boolean compareAndSwapAtomicU32(
        @Nullable @Pointer ISDL_AtomicU32 a,
        @NativeType("Uint32") @Unsigned int oldval,
        @NativeType("Uint32") @Unsigned int newval
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CompareAndSwapAtomicU32);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                oldval,
                newval
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an atomic variable to a value.
    ///
    /// This function also acts as a full memory barrier.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicU32 variable to be modified.
    /// @param v the desired value.
    /// @return the previous value of the atomic variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAtomicU32
    public @NativeType("Uint32") @Unsigned int setAtomicU32(
        @Nullable @Pointer ISDL_AtomicU32 a,
        @NativeType("Uint32") @Unsigned int v
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAtomicU32);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                v
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of an atomic variable.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to an SDL_AtomicU32 variable.
    /// @return the current value of an atomic variable.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAtomicU32
    public @NativeType("Uint32") @Unsigned int getAtomicU32(
        @Nullable @Pointer ISDL_AtomicU32 a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAtomicU32);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a pointer to a new value if it is currently an old value.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to a pointer.
    /// @param oldval the old pointer value.
    /// @param newval the new pointer value.
    /// @return true if the pointer was set, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #compareAndSwapAtomicInt
    /// @see #getAtomicPointer
    /// @see #setAtomicPointer
    public @NativeType("boolean") boolean compareAndSwapAtomicPointer(
        @Nullable PointerPtr a,
        @Pointer(comment="void*") MemorySegment oldval,
        @Pointer(comment="void*") MemorySegment newval
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CompareAndSwapAtomicPointer);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                oldval,
                newval
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a pointer to a value atomically.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to a pointer.
    /// @param v the desired pointer value.
    /// @return the previous value of the pointer.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #compareAndSwapAtomicPointer
    /// @see #getAtomicPointer
    public @Pointer(comment="void*") MemorySegment setAtomicPointer(
        @Nullable PointerPtr a,
        @Pointer(comment="void*") MemorySegment v
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAtomicPointer);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL),
                v
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of a pointer atomically.
    ///
    /// ***Note: If you don't know what this function is for, you shouldn't use
    /// it!***
    ///
    /// @param a a pointer to a pointer.
    /// @return the current value of a pointer.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #compareAndSwapAtomicPointer
    /// @see #setAtomicPointer
    public @Pointer(comment="void*") MemorySegment getAtomicPointer(
        @Nullable PointerPtr a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAtomicPointer);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the number of built-in audio drivers.
    ///
    /// This function returns a hardcoded number. This never returns a negative
    /// value; if there are no drivers compiled into this build of SDL, this
    /// function returns zero. The presence of a driver in this list does not mean
    /// it will function, it just means SDL is capable of interacting with that
    /// interface. For example, a build of SDL might have esound support, but if
    /// there's no esound server available, SDL's esound driver would fail if used.
    ///
    /// By default, SDL tries all drivers, in its preferred order, until one is
    /// found to be usable.
    ///
    /// @return the number of built-in audio drivers.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioDriver
    public int getNumAudioDrivers() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumAudioDrivers);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the name of a built in audio driver.
    ///
    /// The list of audio drivers is given in the order that they are normally
    /// initialized by default; the drivers that seem more reasonable to choose
    /// first (as far as the SDL developers believe) are earlier in the list.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "alsa",
    /// "coreaudio" or "wasapi". These never have Unicode characters, and are not
    /// meant to be proper names.
    ///
    /// @param index the index of the audio driver; the value ranges from 0 to
    /// SDL_GetNumAudioDrivers() - 1.
    /// @return the name of the audio driver at the requested index, or NULL if an
    /// invalid index was specified.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumAudioDrivers
    public BytePtr getAudioDriver(
        int index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                index
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of the current audio driver.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "alsa",
    /// "coreaudio" or "wasapi". These never have Unicode characters, and are not
    /// meant to be proper names.
    ///
    /// @return the name of the current audio driver or NULL if no driver has been
    /// initialized.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getCurrentAudioDriver() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentAudioDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently-connected audio playback devices.
    ///
    /// This returns of list of available devices that play sound, perhaps to
    /// speakers or headphones ("playback" devices). If you want devices that
    /// record audio, like a microphone ("recording" devices), use
    /// SDL_GetAudioRecordingDevices() instead.
    ///
    /// This only returns a list of physical devices; it will not have any device
    /// IDs returned by SDL_OpenAudioDevice().
    ///
    /// If this function returns NULL, to signify an error, `*count` will be set to
    /// zero.
    ///
    /// @param count a pointer filled in with the number of devices returned, may
    /// be NULL.
    /// @return a 0 terminated array of device instance IDs or NULL on error; call
    /// SDL_GetError() for more information. This should be freed with
    /// SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openAudioDevice
    /// @see #getAudioRecordingDevices
    public @Pointer(comment="SDL_AudioDeviceID") @Unsigned IntPtr getAudioPlaybackDevices(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioPlaybackDevices);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently-connected audio recording devices.
    ///
    /// This returns of list of available devices that record audio, like a
    /// microphone ("recording" devices). If you want devices that play sound,
    /// perhaps to speakers or headphones ("playback" devices), use
    /// SDL_GetAudioPlaybackDevices() instead.
    ///
    /// This only returns a list of physical devices; it will not have any device
    /// IDs returned by SDL_OpenAudioDevice().
    ///
    /// If this function returns NULL, to signify an error, `*count` will be set to
    /// zero.
    ///
    /// @param count a pointer filled in with the number of devices returned, may
    /// be NULL.
    /// @return a 0 terminated array of device instance IDs, or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openAudioDevice
    /// @see #getAudioPlaybackDevices
    public @Pointer(comment="SDL_AudioDeviceID") @Unsigned IntPtr getAudioRecordingDevices(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioRecordingDevices);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the human-readable name of a specific audio device.
    ///
    /// @param devid the instance ID of the device to query.
    /// @return the name of the audio device, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioPlaybackDevices
    /// @see #getAudioRecordingDevices
    public BytePtr getAudioDeviceName(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioDeviceName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                devid
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current audio format of a specific audio device.
    ///
    /// For an opened device, this will report the format the device is currently
    /// using. If the device isn't yet opened, this will report the device's
    /// preferred format (or a reasonable default if this can't be determined).
    ///
    /// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or
    /// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a
    /// reasonable recommendation before opening the system-recommended default
    /// device.
    ///
    /// You can also use this to request the current device buffer size. This is
    /// specified in sample frames and represents the amount of data SDL will feed
    /// to the physical hardware in each chunk. This can be converted to
    /// milliseconds of audio with the following equation:
    ///
    /// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`
    ///
    /// Buffer size is only important if you need low-level control over the audio
    /// playback timing. Most apps do not need this.
    ///
    /// @param devid the instance ID of the device to query.
    /// @param spec on return, will be filled with device details.
    /// @param sample_frames pointer to store device buffer size, in sample frames.
    /// Can be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getAudioDeviceFormat(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Nullable @Pointer ISDL_AudioSpec spec,
        @Nullable IntPtr sample_frames
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioDeviceFormat);
        try {
            return (boolean) hFunction.invokeExact(
                devid,
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL),
                (MemorySegment) (sample_frames != null ? sample_frames.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current channel map of an audio device.
    ///
    /// Channel maps are optional; most things do not need them, instead passing
    /// data in the [order that SDL expects](CategoryAudio{@code channel}-layouts).
    ///
    /// Audio devices usually have no remapping applied. This is represented by
    /// returning NULL, and does not signify an error.
    ///
    /// @param devid the instance ID of the device to query.
    /// @param count On output, set to number of channels in the map. Can be NULL.
    /// @return an array of the current channel mapping, with as many elements as
    /// the current output spec's channels, or NULL if default. This
    /// should be freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamInputChannelMap
    public IntPtr getAudioDeviceChannelMap(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioDeviceChannelMap);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                devid,
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a specific audio device.
    ///
    /// You can open both playback and recording devices through this function.
    /// Playback devices will take data from bound audio streams, mix it, and send
    /// it to the hardware. Recording devices will feed any bound audio streams
    /// with a copy of any incoming data.
    ///
    /// An opened audio device starts out with no audio streams bound. To start
    /// audio playing, bind a stream and supply audio data to it. Unlike SDL2,
    /// there is no audio callback; you only bind audio streams and make sure they
    /// have data flowing into them (however, you can simulate SDL2's semantics
    /// fairly closely by using SDL_OpenAudioDeviceStream instead of this
    /// function).
    ///
    /// If you don't care about opening a specific device, pass a `devid` of either
    /// `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or
    /// `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick
    /// the most reasonable default, and may also switch between physical devices
    /// seamlessly later, if the most reasonable default changes during the
    /// lifetime of this opened device (user changed the default in the OS's system
    /// preferences, the default got unplugged so the system jumped to a new
    /// default, the user plugged in headphones on a mobile device, etc). Unless
    /// you have a good reason to choose a specific device, this is probably what
    /// you want.
    ///
    /// You may request a specific format for the audio device, but there is no
    /// promise the device will honor that request for several reasons. As such,
    /// it's only meant to be a hint as to what data your app will provide. Audio
    /// streams will accept data in whatever format you specify and manage
    /// conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you
    /// the preferred format for the device before opening and the actual format
    /// the device is using after opening.
    ///
    /// It's legal to open the same device ID more than once; each successful open
    /// will generate a new logical SDL_AudioDeviceID that is managed separately
    /// from others on the same physical device. This allows libraries to open a
    /// device separately from the main app and bind its own streams without
    /// conflicting.
    ///
    /// It is also legal to open a device ID returned by a previous call to this
    /// function; doing so just creates another logical device on the same physical
    /// device. This may be useful for making logical groupings of audio streams.
    ///
    /// This function returns the opened device ID on success. This is a new,
    /// unique SDL_AudioDeviceID that represents a logical device.
    ///
    /// Some backends might offer arbitrary devices (for example, a networked audio
    /// protocol that can connect to an arbitrary server). For these, as a change
    /// from SDL2, you should open a default device ID and use an SDL hint to
    /// specify the target if you care, or otherwise let the backend figure out a
    /// reasonable default. Most backends don't offer anything like this, and often
    /// this would be an end user setting an environment variable for their custom
    /// need, and not something an application should specifically manage.
    ///
    /// When done with an audio device, possibly at the end of the app's life, one
    /// should call SDL_CloseAudioDevice() on the returned device id.
    ///
    /// @param devid the device instance id to open, or
    /// SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or
    /// SDL_AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable
    /// default device.
    /// @param spec the requested device configuration. Can be NULL to use
    /// reasonable defaults.
    /// @return the device ID on success or 0 on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeAudioDevice
    /// @see #getAudioDeviceFormat
    public @NativeType("SDL_AudioDeviceID") @Unsigned int openAudioDevice(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Nullable @Pointer ISDL_AudioSpec spec
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenAudioDevice);
        try {
            return (int) hFunction.invokeExact(
                devid,
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine if an audio device is physical (instead of logical).
    ///
    /// An SDL_AudioDeviceID that represents physical hardware is a physical
    /// device; there is one for each piece of hardware that SDL can see. Logical
    /// devices are created by calling SDL_OpenAudioDevice or
    /// SDL_OpenAudioDeviceStream, and while each is associated with a physical
    /// device, there can be any number of logical devices on one physical device.
    ///
    /// For the most part, logical and physical IDs are interchangeable--if you try
    /// to open a logical device, SDL understands to assign that effort to the
    /// underlying physical device, etc. However, it might be useful to know if an
    /// arbitrary device ID is physical or logical. This function reports which.
    ///
    /// This function may return either true or false for invalid device IDs.
    ///
    /// @param devid the device ID to query.
    /// @return true if devid is a physical device, false if it is logical.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isAudioDevicePhysical(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsAudioDevicePhysical);
        try {
            return (boolean) hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine if an audio device is a playback device (instead of recording).
    ///
    /// This function may return either true or false for invalid device IDs.
    ///
    /// @param devid the device ID to query.
    /// @return true if devid is a playback device, false if it is recording.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isAudioDevicePlayback(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsAudioDevicePlayback);
        try {
            return (boolean) hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to pause audio playback on a specified device.
    ///
    /// This function pauses audio processing for a given device. Any bound audio
    /// streams will not progress, and no audio will be generated. Pausing one
    /// device does not prevent other unpaused devices from running.
    ///
    /// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
    /// has to bind a stream before any audio will flow. Pausing a paused device is
    /// a legal no-op.
    ///
    /// Pausing a device can be useful to halt all audio without unbinding all the
    /// audio streams. This might be useful while a game is paused, or a level is
    /// loading, etc.
    ///
    /// Physical devices can not be paused or unpaused, only logical devices
    /// created through SDL_OpenAudioDevice() can be.
    ///
    /// @param devid a device opened by SDL_OpenAudioDevice().
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #resumeAudioDevice
    /// @see #audioDevicePaused
    public @NativeType("boolean") boolean pauseAudioDevice(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PauseAudioDevice);
        try {
            return (boolean) hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to unpause audio playback on a specified device.
    ///
    /// This function unpauses audio processing for a given device that has
    /// previously been paused with SDL_PauseAudioDevice(). Once unpaused, any
    /// bound audio streams will begin to progress again, and audio can be
    /// generated.
    ///
    /// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
    /// has to bind a stream before any audio will flow. Unpausing an unpaused
    /// device is a legal no-op.
    ///
    /// Physical devices can not be paused or unpaused, only logical devices
    /// created through SDL_OpenAudioDevice() can be.
    ///
    /// @param devid a device opened by SDL_OpenAudioDevice().
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #audioDevicePaused
    /// @see #pauseAudioDevice
    public @NativeType("boolean") boolean resumeAudioDevice(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResumeAudioDevice);
        try {
            return (boolean) hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to query if an audio device is paused.
    ///
    /// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
    /// has to bind a stream before any audio will flow.
    ///
    /// Physical devices can not be paused or unpaused, only logical devices
    /// created through SDL_OpenAudioDevice() can be. Physical and invalid device
    /// IDs will report themselves as unpaused here.
    ///
    /// @param devid a device opened by SDL_OpenAudioDevice().
    /// @return true if device is valid and paused, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pauseAudioDevice
    /// @see #resumeAudioDevice
    public @NativeType("boolean") boolean audioDevicePaused(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AudioDevicePaused);
        try {
            return (boolean) hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the gain of an audio device.
    ///
    /// The gain of a device is its volume; a larger gain means a louder output,
    /// with a gain of zero being silence.
    ///
    /// Audio devices default to a gain of 1.0f (no change in output).
    ///
    /// Physical devices may not have their gain changed, only logical devices, and
    /// this function will always return -1.0f when used on physical devices.
    ///
    /// @param devid the audio device to query.
    /// @return the gain of the device or -1.0f on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioDeviceGain
    public float getAudioDeviceGain(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioDeviceGain);
        try {
            return (float) hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Change the gain of an audio device.
    ///
    /// The gain of a device is its volume; a larger gain means a louder output,
    /// with a gain of zero being silence.
    ///
    /// Audio devices default to a gain of 1.0f (no change in output).
    ///
    /// Physical devices may not have their gain changed, only logical devices, and
    /// this function will always return false when used on physical devices. While
    /// it might seem attractive to adjust several logical devices at once in this
    /// way, it would allow an app or library to interfere with another portion of
    /// the program's otherwise-isolated devices.
    ///
    /// This is applied, along with any per-audiostream gain, during playback to
    /// the hardware, and can be continuously changed to create various effects. On
    /// recording devices, this will adjust the gain before passing the data into
    /// an audiostream; that recording audiostream can then adjust its gain further
    /// when outputting the data elsewhere, if it likes, but that second gain is
    /// not applied until the data leaves the audiostream again.
    ///
    /// @param devid the audio device on which to change gain.
    /// @param gain the gain. 1.0f is no change, 0.0f is silence.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioDeviceGain
    public @NativeType("boolean") boolean setAudioDeviceGain(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        float gain
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioDeviceGain);
        try {
            return (boolean) hFunction.invokeExact(
                devid,
                gain
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close a previously-opened audio device.
    ///
    /// The application should close open audio devices once they are no longer
    /// needed.
    ///
    /// This function may block briefly while pending audio data is played by the
    /// hardware, so that applications don't drop the last buffer of data they
    /// supplied if terminating immediately afterwards.
    ///
    /// @param devid an audio device id previously returned by
    /// SDL_OpenAudioDevice().
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openAudioDevice
    public void closeAudioDevice(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseAudioDevice);
        try {
            hFunction.invokeExact(
                devid
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Bind a list of audio streams to an audio device.
    ///
    /// Audio data will flow through any bound streams. For a playback device, data
    /// for all bound streams will be mixed together and fed to the device. For a
    /// recording device, a copy of recorded data will be provided to each bound
    /// stream.
    ///
    /// Audio streams can only be bound to an open device. This operation is
    /// atomic--all streams bound in the same call will start processing at the
    /// same time, so they can stay in sync. Also: either all streams will be bound
    /// or none of them will be.
    ///
    /// It is an error to bind an already-bound stream; it must be explicitly
    /// unbound first.
    ///
    /// Binding a stream to a device will set its output format for playback
    /// devices, and its input format for recording devices, so they match the
    /// device's settings. The caller is welcome to change the other end of the
    /// stream's format at any time with SDL_SetAudioStreamFormat().
    ///
    /// @param devid an audio device to bind a stream to.
    /// @param streams an array of audio streams to bind.
    /// @param num_streams number streams listed in the `streams` array.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindAudioStreams
    /// @see #unbindAudioStream
    /// @see #getAudioStreamDevice
    public @NativeType("boolean") boolean bindAudioStreams(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Nullable @Pointer SDL_AudioStream.Ptr streams,
        int num_streams
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindAudioStreams);
        try {
            return (boolean) hFunction.invokeExact(
                devid,
                (MemorySegment) (streams != null ? streams.segment() : MemorySegment.NULL),
                num_streams
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Bind a single audio stream to an audio device.
    ///
    /// This is a convenience function, equivalent to calling
    /// `SDL_BindAudioStreams(devid, &amp;stream, 1)`.
    ///
    /// @param devid an audio device to bind a stream to.
    /// @param stream an audio stream to bind to a device.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindAudioStreams
    /// @see #unbindAudioStream
    /// @see #getAudioStreamDevice
    public @NativeType("boolean") boolean bindAudioStream(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindAudioStream);
        try {
            return (boolean) hFunction.invokeExact(
                devid,
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unbind a list of audio streams from their audio devices.
    ///
    /// The streams being unbound do not all have to be on the same device. All
    /// streams on the same device will be unbound atomically (data will stop
    /// flowing through all unbound streams on the same device at the same time).
    ///
    /// Unbinding a stream that isn't bound to a device is a legal no-op.
    ///
    /// @param streams an array of audio streams to unbind. Can be NULL or contain
    /// NULL.
    /// @param num_streams number streams listed in the `streams` array.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindAudioStreams
    public void unbindAudioStreams(
        @Nullable @Pointer SDL_AudioStream.Ptr streams,
        int num_streams
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnbindAudioStreams);
        try {
            hFunction.invokeExact(
                (MemorySegment) (streams != null ? streams.segment() : MemorySegment.NULL),
                num_streams
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unbind a single audio stream from its audio device.
    ///
    /// This is a convenience function, equivalent to calling
    /// `SDL_UnbindAudioStreams(&amp;stream, 1)`.
    ///
    /// @param stream an audio stream to unbind from a device. Can be NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindAudioStream
    public void unbindAudioStream(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnbindAudioStream);
        try {
            hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query an audio stream for its currently-bound device.
    ///
    /// This reports the audio device that an audio stream is currently bound to.
    ///
    /// If not bound, or invalid, this returns zero, which is not a valid device
    /// ID.
    ///
    /// @param stream the audio stream to query.
    /// @return the bound audio device, or 0 if not bound or invalid.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindAudioStream
    /// @see #bindAudioStreams
    public @NativeType("SDL_AudioDeviceID") @Unsigned int getAudioStreamDevice(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamDevice);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new audio stream.
    ///
    /// @param src_spec the format details of the input audio.
    /// @param dst_spec the format details of the output audio.
    /// @return a new audio stream on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #putAudioStreamData
    /// @see #getAudioStreamData
    /// @see #getAudioStreamAvailable
    /// @see #flushAudioStream
    /// @see #clearAudioStream
    /// @see #setAudioStreamFormat
    /// @see #destroyAudioStream
    public SDL_AudioStream createAudioStream(
        @Nullable @Pointer ISDL_AudioSpec src_spec,
        @Nullable @Pointer ISDL_AudioSpec dst_spec
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateAudioStream);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (src_spec != null ? src_spec.segment() : MemorySegment.NULL),
                (MemorySegment) (dst_spec != null ? dst_spec.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_AudioStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with an audio stream.
    ///
    /// @param stream the SDL_AudioStream to query.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getAudioStreamProperties(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the current format of an audio stream.
    ///
    /// @param stream the SDL_AudioStream to query.
    /// @param src_spec where to store the input audio format; ignored if NULL.
    /// @param dst_spec where to store the output audio format; ignored if NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamFormat
    public @NativeType("boolean") boolean getAudioStreamFormat(
        @Nullable SDL_AudioStream stream,
        @Nullable @Pointer ISDL_AudioSpec src_spec,
        @Nullable @Pointer ISDL_AudioSpec dst_spec
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamFormat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                (MemorySegment) (src_spec != null ? src_spec.segment() : MemorySegment.NULL),
                (MemorySegment) (dst_spec != null ? dst_spec.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Change the input and output formats of an audio stream.
    ///
    /// Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData
    /// will reflect the new format, and future calls to SDL_PutAudioStreamData
    /// must provide data in the new input formats.
    ///
    /// Data that was previously queued in the stream will still be operated on in
    /// the format that was current when it was added, which is to say you can put
    /// the end of a sound file in one format to a stream, change formats for the
    /// next sound file, and start putting that new data while the previous sound
    /// file is still queued, and everything will still play back correctly.
    ///
    /// If a stream is bound to a device, then the format of the side of the stream
    /// bound to a device cannot be changed (src_spec for recording devices,
    /// dst_spec for playback devices). Attempts to make a change to this side will
    /// be ignored, but this will not report an error. The other side's format can
    /// be changed.
    ///
    /// @param stream the stream the format is being changed.
    /// @param src_spec the new format of the audio input; if NULL, it is not
    /// changed.
    /// @param dst_spec the new format of the audio output; if NULL, it is not
    /// changed.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioStreamFormat
    /// @see #setAudioStreamFrequencyRatio
    public @NativeType("boolean") boolean setAudioStreamFormat(
        @Nullable SDL_AudioStream stream,
        @Nullable @Pointer ISDL_AudioSpec src_spec,
        @Nullable @Pointer ISDL_AudioSpec dst_spec
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamFormat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                (MemorySegment) (src_spec != null ? src_spec.segment() : MemorySegment.NULL),
                (MemorySegment) (dst_spec != null ? dst_spec.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the frequency ratio of an audio stream.
    ///
    /// @param stream the SDL_AudioStream to query.
    /// @return the frequency ratio of the stream or 0.0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamFrequencyRatio
    public float getAudioStreamFrequencyRatio(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamFrequencyRatio);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Change the frequency ratio of an audio stream.
    ///
    /// The frequency ratio is used to adjust the rate at which input data is
    /// consumed. Changing this effectively modifies the speed and pitch of the
    /// audio. A value greater than 1.0 will play the audio faster, and at a higher
    /// pitch. A value less than 1.0 will play the audio slower, and at a lower
    /// pitch.
    ///
    /// This is applied during SDL_GetAudioStreamData, and can be continuously
    /// changed to create various effects.
    ///
    /// @param stream the stream the frequency ratio is being changed.
    /// @param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01
    /// and 100.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioStreamFrequencyRatio
    /// @see #setAudioStreamFormat
    public @NativeType("boolean") boolean setAudioStreamFrequencyRatio(
        @Nullable SDL_AudioStream stream,
        float ratio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamFrequencyRatio);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                ratio
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the gain of an audio stream.
    ///
    /// The gain of a stream is its volume; a larger gain means a louder output,
    /// with a gain of zero being silence.
    ///
    /// Audio streams default to a gain of 1.0f (no change in output).
    ///
    /// @param stream the SDL_AudioStream to query.
    /// @return the gain of the stream or -1.0f on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamGain
    public float getAudioStreamGain(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamGain);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Change the gain of an audio stream.
    ///
    /// The gain of a stream is its volume; a larger gain means a louder output,
    /// with a gain of zero being silence.
    ///
    /// Audio streams default to a gain of 1.0f (no change in output).
    ///
    /// This is applied during SDL_GetAudioStreamData, and can be continuously
    /// changed to create various effects.
    ///
    /// @param stream the stream on which the gain is being changed.
    /// @param gain the gain. 1.0f is no change, 0.0f is silence.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioStreamGain
    public @NativeType("boolean") boolean setAudioStreamGain(
        @Nullable SDL_AudioStream stream,
        float gain
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamGain);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                gain
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current input channel map of an audio stream.
    ///
    /// Channel maps are optional; most things do not need them, instead passing
    /// data in the [order that SDL expects](CategoryAudio{@code channel}-layouts).
    ///
    /// Audio streams default to no remapping applied. This is represented by
    /// returning NULL, and does not signify an error.
    ///
    /// @param stream the SDL_AudioStream to query.
    /// @param count On output, set to number of channels in the map. Can be NULL.
    /// @return an array of the current channel mapping, with as many elements as
    /// the current output spec's channels, or NULL if default. This
    /// should be freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamInputChannelMap
    public IntPtr getAudioStreamInputChannelMap(
        @Nullable SDL_AudioStream stream,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamInputChannelMap);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current output channel map of an audio stream.
    ///
    /// Channel maps are optional; most things do not need them, instead passing
    /// data in the [order that SDL expects](CategoryAudio{@code channel}-layouts).
    ///
    /// Audio streams default to no remapping applied. This is represented by
    /// returning NULL, and does not signify an error.
    ///
    /// @param stream the SDL_AudioStream to query.
    /// @param count On output, set to number of channels in the map. Can be NULL.
    /// @return an array of the current channel mapping, with as many elements as
    /// the current output spec's channels, or NULL if default. This
    /// should be freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamInputChannelMap
    public IntPtr getAudioStreamOutputChannelMap(
        @Nullable SDL_AudioStream stream,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamOutputChannelMap);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the current input channel map of an audio stream.
    ///
    /// Channel maps are optional; most things do not need them, instead passing
    /// data in the [order that SDL expects](CategoryAudio{@code channel}-layouts).
    ///
    /// The input channel map reorders data that is added to a stream via
    /// SDL_PutAudioStreamData. Future calls to SDL_PutAudioStreamData must provide
    /// data in the new channel order.
    ///
    /// Each item in the array represents an input channel, and its value is the
    /// channel that it should be remapped to. To reverse a stereo signal's left
    /// and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
    /// multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
    /// right channel to both channels of a stereo signal. An element in the
    /// channel map set to -1 instead of a valid channel will mute that channel,
    /// setting it to a silence value.
    ///
    /// You cannot change the number of channels through a channel map, just
    /// reorder/mute them.
    ///
    /// Data that was previously queued in the stream will still be operated on in
    /// the order that was current when it was added, which is to say you can put
    /// the end of a sound file in one order to a stream, change orders for the
    /// next sound file, and start putting that new data while the previous sound
    /// file is still queued, and everything will still play back correctly.
    ///
    /// Audio streams default to no remapping applied. Passing a NULL channel map
    /// is legal, and turns off remapping.
    ///
    /// SDL will copy the channel map; the caller does not have to save this array
    /// after this call.
    ///
    /// If `count` is not equal to the current number of channels in the audio
    /// stream's format, this will fail. This is a safety measure to make sure a
    /// race condition hasn't changed the format while this call is setting the
    /// channel map.
    ///
    /// Unlike attempting to change the stream's format, the input channel map on a
    /// stream bound to a recording device is permitted to change at any time; any
    /// data added to the stream from the device after this call will have the new
    /// mapping, but previously-added data will still have the prior mapping.
    ///
    /// @param stream the SDL_AudioStream to change.
    /// @param chmap the new channel map, NULL to reset to default.
    /// @param count The number of channels in the map.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running. Don't change the
    /// stream's format to have a different number of channels from a
    /// a different thread at the same time, though!
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamInputChannelMap
    public @NativeType("boolean") boolean setAudioStreamInputChannelMap(
        @Nullable SDL_AudioStream stream,
        @Nullable IntPtr chmap,
        int count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamInputChannelMap);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                (MemorySegment) (chmap != null ? chmap.segment() : MemorySegment.NULL),
                count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the current output channel map of an audio stream.
    ///
    /// Channel maps are optional; most things do not need them, instead passing
    /// data in the [order that SDL expects](CategoryAudio{@code channel}-layouts).
    ///
    /// The output channel map reorders data that leaving a stream via
    /// SDL_GetAudioStreamData.
    ///
    /// Each item in the array represents an input channel, and its value is the
    /// channel that it should be remapped to. To reverse a stereo signal's left
    /// and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
    /// multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
    /// right channel to both channels of a stereo signal. An element in the
    /// channel map set to -1 instead of a valid channel will mute that channel,
    /// setting it to a silence value.
    ///
    /// You cannot change the number of channels through a channel map, just
    /// reorder/mute them.
    ///
    /// The output channel map can be changed at any time, as output remapping is
    /// applied during SDL_GetAudioStreamData.
    ///
    /// Audio streams default to no remapping applied. Passing a NULL channel map
    /// is legal, and turns off remapping.
    ///
    /// SDL will copy the channel map; the caller does not have to save this array
    /// after this call.
    ///
    /// If `count` is not equal to the current number of channels in the audio
    /// stream's format, this will fail. This is a safety measure to make sure a
    /// race condition hasn't changed the format while this call is setting the
    /// channel map.
    ///
    /// Unlike attempting to change the stream's format, the output channel map on
    /// a stream bound to a recording device is permitted to change at any time;
    /// any data added to the stream after this call will have the new mapping, but
    /// previously-added data will still have the prior mapping. When the channel
    /// map doesn't match the hardware's channel layout, SDL will convert the data
    /// before feeding it to the device for playback.
    ///
    /// @param stream the SDL_AudioStream to change.
    /// @param chmap the new channel map, NULL to reset to default.
    /// @param count The number of channels in the map.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as it holds
    /// a stream-specific mutex while running. Don't change the
    /// stream's format to have a different number of channels from a
    /// a different thread at the same time, though!
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamInputChannelMap
    public @NativeType("boolean") boolean setAudioStreamOutputChannelMap(
        @Nullable SDL_AudioStream stream,
        @Nullable IntPtr chmap,
        int count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamOutputChannelMap);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                (MemorySegment) (chmap != null ? chmap.segment() : MemorySegment.NULL),
                count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add data to the stream.
    ///
    /// This data must match the format/channels/samplerate specified in the latest
    /// call to SDL_SetAudioStreamFormat, or the format specified when creating the
    /// stream if it hasn't been changed.
    ///
    /// Note that this call simply copies the unconverted data for later. This is
    /// different than SDL2, where data was converted during the Put call and the
    /// Get call would just dequeue the previously-converted data.
    ///
    /// @param stream the stream the audio data is being added to.
    /// @param buf a pointer to the audio data to add.
    /// @param len the number of bytes to write to the stream.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, but if the
    /// stream has a callback set, the caller might need to manage
    /// extra locking.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #clearAudioStream
    /// @see #flushAudioStream
    /// @see #getAudioStreamData
    /// @see #getAudioStreamQueued
    public @NativeType("boolean") boolean putAudioStreamData(
        @Nullable SDL_AudioStream stream,
        @Pointer(comment="void*") MemorySegment buf,
        int len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PutAudioStreamData);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                buf,
                len
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get converted/resampled data from the stream.
    ///
    /// The input/output data format/channels/samplerate is specified when creating
    /// the stream, and can be changed after creation by calling
    /// SDL_SetAudioStreamFormat.
    ///
    /// Note that any conversion and resampling necessary is done during this call,
    /// and SDL_PutAudioStreamData simply queues unconverted data for later. This
    /// is different than SDL2, where that work was done while inputting new data
    /// to the stream and requesting the output just copied the converted data.
    ///
    /// @param stream the stream the audio is being requested from.
    /// @param buf a buffer to fill with audio data.
    /// @param len the maximum number of bytes to fill.
    /// @return the number of bytes read from the stream or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread, but if the
    /// stream has a callback set, the caller might need to manage
    /// extra locking.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #clearAudioStream
    /// @see #getAudioStreamAvailable
    /// @see #putAudioStreamData
    public int getAudioStreamData(
        @Nullable SDL_AudioStream stream,
        @Pointer(comment="void*") MemorySegment buf,
        int len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamData);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                buf,
                len
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of converted/resampled bytes available.
    ///
    /// The stream may be buffering data behind the scenes until it has enough to
    /// resample correctly, so this number might be lower than what you expect, or
    /// even be zero. Add more data or flush the stream if you need the data now.
    ///
    /// If the stream has so much data that it would overflow an int, the return
    /// value is clamped to a maximum value, but no queued data is lost; if there
    /// are gigabytes of data queued, the app might need to read some of it with
    /// SDL_GetAudioStreamData before this function's return value is no longer
    /// clamped.
    ///
    /// @param stream the audio stream to query.
    /// @return the number of converted/resampled bytes available or -1 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioStreamData
    /// @see #putAudioStreamData
    public int getAudioStreamAvailable(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamAvailable);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of bytes currently queued.
    ///
    /// This is the number of bytes put into a stream as input, not the number that
    /// can be retrieved as output. Because of several details, it's not possible
    /// to calculate one number directly from the other. If you need to know how
    /// much usable data can be retrieved right now, you should use
    /// SDL_GetAudioStreamAvailable() and not this function.
    ///
    /// Note that audio streams can change their input format at any time, even if
    /// there is still data queued in a different format, so the returned byte
    /// count will not necessarily match the number of _sample frames_ available.
    /// Users of this API should be aware of format changes they make when feeding
    /// a stream and plan accordingly.
    ///
    /// Queued data is not converted until it is consumed by
    /// SDL_GetAudioStreamData, so this value should be representative of the exact
    /// data that was put into the stream.
    ///
    /// If the stream has so much data that it would overflow an int, the return
    /// value is clamped to a maximum value, but no queued data is lost; if there
    /// are gigabytes of data queued, the app might need to read some of it with
    /// SDL_GetAudioStreamData before this function's return value is no longer
    /// clamped.
    ///
    /// @param stream the audio stream to query.
    /// @return the number of bytes queued or -1 on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #putAudioStreamData
    /// @see #clearAudioStream
    public int getAudioStreamQueued(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioStreamQueued);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Tell the stream that you're done sending data, and anything being buffered
    /// should be converted/resampled and made available immediately.
    ///
    /// It is legal to add more data to a stream after flushing, but there may be
    /// audio gaps in the output. Generally this is intended to signal the end of
    /// input, so the complete output becomes available.
    ///
    /// @param stream the audio stream to flush.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #putAudioStreamData
    public @NativeType("boolean") boolean flushAudioStream(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlushAudioStream);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear any pending data in the stream.
    ///
    /// This drops any queued data, so there will be nothing to read from the
    /// stream until more is added.
    ///
    /// @param stream the audio stream to clear.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioStreamAvailable
    /// @see #getAudioStreamData
    /// @see #getAudioStreamQueued
    /// @see #putAudioStreamData
    public @NativeType("boolean") boolean clearAudioStream(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClearAudioStream);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to pause audio playback on the audio device associated
    /// with an audio stream.
    ///
    /// This function pauses audio processing for a given device. Any bound audio
    /// streams will not progress, and no audio will be generated. Pausing one
    /// device does not prevent other unpaused devices from running.
    ///
    /// Pausing a device can be useful to halt all audio without unbinding all the
    /// audio streams. This might be useful while a game is paused, or a level is
    /// loading, etc.
    ///
    /// @param stream the audio stream associated with the audio device to pause.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #resumeAudioStreamDevice
    public @NativeType("boolean") boolean pauseAudioStreamDevice(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PauseAudioStreamDevice);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to unpause audio playback on the audio device associated
    /// with an audio stream.
    ///
    /// This function unpauses audio processing for a given device that has
    /// previously been paused. Once unpaused, any bound audio streams will begin
    /// to progress again, and audio can be generated.
    ///
    /// Remember, SDL_OpenAudioDeviceStream opens device in a paused state, so this
    /// function call is required for audio playback to begin on such device.
    ///
    /// @param stream the audio stream associated with the audio device to resume.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pauseAudioStreamDevice
    public @NativeType("boolean") boolean resumeAudioStreamDevice(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResumeAudioStreamDevice);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to query if an audio device associated with a stream is
    /// paused.
    ///
    /// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
    /// has to bind a stream before any audio will flow.
    ///
    /// @param stream the audio stream associated with the audio device to query.
    /// @return true if device is valid and paused, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pauseAudioStreamDevice
    /// @see #resumeAudioStreamDevice
    public @NativeType("boolean") boolean audioStreamDevicePaused(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AudioStreamDevicePaused);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock an audio stream for serialized access.
    ///
    /// Each SDL_AudioStream has an internal mutex it uses to protect its data
    /// structures from threading conflicts. This function allows an app to lock
    /// that mutex, which could be useful if registering callbacks on this stream.
    ///
    /// One does not need to lock a stream to use in it most cases, as the stream
    /// manages this lock internally. However, this lock is held during callbacks,
    /// which may run from arbitrary threads at any time, so if an app needs to
    /// protect shared data during those callbacks, locking the stream guarantees
    /// that the callback is not running while the lock is held.
    ///
    /// As this is just a wrapper over SDL_LockMutex for an internal lock; it has
    /// all the same attributes (recursive locks are allowed, etc).
    ///
    /// @param stream the audio stream to lock.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #unlockAudioStream
    public @NativeType("boolean") boolean lockAudioStream(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockAudioStream);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlock an audio stream for serialized access.
    ///
    /// This unlocks an audio stream after a call to SDL_LockAudioStream.
    ///
    /// @param stream the audio stream to unlock.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety You should only call this from the same thread that
    /// previously called SDL_LockAudioStream.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockAudioStream
    public @NativeType("boolean") boolean unlockAudioStream(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockAudioStream);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a callback that runs when data is requested from an audio stream.
    ///
    /// This callback is called _before_ data is obtained from the stream, giving
    /// the callback the chance to add more on-demand.
    ///
    /// The callback can (optionally) call SDL_PutAudioStreamData() to add more
    /// audio to the stream during this call; if needed, the request that triggered
    /// this callback will obtain the new data immediately.
    ///
    /// The callback's `additional_amount` argument is roughly how many bytes of
    /// _unconverted_ data (in the stream's input format) is needed by the caller,
    /// although this may overestimate a little for safety. This takes into account
    /// how much is already in the stream and only asks for any extra necessary to
    /// resolve the request, which means the callback may be asked for zero bytes,
    /// and a different amount on each call.
    ///
    /// The callback is not required to supply exact amounts; it is allowed to
    /// supply too much or too little or none at all. The caller will get what's
    /// available, up to the amount they requested, regardless of this callback's
    /// outcome.
    ///
    /// Clearing or flushing an audio stream does not call this callback.
    ///
    /// This function obtains the stream's lock, which means any existing callback
    /// (get or put) in progress will finish running before setting the new
    /// callback.
    ///
    /// Setting a NULL function turns off the callback.
    ///
    /// @param stream the audio stream to set the new callback on.
    /// @param callback the new callback function to call when data is requested
    /// from the stream.
    /// @param userdata an opaque pointer provided to the callback for its own
    /// personal use.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information. This only fails if `stream` is NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamPutCallback
    public @NativeType("boolean") boolean setAudioStreamGetCallback(
        @Nullable SDL_AudioStream stream,
        @Pointer(comment="SDL_AudioStreamCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamGetCallback);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a callback that runs when data is added to an audio stream.
    ///
    /// This callback is called _after_ the data is added to the stream, giving the
    /// callback the chance to obtain it immediately.
    ///
    /// The callback can (optionally) call SDL_GetAudioStreamData() to obtain audio
    /// from the stream during this call.
    ///
    /// The callback's `additional_amount` argument is how many bytes of
    /// _converted_ data (in the stream's output format) was provided by the
    /// caller, although this may underestimate a little for safety. This value
    /// might be less than what is currently available in the stream, if data was
    /// already there, and might be less than the caller provided if the stream
    /// needs to keep a buffer to aid in resampling. Which means the callback may
    /// be provided with zero bytes, and a different amount on each call.
    ///
    /// The callback may call SDL_GetAudioStreamAvailable to see the total amount
    /// currently available to read from the stream, instead of the total provided
    /// by the current call.
    ///
    /// The callback is not required to obtain all data. It is allowed to read less
    /// or none at all. Anything not read now simply remains in the stream for
    /// later access.
    ///
    /// Clearing or flushing an audio stream does not call this callback.
    ///
    /// This function obtains the stream's lock, which means any existing callback
    /// (get or put) in progress will finish running before setting the new
    /// callback.
    ///
    /// Setting a NULL function turns off the callback.
    ///
    /// @param stream the audio stream to set the new callback on.
    /// @param callback the new callback function to call when data is added to the
    /// stream.
    /// @param userdata an opaque pointer provided to the callback for its own
    /// personal use.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information. This only fails if `stream` is NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAudioStreamGetCallback
    public @NativeType("boolean") boolean setAudioStreamPutCallback(
        @Nullable SDL_AudioStream stream,
        @Pointer(comment="SDL_AudioStreamCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioStreamPutCallback);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free an audio stream.
    ///
    /// This will release all allocated data, including any audio that is still
    /// queued. You do not need to manually clear the stream first.
    ///
    /// If this stream was bound to an audio device, it is unbound during this
    /// call. If this stream was created with SDL_OpenAudioDeviceStream, the audio
    /// device that was opened alongside this stream's creation will be closed,
    /// too.
    ///
    /// @param stream the audio stream to destroy.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createAudioStream
    public void destroyAudioStream(
        @Nullable SDL_AudioStream stream
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyAudioStream);
        try {
            hFunction.invokeExact(
                (MemorySegment) (stream != null ? stream.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convenience function for straightforward audio init for the common case.
    ///
    /// If all your app intends to do is provide a single source of PCM audio, this
    /// function allows you to do all your audio setup in a single call.
    ///
    /// This is also intended to be a clean means to migrate apps from SDL2.
    ///
    /// This function will open an audio device, create a stream and bind it.
    /// Unlike other methods of setup, the audio device will be closed when this
    /// stream is destroyed, so the app can treat the returned SDL_AudioStream as
    /// the only object needed to manage audio playback.
    ///
    /// Also unlike other functions, the audio device begins paused. This is to map
    /// more closely to SDL2-style behavior, since there is no extra step here to
    /// bind a stream to begin audio flowing. The audio device should be resumed
    /// with `SDL_ResumeAudioStreamDevice(stream);`
    ///
    /// This function works with both playback and recording devices.
    ///
    /// The `spec` parameter represents the app's side of the audio stream. That
    /// is, for recording audio, this will be the output format, and for playing
    /// audio, this will be the input format. If spec is NULL, the system will
    /// choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain
    /// this information later.
    ///
    /// If you don't care about opening a specific audio device, you can (and
    /// probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
    /// SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.
    ///
    /// One can optionally provide a callback function; if NULL, the app is
    /// expected to queue audio data for playback (or unqueue audio data if
    /// capturing). Otherwise, the callback will begin to fire once the device is
    /// unpaused.
    ///
    /// Destroying the returned stream with SDL_DestroyAudioStream will also close
    /// the audio device associated with this stream.
    ///
    /// @param devid an audio device to open, or SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK
    /// or SDL_AUDIO_DEVICE_DEFAULT_RECORDING.
    /// @param spec the audio stream's data format. Can be NULL.
    /// @param callback a callback where the app will provide new data for
    /// playback, or receive new data for recording. Can be NULL,
    /// in which case the app will need to call
    /// SDL_PutAudioStreamData or SDL_GetAudioStreamData as
    /// necessary.
    /// @param userdata app-controlled pointer passed to callback. Can be NULL.
    /// Ignored if callback is NULL.
    /// @return an audio stream on success, ready to use, or NULL on failure; call
    /// SDL_GetError() for more information. When done with this stream,
    /// call SDL_DestroyAudioStream to free resources and close the
    /// device.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAudioStreamDevice
    /// @see #resumeAudioStreamDevice
    public SDL_AudioStream openAudioDeviceStream(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Nullable @Pointer ISDL_AudioSpec spec,
        @Pointer(comment="SDL_AudioStreamCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenAudioDeviceStream);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                devid,
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_AudioStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a callback that fires when data is about to be fed to an audio device.
    ///
    /// This is useful for accessing the final mix, perhaps for writing a
    /// visualizer or applying a final effect to the audio data before playback.
    ///
    /// The buffer is the final mix of all bound audio streams on an opened device;
    /// this callback will fire regularly for any device that is both opened and
    /// unpaused. If there is no new data to mix, either because no streams are
    /// bound to the device or all the streams are empty, this callback will still
    /// fire with the entire buffer set to silence.
    ///
    /// This callback is allowed to make changes to the data; the contents of the
    /// buffer after this call is what is ultimately passed along to the hardware.
    ///
    /// The callback is always provided the data in float format (values from -1.0f
    /// to 1.0f), but the number of channels or sample rate may be different than
    /// the format the app requested when opening the device; SDL might have had to
    /// manage a conversion behind the scenes, or the playback might have jumped to
    /// new physical hardware when a system default changed, etc. These details may
    /// change between calls. Accordingly, the size of the buffer might change
    /// between calls as well.
    ///
    /// This callback can run at any time, and from any thread; if you need to
    /// serialize access to your app's data, you should provide and use a mutex or
    /// other synchronization device.
    ///
    /// All of this to say: there are specific needs this callback can fulfill, but
    /// it is not the simplest interface. Apps should generally provide audio in
    /// their preferred format through an SDL_AudioStream and let SDL handle the
    /// difference.
    ///
    /// This function is extremely time-sensitive; the callback should do the least
    /// amount of work possible and return as quickly as it can. The longer the
    /// callback runs, the higher the risk of audio dropouts or other problems.
    ///
    /// This function will block until the audio device is in between iterations,
    /// so any existing callback that might be running will finish before this
    /// function sets the new callback and returns.
    ///
    /// Setting a NULL callback function disables any previously-set callback.
    ///
    /// @param devid the ID of an opened audio device.
    /// @param callback a callback function to be called. Can be NULL.
    /// @param userdata app-controlled pointer passed to callback. Can be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setAudioPostmixCallback(
        @NativeType("SDL_AudioDeviceID") @Unsigned int devid,
        @Pointer(comment="SDL_AudioPostmixCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAudioPostmixCallback);
        try {
            return (boolean) hFunction.invokeExact(
                devid,
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load the audio data of a WAVE file into memory.
    ///
    /// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
    /// be valid pointers. The entire data portion of the file is then loaded into
    /// memory and decoded if necessary.
    ///
    /// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
    /// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
    /// A-law and mu-law (8 bits). Other formats are currently unsupported and
    /// cause an error.
    ///
    /// If this function succeeds, the return value is zero and the pointer to the
    /// audio data allocated by the function is written to `audio_buf` and its
    /// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,
    /// `channels`, and `format` are set to the values of the audio data in the
    /// buffer.
    ///
    /// It's necessary to use SDL_free() to free the audio data returned in
    /// `audio_buf` when it is no longer used.
    ///
    /// Because of the underspecification of the .WAV format, there are many
    /// problematic files in the wild that cause issues with strict decoders. To
    /// provide compatibility with these files, this decoder is lenient in regards
    /// to the truncation of the file, the fact chunk, and the size of the RIFF
    /// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
    /// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
    /// tune the behavior of the loading process.
    ///
    /// Any file that is invalid (due to truncation, corruption, or wrong values in
    /// the headers), too big, or unsupported causes an error. Additionally, any
    /// critical I/O error from the data source will terminate the loading process
    /// with an error. The function returns NULL on error and in all cases (with
    /// the exception of `src` being NULL), an appropriate error message will be
    /// set.
    ///
    /// It is required that the data source supports seeking.
    ///
    /// Example:
    ///
    /// ```c
    /// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, &amp;spec, &amp;buf, &amp;len);
    /// ```
    ///
    /// Note that the SDL_LoadWAV function does this same thing for you, but in a
    /// less messy way:
    ///
    /// ```c
    /// SDL_LoadWAV("sample.wav", &amp;spec, &amp;buf, &amp;len);
    /// ```
    ///
    /// @param src the data source for the WAVE data.
    /// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
    /// in the case of an error.
    /// @param spec a pointer to an SDL_AudioSpec that will be set to the WAVE
    /// data's format details on successful return.
    /// @param audio_buf a pointer filled with the audio data, allocated by the
    /// function.
    /// @param audio_len a pointer filled with the length of the audio data buffer
    /// in bytes.
    /// @return true on success. `audio_buf` will be filled with a pointer to an
    /// allocated buffer containing the audio data, and `audio_len` is
    /// filled with the length of that audio buffer in bytes.
    ///
    /// This function returns false if the .WAV file cannot be opened,
    /// uses an unknown data format, or is corrupt; call SDL_GetError()
    /// for more information.
    ///
    /// When the application is done with the data returned in
    /// `audio_buf`, it should call SDL_free() to dispose of it.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #free
    /// @see #loadWAV
    public @NativeType("boolean") boolean loadWAV_IO(
        @Nullable SDL_IOStream src,
        @NativeType("boolean") boolean closeio,
        @Nullable @Pointer ISDL_AudioSpec spec,
        @Nullable PointerPtr audio_buf,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr audio_len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadWAV_IO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                closeio,
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL),
                (MemorySegment) (audio_buf != null ? audio_buf.segment() : MemorySegment.NULL),
                (MemorySegment) (audio_len != null ? audio_len.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Loads a WAV from a file path.
    ///
    /// This is a convenience function that is effectively the same as:
    ///
    /// ```c
    /// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);
    /// ```
    ///
    /// @param path the file path of the WAV file to open.
    /// @param spec a pointer to an SDL_AudioSpec that will be set to the WAVE
    /// data's format details on successful return.
    /// @param audio_buf a pointer filled with the audio data, allocated by the
    /// function.
    /// @param audio_len a pointer filled with the length of the audio data buffer
    /// in bytes.
    /// @return true on success. `audio_buf` will be filled with a pointer to an
    /// allocated buffer containing the audio data, and `audio_len` is
    /// filled with the length of that audio buffer in bytes.
    ///
    /// This function returns false if the .WAV file cannot be opened,
    /// uses an unknown data format, or is corrupt; call SDL_GetError()
    /// for more information.
    ///
    /// When the application is done with the data returned in
    /// `audio_buf`, it should call SDL_free() to dispose of it.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #free
    /// @see #loadWAV_IO
    public @NativeType("boolean") boolean loadWAV(
        @Nullable BytePtr path,
        @Nullable @Pointer ISDL_AudioSpec spec,
        @Nullable PointerPtr audio_buf,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr audio_len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadWAV);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL),
                (MemorySegment) (audio_buf != null ? audio_buf.segment() : MemorySegment.NULL),
                (MemorySegment) (audio_len != null ? audio_len.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Mix audio data in a specified format.
    ///
    /// This takes an audio buffer `src` of `len` bytes of `format` data and mixes
    /// it into `dst`, performing addition, volume adjustment, and overflow
    /// clipping. The buffer pointed to by `dst` must also be `len` bytes of
    /// `format` data.
    ///
    /// This is provided for convenience -- you can mix your own audio data.
    ///
    /// Do not use this function for mixing together more than two streams of
    /// sample data. The output from repeated application of this function may be
    /// distorted by clipping, because there is no accumulator with greater range
    /// than the input (not to mention this being an inefficient way of doing it).
    ///
    /// It is a common misconception that this function is required to write audio
    /// data to an output stream in an audio callback. While you can do that,
    /// SDL_MixAudio() is really only needed when you're mixing a single audio
    /// stream with a volume adjustment.
    ///
    /// @param dst the destination for the mixed audio.
    /// @param src the source audio buffer to be mixed.
    /// @param format the SDL_AudioFormat structure representing the desired audio
    /// format.
    /// @param len the length of the audio buffer in bytes.
    /// @param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full
    /// audio volume.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean mixAudio(
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr dst,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr src,
        @EnumType(SDL_AudioFormat.class) int format,
        @NativeType("Uint32") @Unsigned int len,
        float volume
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MixAudio);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                format,
                len,
                volume
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert some audio data of one format to another format.
    ///
    /// Please note that this function is for convenience, but should not be used
    /// to resample audio in blocks, as it will introduce audio artifacts on the
    /// boundaries. You should only use this function if you are converting audio
    /// data in its entirety in one call. If you want to convert audio in smaller
    /// chunks, use an SDL_AudioStream, which is designed for this situation.
    ///
    /// Internally, this function creates and destroys an SDL_AudioStream on each
    /// use, so it's also less efficient than using one directly, if you need to
    /// convert multiple times.
    ///
    /// @param src_spec the format details of the input audio.
    /// @param src_data the audio data to be converted.
    /// @param src_len the len of src_data.
    /// @param dst_spec the format details of the output audio.
    /// @param dst_data will be filled with a pointer to converted audio data,
    /// which should be freed with SDL_free(). On error, it will be
    /// NULL.
    /// @param dst_len will be filled with the len of dst_data.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean convertAudioSamples(
        @Nullable @Pointer ISDL_AudioSpec src_spec,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr src_data,
        int src_len,
        @Nullable @Pointer ISDL_AudioSpec dst_spec,
        @Nullable PointerPtr dst_data,
        @Nullable IntPtr dst_len
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ConvertAudioSamples);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src_spec != null ? src_spec.segment() : MemorySegment.NULL),
                (MemorySegment) (src_data != null ? src_data.segment() : MemorySegment.NULL),
                src_len,
                (MemorySegment) (dst_spec != null ? dst_spec.segment() : MemorySegment.NULL),
                (MemorySegment) (dst_data != null ? dst_data.segment() : MemorySegment.NULL),
                (MemorySegment) (dst_len != null ? dst_len.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the human readable name of an audio format.
    ///
    /// @param format the audio format to query.
    /// @return the human readable name of the specified audio format or
    /// "SDL_AUDIO_UNKNOWN" if the format isn't recognized.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getAudioFormatName(
        @EnumType(SDL_AudioFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAudioFormatName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                format
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the appropriate memset value for silencing an audio format.
    ///
    /// The value returned by this function can be used as the second argument to
    /// memset (or SDL_memset) to set an audio buffer in a specific format to
    /// silence.
    ///
    /// @param format the audio data format to query.
    /// @return a byte value that can be passed to memset.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getSilenceValueForFormat(
        @EnumType(SDL_AudioFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSilenceValueForFormat);
        try {
            return (int) hFunction.invokeExact(
                format
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compose a custom blend mode for renderers.
    ///
    /// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
    /// the SDL_BlendMode returned by this function if the renderer supports it.
    ///
    /// A blend mode controls how the pixels from a drawing operation (source) get
    /// combined with the pixels from the render target (destination). First, the
    /// components of the source and destination pixels get multiplied with their
    /// blend factors. Then, the blend operation takes the two products and
    /// calculates the result that will get stored in the render target.
    ///
    /// Expressed in pseudocode, it would look like this:
    ///
    /// ```c
    /// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
    /// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
    /// ```
    ///
    /// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
    /// dst)` can return one of the following:
    ///
    /// - `src + dst`
    /// - `src - dst`
    /// - `dst - src`
    /// - `min(src, dst)`
    /// - `max(src, dst)`
    ///
    /// The red, green, and blue components are always multiplied with the first,
    /// second, and third components of the SDL_BlendFactor, respectively. The
    /// fourth component is not used.
    ///
    /// The alpha component is always multiplied with the fourth component of the
    /// SDL_BlendFactor. The other components are not used in the alpha
    /// calculation.
    ///
    /// Support for these blend modes varies for each renderer. To check if a
    /// specific SDL_BlendMode is supported, create a renderer and pass it to
    /// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
    /// return with an error if the blend mode is not supported.
    ///
    /// This list describes the support of custom blend modes for each renderer.
    /// All renderers support the four blend modes listed in the SDL_BlendMode
    /// enumeration.
    ///
    /// - **direct3d**: Supports all operations with all factors. However, some
    /// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
    /// `SDL_BLENDOPERATION_MAXIMUM`.
    /// - **direct3d11**: Same as Direct3D 9.
    /// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
    /// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.
    /// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
    /// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
    /// operations with all factors.
    /// - **psp**: No custom blend mode support.
    /// - **software**: No custom blend mode support.
    ///
    /// Some renderers do not provide an alpha component for the default render
    /// target. The `SDL_BLENDFACTOR_DST_ALPHA` and
    /// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
    /// case.
    ///
    /// @param srcColorFactor the SDL_BlendFactor applied to the red, green, and
    /// blue components of the source pixels.
    /// @param dstColorFactor the SDL_BlendFactor applied to the red, green, and
    /// blue components of the destination pixels.
    /// @param colorOperation the SDL_BlendOperation used to combine the red,
    /// green, and blue components of the source and
    /// destination pixels.
    /// @param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
    /// the source pixels.
    /// @param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
    /// the destination pixels.
    /// @param alphaOperation the SDL_BlendOperation used to combine the alpha
    /// component of the source and destination pixels.
    /// @return an SDL_BlendMode that represents the chosen factors and
    /// operations.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderDrawBlendMode
    /// @see #getRenderDrawBlendMode
    /// @see #setTextureBlendMode
    /// @see #getTextureBlendMode
    public @EnumType(SDL_BlendMode.class) int composeCustomBlendMode(
        @EnumType(SDL_BlendFactor.class) int srcColorFactor,
        @EnumType(SDL_BlendFactor.class) int dstColorFactor,
        @EnumType(SDL_BlendOperation.class) int colorOperation,
        @EnumType(SDL_BlendFactor.class) int srcAlphaFactor,
        @EnumType(SDL_BlendFactor.class) int dstAlphaFactor,
        @EnumType(SDL_BlendOperation.class) int alphaOperation
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ComposeCustomBlendMode);
        try {
            return (int) hFunction.invokeExact(
                srcColorFactor,
                dstColorFactor,
                colorOperation,
                srcAlphaFactor,
                dstAlphaFactor,
                alphaOperation
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the number of built-in camera drivers.
    ///
    /// This function returns a hardcoded number. This never returns a negative
    /// value; if there are no drivers compiled into this build of SDL, this
    /// function returns zero. The presence of a driver in this list does not mean
    /// it will function, it just means SDL is capable of interacting with that
    /// interface. For example, a build of SDL might have v4l2 support, but if
    /// there's no kernel support available, SDL's v4l2 driver would fail if used.
    ///
    /// By default, SDL tries all drivers, in its preferred order, until one is
    /// found to be usable.
    ///
    /// @return the number of built-in camera drivers.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCameraDriver
    public int getNumCameraDrivers() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumCameraDrivers);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the name of a built in camera driver.
    ///
    /// The list of camera drivers is given in the order that they are normally
    /// initialized by default; the drivers that seem more reasonable to choose
    /// first (as far as the SDL developers believe) are earlier in the list.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",
    /// "coremedia" or "android". These never have Unicode characters, and are not
    /// meant to be proper names.
    ///
    /// @param index the index of the camera driver; the value ranges from 0 to
    /// SDL_GetNumCameraDrivers() - 1.
    /// @return the name of the camera driver at the requested index, or NULL if
    /// an invalid index was specified.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumCameraDrivers
    public BytePtr getCameraDriver(
        int index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                index
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of the current camera driver.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",
    /// "coremedia" or "android". These never have Unicode characters, and are not
    /// meant to be proper names.
    ///
    /// @return the name of the current camera driver or NULL if no driver has
    /// been initialized.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getCurrentCameraDriver() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentCameraDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected camera devices.
    ///
    /// @param count a pointer filled in with the number of cameras returned, may
    /// be NULL.
    /// @return a 0 terminated array of camera instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openCamera
    public @Pointer(comment="SDL_CameraID") @Unsigned IntPtr getCameras(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameras);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the list of native formats/sizes a camera supports.
    ///
    /// This returns a list of all formats and frame sizes that a specific camera
    /// can offer. This is useful if your app can accept a variety of image formats
    /// and sizes and so want to find the optimal spec that doesn't require
    /// conversion.
    ///
    /// This function isn't strictly required; if you call SDL_OpenCamera with a
    /// NULL spec, SDL will choose a native format for you, and if you instead
    /// specify a desired format, it will transparently convert to the requested
    /// format on your behalf.
    ///
    /// If `count` is not NULL, it will be filled with the number of elements in
    /// the returned array.
    ///
    /// Note that it's legal for a camera to supply an empty list. This is what
    /// will happen on Emscripten builds, since that platform won't tell _anything_
    /// about available cameras until you've opened one, and won't even tell if
    /// there _is_ a camera until the user has given you permission to check
    /// through a scary warning popup.
    ///
    /// @param instance_id the camera device instance ID.
    /// @param count a pointer filled in with the number of elements in the list,
    /// may be NULL.
    /// @return a NULL terminated array of pointers to SDL_CameraSpec or NULL on
    /// failure; call SDL_GetError() for more information. This is a
    /// single allocation that should be freed with SDL_free() when it is
    /// no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCameras
    /// @see #openCamera
    public PointerPtr getCameraSupportedFormats(
        @NativeType("SDL_CameraID") @Unsigned int instance_id,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraSupportedFormats);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id,
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the human-readable device name for a camera.
    ///
    /// @param instance_id the camera device instance ID.
    /// @return a human-readable device name or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCameras
    public BytePtr getCameraName(
        @NativeType("SDL_CameraID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the position of the camera in relation to the system.
    ///
    /// Most platforms will report UNKNOWN, but mobile devices, like phones, can
    /// often make a distinction between cameras on the front of the device (that
    /// points towards the user, for taking "selfies") and cameras on the back (for
    /// filming in the direction the user is facing).
    ///
    /// @param instance_id the camera device instance ID.
    /// @return the position of the camera on the system hardware.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCameras
    public @EnumType(SDL_CameraPosition.class) int getCameraPosition(
        @NativeType("SDL_CameraID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraPosition);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a video recording device (a "camera").
    ///
    /// You can open the device with any reasonable spec, and if the hardware can't
    /// directly support it, it will convert data seamlessly to the requested
    /// format. This might incur overhead, including scaling of image data.
    ///
    /// If you would rather accept whatever format the device offers, you can pass
    /// a NULL spec here and it will choose one for you (and you can use
    /// SDL_Surface's conversion/scaling functions directly if necessary).
    ///
    /// You can call SDL_GetCameraFormat() to get the actual data format if passing
    /// a NULL spec here. You can see the exact specs a device can support without
    /// conversion with SDL_GetCameraSupportedFormats().
    ///
    /// SDL will not attempt to emulate framerate; it will try to set the hardware
    /// to the rate closest to the requested speed, but it won't attempt to limit
    /// or duplicate frames artificially; call SDL_GetCameraFormat() to see the
    /// actual framerate of the opened the device, and check your timestamps if
    /// this is crucial to your app!
    ///
    /// Note that the camera is not usable until the user approves its use! On some
    /// platforms, the operating system will prompt the user to permit access to
    /// the camera, and they can choose Yes or No at that point. Until they do, the
    /// camera will not be usable. The app should either wait for an
    /// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,
    /// or poll SDL_GetCameraPermissionState() occasionally until it returns
    /// non-zero. On platforms that don't require explicit user approval (and
    /// perhaps in places where the user previously permitted access), the approval
    /// event might come immediately, but it might come seconds, minutes, or hours
    /// later!
    ///
    /// @param instance_id the camera device instance ID.
    /// @param spec the desired format for data the device will provide. Can be
    /// NULL.
    /// @return an SDL_Camera object or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCameras
    /// @see #getCameraFormat
    public SDL_Camera openCamera(
        @NativeType("SDL_CameraID") @Unsigned int instance_id,
        @Nullable @Pointer ISDL_CameraSpec spec
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenCamera);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id,
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Camera(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if camera access has been approved by the user.
    ///
    /// Cameras will not function between when the device is opened by the app and
    /// when the user permits access to the hardware. On some platforms, this
    /// presents as a popup dialog where the user has to explicitly approve access;
    /// on others the approval might be implicit and not alert the user at all.
    ///
    /// This function can be used to check the status of that approval. It will
    /// return 0 if still waiting for user response, 1 if the camera is approved
    /// for use, and -1 if the user denied access.
    ///
    /// Instead of polling with this function, you can wait for a
    /// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event
    /// in the standard SDL event loop, which is guaranteed to be sent once when
    /// permission to use the camera is decided.
    ///
    /// If a camera is declined, there's nothing to be done but call
    /// SDL_CloseCamera() to dispose of it.
    ///
    /// @param camera the opened camera device to query.
    /// @return -1 if user denied access to the camera, 1 if user approved access,
    /// 0 if no decision has been made yet.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openCamera
    /// @see #closeCamera
    public int getCameraPermissionState(
        @Nullable SDL_Camera camera
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraPermissionState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the instance ID of an opened camera.
    ///
    /// @param camera an SDL_Camera to query.
    /// @return the instance ID of the specified camera on success or 0 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openCamera
    public @NativeType("SDL_CameraID") @Unsigned int getCameraID(
        @Nullable SDL_Camera camera
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraID);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with an opened camera.
    ///
    /// @param camera the SDL_Camera obtained from SDL_OpenCamera().
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getCameraProperties(
        @Nullable SDL_Camera camera
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the spec that a camera is using when generating images.
    ///
    /// Note that this might not be the native format of the hardware, as SDL might
    /// be converting to this format behind the scenes.
    ///
    /// If the system is waiting for the user to approve access to the camera, as
    /// some platforms require, this will return false, but this isn't necessarily
    /// a fatal error; you should either wait for an
    /// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,
    /// or poll SDL_GetCameraPermissionState() occasionally until it returns
    /// non-zero.
    ///
    /// @param camera opened camera device.
    /// @param spec the SDL_CameraSpec to be initialized by this function.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openCamera
    public @NativeType("boolean") boolean getCameraFormat(
        @Nullable SDL_Camera camera,
        @Nullable @Pointer ISDL_CameraSpec spec
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCameraFormat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL),
                (MemorySegment) (spec != null ? spec.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Acquire a frame.
    ///
    /// The frame is a memory pointer to the image data, whose size and format are
    /// given by the spec requested when opening the device.
    ///
    /// This is a non blocking API. If there is a frame available, a non-NULL
    /// surface is returned, and timestampNS will be filled with a non-zero value.
    ///
    /// Note that an error case can also return NULL, but a NULL by itself is
    /// normal and just signifies that a new frame is not yet available. Note that
    /// even if a camera device fails outright (a USB camera is unplugged while in
    /// use, etc), SDL will send an event separately to notify the app, but
    /// continue to provide blank frames at ongoing intervals until
    /// SDL_CloseCamera() is called, so real failure here is almost always an out
    /// of memory condition.
    ///
    /// After use, the frame should be released with SDL_ReleaseCameraFrame(). If
    /// you don't do this, the system may stop providing more video!
    ///
    /// Do not call SDL_DestroySurface() on the returned surface! It must be given
    /// back to the camera subsystem with SDL_ReleaseCameraFrame!
    ///
    /// If the system is waiting for the user to approve access to the camera, as
    /// some platforms require, this will return NULL (no frames available); you
    /// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or
    /// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll
    /// SDL_GetCameraPermissionState() occasionally until it returns non-zero.
    ///
    /// @param camera opened camera device.
    /// @param timestampNS a pointer filled in with the frame's timestamp, or 0 on
    /// error. Can be NULL.
    /// @return a new frame of video on success, NULL if none is currently
    /// available.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #releaseCameraFrame
    public SDL_Surface acquireCameraFrame(
        @Nullable SDL_Camera camera,
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr timestampNS
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AcquireCameraFrame);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL),
                (MemorySegment) (timestampNS != null ? timestampNS.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Release a frame of video acquired from a camera.
    ///
    /// Let the back-end re-use the internal buffer for camera.
    ///
    /// This function _must_ be called only on surface objects returned by
    /// SDL_AcquireCameraFrame(). This function should be called as quickly as
    /// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for
    /// video frames; if surfaces aren't released in a timely manner, SDL may drop
    /// upcoming video frames from the camera.
    ///
    /// If the app needs to keep the surface for a significant time, they should
    /// make a copy of it and release the original.
    ///
    /// The app should not use the surface again after calling this function;
    /// assume the surface is freed and the pointer is invalid.
    ///
    /// @param camera opened camera device.
    /// @param frame the video frame surface to release.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #acquireCameraFrame
    public void releaseCameraFrame(
        @Nullable SDL_Camera camera,
        @Nullable SDL_Surface frame
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseCameraFrame);
        try {
            hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL),
                (MemorySegment) (frame != null ? frame.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to shut down camera processing and close the camera
    /// device.
    ///
    /// @param camera opened camera device.
    ///
    /// @threadsafety It is safe to call this function from any thread, but no
    /// thread may reference `device` once this function is called.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openCamera
    public void closeCamera(
        @Nullable SDL_Camera camera
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseCamera);
        try {
            hFunction.invokeExact(
                (MemorySegment) (camera != null ? camera.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Put UTF-8 text into the clipboard.
    ///
    /// @param text the text to store in the clipboard.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getClipboardText
    /// @see #hasClipboardText
    public @NativeType("boolean") boolean setClipboardText(
        @Nullable BytePtr text
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetClipboardText);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (text != null ? text.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get UTF-8 text from the clipboard.
    ///
    /// This functions returns an empty string if there was not enough memory left
    /// for a copy of the clipboard's content.
    ///
    /// @return the clipboard text on success or an empty string on failure; call
    /// SDL_GetError() for more information. This should be freed with
    /// SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasClipboardText
    /// @see #setClipboardText
    public BytePtr getClipboardText() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetClipboardText);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether the clipboard exists and contains a non-empty text string.
    ///
    /// @return true if the clipboard has text, or false if it does not.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getClipboardText
    /// @see #setClipboardText
    public @NativeType("boolean") boolean hasClipboardText() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasClipboardText);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Put UTF-8 text into the primary selection.
    ///
    /// @param text the text to store in the primary selection.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPrimarySelectionText
    /// @see #hasPrimarySelectionText
    public @NativeType("boolean") boolean setPrimarySelectionText(
        @Nullable BytePtr text
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetPrimarySelectionText);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (text != null ? text.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get UTF-8 text from the primary selection.
    ///
    /// This functions returns an empty string if there was not enough memory left
    /// for a copy of the primary selection's content.
    ///
    /// @return the primary selection text on success or an empty string on
    /// failure; call SDL_GetError() for more information. This should be
    /// freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasPrimarySelectionText
    /// @see #setPrimarySelectionText
    public BytePtr getPrimarySelectionText() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPrimarySelectionText);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether the primary selection exists and contains a non-empty text
    /// string.
    ///
    /// @return true if the primary selection has text, or false if it does not.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPrimarySelectionText
    /// @see #setPrimarySelectionText
    public @NativeType("boolean") boolean hasPrimarySelectionText() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasPrimarySelectionText);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Offer clipboard data to the OS.
    ///
    /// Tell the operating system that the application is offering clipboard data
    /// for each of the provided mime-types. Once another application requests the
    /// data the callback function will be called, allowing it to generate and
    /// respond with the data for the requested mime-type.
    ///
    /// The size of text data does not include any terminator, and the text does
    /// not need to be null terminated (e.g. you can directly copy a portion of a
    /// document).
    ///
    /// @param callback a function pointer to the function that provides the
    /// clipboard data.
    /// @param cleanup a function pointer to the function that cleans up the
    /// clipboard data.
    /// @param userdata an opaque pointer that will be forwarded to the callbacks.
    /// @param mime_types a list of mime-types that are being offered.
    /// @param num_mime_types the number of mime-types in the mime_types list.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #clearClipboardData
    /// @see #getClipboardData
    /// @see #hasClipboardData
    public @NativeType("boolean") boolean setClipboardData(
        @Pointer(comment="SDL_ClipboardDataCallback") MemorySegment callback,
        @Pointer(comment="SDL_ClipboardCleanupCallback") MemorySegment cleanup,
        @Pointer(comment="void*") MemorySegment userdata,
        @Nullable PointerPtr mime_types,
        long num_mime_types
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetClipboardData);
        try {
            return (boolean) hFunction.invokeExact(
                callback,
                cleanup,
                userdata,
                (MemorySegment) (mime_types != null ? mime_types.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(num_mime_types)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear the clipboard data.
    ///
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setClipboardData
    public @NativeType("boolean") boolean clearClipboardData() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClearClipboardData);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the data from clipboard for a given mime type.
    ///
    /// The size of text data does not include the terminator, but the text is
    /// guaranteed to be null terminated.
    ///
    /// @param mime_type the mime type to read from the clipboard.
    /// @param size a pointer filled in with the length of the returned data.
    /// @return the retrieved data buffer or NULL on failure; call SDL_GetError()
    /// for more information. This should be freed with SDL_free() when it
    /// is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasClipboardData
    /// @see #setClipboardData
    public @Pointer(comment="void*") MemorySegment getClipboardData(
        @Nullable BytePtr mime_type,
        @Nullable PointerPtr size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetClipboardData);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (mime_type != null ? mime_type.segment() : MemorySegment.NULL),
                (MemorySegment) (size != null ? size.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether there is data in the clipboard for the provided mime type.
    ///
    /// @param mime_type the mime type to check for data for.
    /// @return true if there exists data in clipboard for the provided mime type,
    /// false if it does not.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setClipboardData
    /// @see #getClipboardData
    public @NativeType("boolean") boolean hasClipboardData(
        @Nullable BytePtr mime_type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasClipboardData);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (mime_type != null ? mime_type.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Retrieve the list of mime types available in the clipboard.
    ///
    /// @param num_mime_types a pointer filled with the number of mime types, may
    /// be NULL.
    /// @return a null terminated array of strings with mime types, or NULL on
    /// failure; call SDL_GetError() for more information. This should be
    /// freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setClipboardData
    public PointerPtr getClipboardMimeTypes(
        @Nullable PointerPtr num_mime_types
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetClipboardMimeTypes);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (num_mime_types != null ? num_mime_types.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of logical CPU cores available.
    ///
    /// @return the total number of logical CPU cores. On CPUs that include
    /// technologies such as hyperthreading, the number of logical cores
    /// may be more than the number of physical cores.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getNumLogicalCPUCores() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumLogicalCPUCores);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine the L1 cache line size of the CPU.
    ///
    /// This is useful for determining multi-threaded structure padding or SIMD
    /// prefetch sizes.
    ///
    /// @return the L1 cache line size of the CPU, in bytes.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getCPUCacheLineSize() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCPUCacheLineSize);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has AltiVec features.
    ///
    /// This always returns false on CPUs that aren't using PowerPC instruction
    /// sets.
    ///
    /// @return true if the CPU has AltiVec features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean hasAltiVec() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasAltiVec);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has MMX features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has MMX features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean hasMMX() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasMMX);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has SSE features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has SSE features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasSSE2
    /// @see #hasSSE3
    /// @see #hasSSE41
    /// @see #hasSSE42
    public @NativeType("boolean") boolean hasSSE() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasSSE);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has SSE2 features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has SSE2 features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasSSE
    /// @see #hasSSE3
    /// @see #hasSSE41
    /// @see #hasSSE42
    public @NativeType("boolean") boolean hasSSE2() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasSSE2);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has SSE3 features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has SSE3 features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasSSE
    /// @see #hasSSE2
    /// @see #hasSSE41
    /// @see #hasSSE42
    public @NativeType("boolean") boolean hasSSE3() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasSSE3);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has SSE4.1 features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has SSE4.1 features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasSSE
    /// @see #hasSSE2
    /// @see #hasSSE3
    /// @see #hasSSE42
    public @NativeType("boolean") boolean hasSSE41() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasSSE41);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has SSE4.2 features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has SSE4.2 features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasSSE
    /// @see #hasSSE2
    /// @see #hasSSE3
    /// @see #hasSSE41
    public @NativeType("boolean") boolean hasSSE42() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasSSE42);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has AVX features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has AVX features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasAVX2
    /// @see #hasAVX512F
    public @NativeType("boolean") boolean hasAVX() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasAVX);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has AVX2 features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has AVX2 features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasAVX
    /// @see #hasAVX512F
    public @NativeType("boolean") boolean hasAVX2() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasAVX2);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has AVX-512F (foundation) features.
    ///
    /// This always returns false on CPUs that aren't using Intel instruction sets.
    ///
    /// @return true if the CPU has AVX-512F features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasAVX
    /// @see #hasAVX2
    public @NativeType("boolean") boolean hasAVX512F() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasAVX512F);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has ARM SIMD (ARMv6) features.
    ///
    /// This is different from ARM NEON, which is a different instruction set.
    ///
    /// This always returns false on CPUs that aren't using ARM instruction sets.
    ///
    /// @return true if the CPU has ARM SIMD features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasNEON
    public @NativeType("boolean") boolean hasARMSIMD() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasARMSIMD);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has NEON (ARM SIMD) features.
    ///
    /// This always returns false on CPUs that aren't using ARM instruction sets.
    ///
    /// @return true if the CPU has ARM NEON features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean hasNEON() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasNEON);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has LSX (LOONGARCH SIMD) features.
    ///
    /// This always returns false on CPUs that aren't using LOONGARCH instruction
    /// sets.
    ///
    /// @return true if the CPU has LOONGARCH LSX features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean hasLSX() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasLSX);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether the CPU has LASX (LOONGARCH SIMD) features.
    ///
    /// This always returns false on CPUs that aren't using LOONGARCH instruction
    /// sets.
    ///
    /// @return true if the CPU has LOONGARCH LASX features or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean hasLASX() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasLASX);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the amount of RAM configured in the system.
    ///
    /// @return the amount of RAM configured in the system in MiB.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getSystemRAM() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSystemRAM);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report the alignment this system needs for SIMD allocations.
    ///
    /// This will return the minimum number of bytes to which a pointer must be
    /// aligned to be compatible with SIMD instructions on the current machine. For
    /// example, if the machine supports SSE only, it will return 16, but if it
    /// supports AVX-512F, it'll return 64 (etc). This only reports values for
    /// instruction sets SDL knows about, so if your SDL build doesn't have
    /// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
    /// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
    /// Plan accordingly.
    ///
    /// @return the alignment in bytes needed for available, known SIMD
    /// instructions.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #aligned_alloc
    /// @see #aligned_free
    public long getSIMDAlignment() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSIMDAlignment);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Displays a dialog that lets the user select a file on their filesystem.
    ///
    /// This is an asynchronous function; it will return immediately, and the
    /// result will be passed to the callback.
    ///
    /// The callback will be invoked with a null-terminated list of files the user
    /// chose. The list will be empty if the user canceled the dialog, and it will
    /// be NULL if an error occurred.
    ///
    /// Note that the callback may be called from a different thread than the one
    /// the function was invoked on.
    ///
    /// Depending on the platform, the user may be allowed to input paths that
    /// don't yet exist.
    ///
    /// On Linux, dialogs may require XDG Portals, which requires DBus, which
    /// requires an event-handling loop. Apps that do not use SDL to handle events
    /// should add a call to SDL_PumpEvents in their main loop.
    ///
    /// @param callback a function pointer to be invoked when the user selects a
    /// file and accepts, or cancels the dialog, or an error
    /// occurs.
    /// @param userdata an optional pointer to pass extra data to the callback when
    /// it will be invoked.
    /// @param window the window that the dialog should be modal for, may be NULL.
    /// Not all platforms support this option.
    /// @param filters a list of filters, may be NULL. Not all platforms support
    /// this option, and platforms that do support it may allow the
    /// user to ignore the filters. If non-NULL, it must remain
    /// valid at least until the callback is invoked.
    /// @param nfilters the number of filters. Ignored if filters is NULL.
    /// @param default_location the default folder or file to start the dialog at,
    /// may be NULL. Not all platforms support this option.
    /// @param allow_many if non-zero, the user will be allowed to select multiple
    /// entries. Not all platforms support this option.
    ///
    /// @threadsafety This function should be called only from the main thread. The
    /// callback may be invoked from the same thread or from a
    /// different one, depending on the OS's constraints.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_DialogFileCallback`
    /// @see `SDL_DialogFileFilter`
    /// @see #showSaveFileDialog
    /// @see #showOpenFolderDialog
    /// @see #showFileDialogWithProperties
    public void showOpenFileDialog(
        @Pointer(comment="SDL_DialogFileCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata,
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_DialogFileFilter filters,
        int nfilters,
        @Nullable BytePtr default_location,
        @NativeType("boolean") boolean allow_many
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowOpenFileDialog);
        try {
            hFunction.invokeExact(
                callback,
                userdata,
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (filters != null ? filters.segment() : MemorySegment.NULL),
                nfilters,
                (MemorySegment) (default_location != null ? default_location.segment() : MemorySegment.NULL),
                allow_many
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Displays a dialog that lets the user choose a new or existing file on their
    /// filesystem.
    ///
    /// This is an asynchronous function; it will return immediately, and the
    /// result will be passed to the callback.
    ///
    /// The callback will be invoked with a null-terminated list of files the user
    /// chose. The list will be empty if the user canceled the dialog, and it will
    /// be NULL if an error occurred.
    ///
    /// Note that the callback may be called from a different thread than the one
    /// the function was invoked on.
    ///
    /// The chosen file may or may not already exist.
    ///
    /// On Linux, dialogs may require XDG Portals, which requires DBus, which
    /// requires an event-handling loop. Apps that do not use SDL to handle events
    /// should add a call to SDL_PumpEvents in their main loop.
    ///
    /// @param callback a function pointer to be invoked when the user selects a
    /// file and accepts, or cancels the dialog, or an error
    /// occurs.
    /// @param userdata an optional pointer to pass extra data to the callback when
    /// it will be invoked.
    /// @param window the window that the dialog should be modal for, may be NULL.
    /// Not all platforms support this option.
    /// @param filters a list of filters, may be NULL. Not all platforms support
    /// this option, and platforms that do support it may allow the
    /// user to ignore the filters. If non-NULL, it must remain
    /// valid at least until the callback is invoked.
    /// @param nfilters the number of filters. Ignored if filters is NULL.
    /// @param default_location the default folder or file to start the dialog at,
    /// may be NULL. Not all platforms support this option.
    ///
    /// @threadsafety This function should be called only from the main thread. The
    /// callback may be invoked from the same thread or from a
    /// different one, depending on the OS's constraints.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_DialogFileCallback`
    /// @see `SDL_DialogFileFilter`
    /// @see #showOpenFileDialog
    /// @see #showOpenFolderDialog
    /// @see #showFileDialogWithProperties
    public void showSaveFileDialog(
        @Pointer(comment="SDL_DialogFileCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata,
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_DialogFileFilter filters,
        int nfilters,
        @Nullable BytePtr default_location
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowSaveFileDialog);
        try {
            hFunction.invokeExact(
                callback,
                userdata,
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (filters != null ? filters.segment() : MemorySegment.NULL),
                nfilters,
                (MemorySegment) (default_location != null ? default_location.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Displays a dialog that lets the user select a folder on their filesystem.
    ///
    /// This is an asynchronous function; it will return immediately, and the
    /// result will be passed to the callback.
    ///
    /// The callback will be invoked with a null-terminated list of files the user
    /// chose. The list will be empty if the user canceled the dialog, and it will
    /// be NULL if an error occurred.
    ///
    /// Note that the callback may be called from a different thread than the one
    /// the function was invoked on.
    ///
    /// Depending on the platform, the user may be allowed to input paths that
    /// don't yet exist.
    ///
    /// On Linux, dialogs may require XDG Portals, which requires DBus, which
    /// requires an event-handling loop. Apps that do not use SDL to handle events
    /// should add a call to SDL_PumpEvents in their main loop.
    ///
    /// @param callback a function pointer to be invoked when the user selects a
    /// file and accepts, or cancels the dialog, or an error
    /// occurs.
    /// @param userdata an optional pointer to pass extra data to the callback when
    /// it will be invoked.
    /// @param window the window that the dialog should be modal for, may be NULL.
    /// Not all platforms support this option.
    /// @param default_location the default folder or file to start the dialog at,
    /// may be NULL. Not all platforms support this option.
    /// @param allow_many if non-zero, the user will be allowed to select multiple
    /// entries. Not all platforms support this option.
    ///
    /// @threadsafety This function should be called only from the main thread. The
    /// callback may be invoked from the same thread or from a
    /// different one, depending on the OS's constraints.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_DialogFileCallback`
    /// @see #showOpenFileDialog
    /// @see #showSaveFileDialog
    /// @see #showFileDialogWithProperties
    public void showOpenFolderDialog(
        @Pointer(comment="SDL_DialogFileCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata,
        @Nullable SDL_Window window,
        @Nullable BytePtr default_location,
        @NativeType("boolean") boolean allow_many
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowOpenFolderDialog);
        try {
            hFunction.invokeExact(
                callback,
                userdata,
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (default_location != null ? default_location.segment() : MemorySegment.NULL),
                allow_many
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create and launch a file dialog with the specified properties.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of
    /// SDL_DialogFileFilter structs, which will be used as filters for
    /// file-based selections. Ignored if the dialog is an "Open Folder" dialog.
    /// If non-NULL, the array of filters must remain valid at least until the
    /// callback is invoked.
    /// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the
    /// array of filters, if it exists.
    /// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should
    /// be modal for.
    /// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to
    /// start the dialog at.
    /// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select
    /// more than one entry.
    /// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.
    /// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button
    /// should have.
    /// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button
    /// should have.
    ///
    /// Note that each platform may or may not support any of the properties.
    ///
    /// @param type the type of file dialog.
    /// @param callback a function pointer to be invoked when the user selects a
    /// file and accepts, or cancels the dialog, or an error
    /// occurs.
    /// @param userdata an optional pointer to pass extra data to the callback when
    /// it will be invoked.
    /// @param props the properties to use.
    ///
    /// @threadsafety This function should be called only from the main thread. The
    /// callback may be invoked from the same thread or from a
    /// different one, depending on the OS's constraints.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_FileDialogType`
    /// @see `SDL_DialogFileCallback`
    /// @see `SDL_DialogFileFilter`
    /// @see #showOpenFileDialog
    /// @see #showSaveFileDialog
    /// @see #showOpenFolderDialog
    public void showFileDialogWithProperties(
        @EnumType(SDL_FileDialogType.class) int type,
        @Pointer(comment="SDL_DialogFileCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata,
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowFileDialogWithProperties);
        try {
            hFunction.invokeExact(
                type,
                callback,
                userdata,
                props
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an error indicating that memory allocation failed.
    ///
    /// This function does not do any memory allocation.
    ///
    /// @return false.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean outOfMemory() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OutOfMemory);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Retrieve a message about the last error that occurred on the current
    /// thread.
    ///
    /// It is possible for multiple errors to occur before calling SDL_GetError().
    /// Only the last error is returned.
    ///
    /// The message is only applicable when an SDL function has signaled an error.
    /// You must check the return values of SDL function calls to determine when to
    /// appropriately call SDL_GetError(). You should *not* use the results of
    /// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
    /// an error string even when reporting success.
    ///
    /// SDL will *not* clear the error string for successful API calls. You *must*
    /// check return values for failure cases before you can assume the error
    /// string applies.
    ///
    /// Error strings are set per-thread, so an error set in a different thread
    /// will not interfere with the current thread's operation.
    ///
    /// The returned value is a thread-local string which will remain valid until
    /// the current thread's error string is changed. The caller should make a copy
    /// if the value is needed after the next SDL API call.
    ///
    /// @return a message with information about the specific error that occurred,
    /// or an empty string if there hasn't been an error message set since
    /// the last call to SDL_ClearError().
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #clearError
    /// @see #setError
    public BytePtr getError() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetError);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear any previous error message for this thread.
    ///
    /// @return true.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getError
    /// @see #setError
    public @NativeType("boolean") boolean clearError() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClearError);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Pump the event loop, gathering events from the input devices.
    ///
    /// This function updates the event queue and internal input device state.
    ///
    /// SDL_PumpEvents() gathers all the pending input information from devices and
    /// places it in the event queue. Without calls to SDL_PumpEvents() no events
    /// would ever be placed on the queue. Often the need for calls to
    /// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
    /// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
    /// polling or waiting for events (e.g. you are filtering them), then you must
    /// call SDL_PumpEvents() to force an event queue update.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pollEvent
    /// @see #waitEvent
    public void pumpEvents() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PumpEvents);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check the event queue for messages and optionally return them.
    ///
    /// `action` may be any of the following:
    ///
    /// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
    /// event queue.
    /// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
    /// within the specified minimum and maximum type, will be returned to the
    /// caller and will _not_ be removed from the queue. If you pass NULL for
    /// `events`, then `numevents` is ignored and the total number of matching
    /// events will be returned.
    /// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
    /// within the specified minimum and maximum type, will be returned to the
    /// caller and will be removed from the queue.
    ///
    /// You may have to call SDL_PumpEvents() before calling this function.
    /// Otherwise, the events may not be ready to be filtered when you call
    /// SDL_PeepEvents().
    ///
    /// @param events destination buffer for the retrieved events, may be NULL to
    /// leave the events in the queue and return the number of events
    /// that would have been stored.
    /// @param numevents if action is SDL_ADDEVENT, the number of events to add
    /// back to the event queue; if action is SDL_PEEKEVENT or
    /// SDL_GETEVENT, the maximum number of events to retrieve.
    /// @param action action to take; see [Remarks]({@code remarks}) for details.
    /// @param minType minimum value of the event type to be considered;
    /// SDL_EVENT_FIRST is a safe choice.
    /// @param maxType maximum value of the event type to be considered;
    /// SDL_EVENT_LAST is a safe choice.
    /// @return the number of events actually stored or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pollEvent
    /// @see #pumpEvents
    /// @see #pushEvent
    public int peepEvents(
        @Nullable @Pointer ISDL_Event events,
        int numevents,
        @EnumType(SDL_EventAction.class) int action,
        @NativeType("Uint32") @Unsigned int minType,
        @NativeType("Uint32") @Unsigned int maxType
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PeepEvents);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (events != null ? events.segment() : MemorySegment.NULL),
                numevents,
                action,
                minType,
                maxType
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check for the existence of a certain event type in the event queue.
    ///
    /// If you need to check for a range of event types, use SDL_HasEvents()
    /// instead.
    ///
    /// @param type the type of event to be queried; see SDL_EventType for details.
    /// @return true if events matching `type` are present, or false if events
    /// matching `type` are not present.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasEvents
    public @NativeType("boolean") boolean hasEvent(
        @NativeType("Uint32") @Unsigned int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasEvent);
        try {
            return (boolean) hFunction.invokeExact(
                type
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check for the existence of certain event types in the event queue.
    ///
    /// If you need to check for a single event type, use SDL_HasEvent() instead.
    ///
    /// @param minType the low end of event type to be queried, inclusive; see
    /// SDL_EventType for details.
    /// @param maxType the high end of event type to be queried, inclusive; see
    /// SDL_EventType for details.
    /// @return true if events with type &amp;gt;= `minType` and &amp;lt;= `maxType` are
    /// present, or false if not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasEvents
    public @NativeType("boolean") boolean hasEvents(
        @NativeType("Uint32") @Unsigned int minType,
        @NativeType("Uint32") @Unsigned int maxType
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasEvents);
        try {
            return (boolean) hFunction.invokeExact(
                minType,
                maxType
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear events of a specific type from the event queue.
    ///
    /// This will unconditionally remove any events from the queue that match
    /// `type`. If you need to remove a range of event types, use SDL_FlushEvents()
    /// instead.
    ///
    /// It's also normal to just ignore events you don't care about in your event
    /// loop without calling this function.
    ///
    /// This function only affects currently queued events. If you want to make
    /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
    /// on the main thread immediately before the flush call.
    ///
    /// If you have user events with custom data that needs to be freed, you should
    /// use SDL_PeepEvents() to remove and clean up those events before calling
    /// this function.
    ///
    /// @param type the type of event to be cleared; see SDL_EventType for details.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #flushEvents
    public void flushEvent(
        @NativeType("Uint32") @Unsigned int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlushEvent);
        try {
            hFunction.invokeExact(
                type
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear events of a range of types from the event queue.
    ///
    /// This will unconditionally remove any events from the queue that are in the
    /// range of `minType` to `maxType`, inclusive. If you need to remove a single
    /// event type, use SDL_FlushEvent() instead.
    ///
    /// It's also normal to just ignore events you don't care about in your event
    /// loop without calling this function.
    ///
    /// This function only affects currently queued events. If you want to make
    /// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
    /// on the main thread immediately before the flush call.
    ///
    /// @param minType the low end of event type to be cleared, inclusive; see
    /// SDL_EventType for details.
    /// @param maxType the high end of event type to be cleared, inclusive; see
    /// SDL_EventType for details.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #flushEvent
    public void flushEvents(
        @NativeType("Uint32") @Unsigned int minType,
        @NativeType("Uint32") @Unsigned int maxType
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlushEvents);
        try {
            hFunction.invokeExact(
                minType,
                maxType
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Poll for currently pending events.
    ///
    /// If `event` is not NULL, the next event is removed from the queue and stored
    /// in the SDL_Event structure pointed to by `event`. The 1 returned refers to
    /// this event, immediately stored in the SDL Event structure -- not an event
    /// to follow.
    ///
    /// If `event` is NULL, it simply returns 1 if there is an event in the queue,
    /// but will not remove it from the queue.
    ///
    /// As this function may implicitly call SDL_PumpEvents(), you can only call
    /// this function in the thread that set the video mode.
    ///
    /// SDL_PollEvent() is the favored way of receiving system events since it can
    /// be done from the main loop and does not suspend the main loop while waiting
    /// on an event to be posted.
    ///
    /// The common practice is to fully process the event queue once every frame,
    /// usually as a first step before updating the game's state:
    ///
    /// ```c
    /// while (game_is_still_running) {
    /// SDL_Event event;
    /// while (SDL_PollEvent(&amp;event)) {  // poll until all events are handled!
    /// // decide what to do with this event.
    /// }
    ///
    /// // update game state, draw the current frame
    /// }
    /// ```
    ///
    /// @param event the SDL_Event structure to be filled with the next event from
    /// the queue, or NULL.
    /// @return true if this got an event or false if there are none available.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pushEvent
    /// @see #waitEvent
    /// @see #waitEventTimeout
    public @NativeType("boolean") boolean pollEvent(
        @Nullable @Pointer ISDL_Event event
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PollEvent);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (event != null ? event.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait indefinitely for the next available event.
    ///
    /// If `event` is not NULL, the next event is removed from the queue and stored
    /// in the SDL_Event structure pointed to by `event`.
    ///
    /// As this function may implicitly call SDL_PumpEvents(), you can only call
    /// this function in the thread that initialized the video subsystem.
    ///
    /// @param event the SDL_Event structure to be filled in with the next event
    /// from the queue, or NULL.
    /// @return true on success or false if there was an error while waiting for
    /// events; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pollEvent
    /// @see #pushEvent
    /// @see #waitEventTimeout
    public @NativeType("boolean") boolean waitEvent(
        @Nullable @Pointer ISDL_Event event
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitEvent);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (event != null ? event.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait until the specified timeout (in milliseconds) for the next available
    /// event.
    ///
    /// If `event` is not NULL, the next event is removed from the queue and stored
    /// in the SDL_Event structure pointed to by `event`.
    ///
    /// As this function may implicitly call SDL_PumpEvents(), you can only call
    /// this function in the thread that initialized the video subsystem.
    ///
    /// The timeout is not guaranteed, the actual wait time could be longer due to
    /// system scheduling.
    ///
    /// @param event the SDL_Event structure to be filled in with the next event
    /// from the queue, or NULL.
    /// @param timeoutMS the maximum number of milliseconds to wait for the next
    /// available event.
    /// @return true if this got an event or false if the timeout elapsed without
    /// any events available.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pollEvent
    /// @see #pushEvent
    /// @see #waitEvent
    public @NativeType("boolean") boolean waitEventTimeout(
        @Nullable @Pointer ISDL_Event event,
        @NativeType("Sint32") int timeoutMS
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitEventTimeout);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (event != null ? event.segment() : MemorySegment.NULL),
                timeoutMS
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add an event to the event queue.
    ///
    /// The event queue can actually be used as a two way communication channel.
    /// Not only can events be read from the queue, but the user can also push
    /// their own events onto it. `event` is a pointer to the event structure you
    /// wish to push onto the queue. The event is copied into the queue, and the
    /// caller may dispose of the memory pointed to after SDL_PushEvent() returns.
    ///
    /// Note: Pushing device input events onto the queue doesn't modify the state
    /// of the device within SDL.
    ///
    /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
    /// the event filter but events added with SDL_PeepEvents() do not.
    ///
    /// For pushing application-specific events, please use SDL_RegisterEvents() to
    /// get an event type that does not conflict with other code that also wants
    /// its own custom event types.
    ///
    /// @param event the SDL_Event to be added to the queue.
    /// @return true on success, false if the event was filtered or on failure;
    /// call SDL_GetError() for more information. A common reason for
    /// error is the event queue being full.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #peepEvents
    /// @see #pollEvent
    /// @see #registerEvents
    public @NativeType("boolean") boolean pushEvent(
        @Nullable @Pointer ISDL_Event event
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PushEvent);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (event != null ? event.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set up a filter to process all events before they are added to the internal
    /// event queue.
    ///
    /// If you just want to see events without modifying them or preventing them
    /// from being queued, you should use SDL_AddEventWatch() instead.
    ///
    /// If the filter function returns true when called, then the event will be
    /// added to the internal queue. If it returns false, then the event will be
    /// dropped from the queue, but the internal state will still be updated. This
    /// allows selective filtering of dynamically arriving events.
    ///
    /// **WARNING**: Be very careful of what you do in the event filter function,
    /// as it may run in a different thread!
    ///
    /// On platforms that support it, if the quit event is generated by an
    /// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
    /// application at the next event poll.
    ///
    /// Note: Disabled events never make it to the event filter function; see
    /// SDL_SetEventEnabled().
    ///
    /// Note: Events pushed onto the queue with SDL_PushEvent() get passed through
    /// the event filter, but events pushed onto the queue with SDL_PeepEvents() do
    /// not.
    ///
    /// @param filter an SDL_EventFilter function to call when an event happens.
    /// @param userdata a pointer that is passed to `filter`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addEventWatch
    /// @see #setEventEnabled
    /// @see #getEventFilter
    /// @see #peepEvents
    /// @see #pushEvent
    public void setEventFilter(
        @Pointer(comment="SDL_EventFilter") MemorySegment filter,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetEventFilter);
        try {
            hFunction.invokeExact(
                filter,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the current event filter.
    ///
    /// This function can be used to "chain" filters, by saving the existing filter
    /// before replacing it with a function that will call that saved filter.
    ///
    /// @param filter the current callback function will be stored here.
    /// @param userdata the pointer that is passed to the current event filter will
    /// be stored here.
    /// @return true on success or false if there is no event filter set.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setEventFilter
    public @NativeType("boolean") boolean getEventFilter(
        @Nullable PointerPtr filter,
        @Nullable PointerPtr userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetEventFilter);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (filter != null ? filter.segment() : MemorySegment.NULL),
                (MemorySegment) (userdata != null ? userdata.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add a callback to be triggered when an event is added to the event queue.
    ///
    /// `filter` will be called when an event happens, and its return value is
    /// ignored.
    ///
    /// **WARNING**: Be very careful of what you do in the event filter function,
    /// as it may run in a different thread!
    ///
    /// If the quit event is generated by a signal (e.g. SIGINT), it will bypass
    /// the internal queue and be delivered to the watch callback immediately, and
    /// arrive at the next event poll.
    ///
    /// Note: the callback is called for events posted by the user through
    /// SDL_PushEvent(), but not for disabled events, nor for events by a filter
    /// callback set with SDL_SetEventFilter(), nor for events posted by the user
    /// through SDL_PeepEvents().
    ///
    /// @param filter an SDL_EventFilter function to call when an event happens.
    /// @param userdata a pointer that is passed to `filter`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #removeEventWatch
    /// @see #setEventFilter
    public @NativeType("boolean") boolean addEventWatch(
        @Pointer(comment="SDL_EventFilter") MemorySegment filter,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddEventWatch);
        try {
            return (boolean) hFunction.invokeExact(
                filter,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Remove an event watch callback added with SDL_AddEventWatch().
    ///
    /// This function takes the same input as SDL_AddEventWatch() to identify and
    /// delete the corresponding callback.
    ///
    /// @param filter the function originally passed to SDL_AddEventWatch().
    /// @param userdata the pointer originally passed to SDL_AddEventWatch().
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addEventWatch
    public void removeEventWatch(
        @Pointer(comment="SDL_EventFilter") MemorySegment filter,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemoveEventWatch);
        try {
            hFunction.invokeExact(
                filter,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Run a specific filter function on the current event queue, removing any
    /// events for which the filter returns false.
    ///
    /// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
    /// this function does not change the filter permanently, it only uses the
    /// supplied filter until this function returns.
    ///
    /// @param filter the SDL_EventFilter function to call when an event happens.
    /// @param userdata a pointer that is passed to `filter`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getEventFilter
    /// @see #setEventFilter
    public void filterEvents(
        @Pointer(comment="SDL_EventFilter") MemorySegment filter,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FilterEvents);
        try {
            hFunction.invokeExact(
                filter,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the state of processing events by type.
    ///
    /// @param type the type of event; see SDL_EventType for details.
    /// @param enabled whether to process the event or not.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #eventEnabled
    public void setEventEnabled(
        @NativeType("Uint32") @Unsigned int type,
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetEventEnabled);
        try {
            hFunction.invokeExact(
                type,
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the state of processing events by type.
    ///
    /// @param type the type of event; see SDL_EventType for details.
    /// @return true if the event is being processed, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setEventEnabled
    public @NativeType("boolean") boolean eventEnabled(
        @NativeType("Uint32") @Unsigned int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EventEnabled);
        try {
            return (boolean) hFunction.invokeExact(
                type
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a set of user-defined events, and return the beginning event
    /// number for that set of events.
    ///
    /// @param numevents the number of events to be allocated.
    /// @return the beginning event number, or 0 if numevents is invalid or if
    /// there are not enough user-defined events left.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pushEvent
    public @NativeType("Uint32") @Unsigned int registerEvents(
        int numevents
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RegisterEvents);
        try {
            return (int) hFunction.invokeExact(
                numevents
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get window associated with an event.
    ///
    /// @param event an event containing a `windowID`.
    /// @return the associated window on success or NULL if there is none.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pollEvent
    /// @see #waitEvent
    /// @see #waitEventTimeout
    public SDL_Window getWindowFromEvent(
        @Nullable @Pointer ISDL_Event event
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowFromEvent);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (event != null ? event.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the directory where the application was run from.
    ///
    /// SDL caches the result of this call internally, but the first call to this
    /// function is not necessarily fast, so plan accordingly.
    ///
    /// **macOS and iOS Specific Functionality**: If the application is in a ".app"
    /// bundle, this function returns the Resource directory (e.g.
    /// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
    /// a property to the Info.plist file. Adding a string key with the name
    /// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
    /// behaviour.
    ///
    /// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
    /// application in /Applications/SDLApp/MyApp.app):
    ///
    /// - `resource`: bundle resource directory (the default). For example:
    /// `/Applications/SDLApp/MyApp.app/Contents/Resources`
    /// - `bundle`: the Bundle directory. For example:
    /// `/Applications/SDLApp/MyApp.app/`
    /// - `parent`: the containing directory of the bundle. For example:
    /// `/Applications/SDLApp/`
    ///
    /// **Nintendo 3DS Specific Functionality**: This function returns "romfs"
    /// directory of the application as it is uncommon to store resources outside
    /// the executable. As such it is not a writable directory.
    ///
    /// The returned path is guaranteed to end with a path separator ('\\' on
    /// Windows, '/' on most other platforms).
    ///
    /// @return an absolute path in UTF-8 encoding to the application data
    /// directory. NULL will be returned on error or when the platform
    /// doesn't implement this functionality, call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPrefPath
    public BytePtr getBasePath() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetBasePath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the user-and-app-specific path where files can be written.
    ///
    /// Get the "pref dir". This is meant to be where users can write personal
    /// files (preferences and save games, etc) that are specific to your
    /// application. This directory is unique per user, per application.
    ///
    /// This function will decide the appropriate location in the native
    /// filesystem, create the directory if necessary, and return a string of the
    /// absolute path to the directory in UTF-8 encoding.
    ///
    /// On Windows, the string might look like:
    ///
    /// `C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\`
    ///
    /// On Linux, the string might look like:
    ///
    /// `/home/bob/.local/share/My Program Name/`
    ///
    /// On macOS, the string might look like:
    ///
    /// `/Users/bob/Library/Application Support/My Program Name/`
    ///
    /// You should assume the path returned by this function is the only safe place
    /// to write files (and that SDL_GetBasePath(), while it might be writable, or
    /// even the parent of the returned path, isn't where you should be writing
    /// things).
    ///
    /// Both the org and app strings may become part of a directory name, so please
    /// follow these rules:
    ///
    /// - Try to use the same org string (_including case-sensitivity_) for all
    /// your applications that use this function.
    /// - Always use a unique app string for each one, and make sure it never
    /// changes for an app once you've decided on it.
    /// - Unicode characters are legal, as long as they are UTF-8 encoded, but...
    /// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
    /// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
    ///
    /// The returned path is guaranteed to end with a path separator ('\\' on
    /// Windows, '/' on most other platforms).
    ///
    /// @param org the name of your organization.
    /// @param app the name of your application.
    /// @return a UTF-8 string of the user directory in platform-dependent
    /// notation. NULL if there's a problem (creating directory failed,
    /// etc.). This should be freed with SDL_free() when it is no longer
    /// needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getBasePath
    public BytePtr getPrefPath(
        @Nullable BytePtr org,
        @Nullable BytePtr app
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPrefPath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (org != null ? org.segment() : MemorySegment.NULL),
                (MemorySegment) (app != null ? app.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Finds the most suitable user folder for a specific purpose.
    ///
    /// Many OSes provide certain standard folders for certain purposes, such as
    /// storing pictures, music or videos for a certain user. This function gives
    /// the path for many of those special locations.
    ///
    /// This function is specifically for _user_ folders, which are meant for the
    /// user to access and manage. For application-specific folders, meant to hold
    /// data for the application to manage, see SDL_GetBasePath() and
    /// SDL_GetPrefPath().
    ///
    /// The returned path is guaranteed to end with a path separator ('\\' on
    /// Windows, '/' on most other platforms).
    ///
    /// If NULL is returned, the error may be obtained with SDL_GetError().
    ///
    /// @param folder the type of folder to find.
    /// @return either a null-terminated C string containing the full path to the
    /// folder, or NULL if an error happened.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getUserFolder(
        @EnumType(SDL_Folder.class) int folder
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetUserFolder);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                folder
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a directory, and any missing parent directories.
    ///
    /// This reports success if `path` already exists as a directory.
    ///
    /// If parent directories are missing, it will also create them. Note that if
    /// this fails, it will not remove any parent directories it already made.
    ///
    /// @param path the path of the directory to create.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean createDirectory(
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateDirectory);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Enumerate a directory through a callback function.
    ///
    /// This function provides every directory entry through an app-provided
    /// callback, called once for each directory entry, until all results have been
    /// provided or the callback returns either SDL_ENUM_SUCCESS or
    /// SDL_ENUM_FAILURE.
    ///
    /// This will return false if there was a system problem in general, or if a
    /// callback returns SDL_ENUM_FAILURE. A successful return means a callback
    /// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
    /// were enumerated.
    ///
    /// @param path the path of the directory to enumerate.
    /// @param callback a function that is called for each entry in the directory.
    /// @param userdata a pointer that is passed to `callback`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean enumerateDirectory(
        @Nullable BytePtr path,
        @Pointer(comment="SDL_EnumerateDirectoryCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EnumerateDirectory);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Remove a file or an empty directory.
    ///
    /// Directories that are not empty will fail; this function will not recursely
    /// delete directory trees.
    ///
    /// @param path the path to remove from the filesystem.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean removePath(
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemovePath);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Rename a file or directory.
    ///
    /// If the file at `newpath` already exists, it will replaced.
    ///
    /// Note that this will not copy files across filesystems/drives/volumes, as
    /// that is a much more complicated (and possibly time-consuming) operation.
    ///
    /// Which is to say, if this function fails, SDL_CopyFile() to a temporary file
    /// in the same directory as `newpath`, then SDL_RenamePath() from the
    /// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work
    /// for files. Renaming a non-empty directory across filesystems is
    /// dramatically more complex, however.
    ///
    /// @param oldpath the old path.
    /// @param newpath the new path.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean renamePath(
        @Nullable BytePtr oldpath,
        @Nullable BytePtr newpath
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenamePath);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (oldpath != null ? oldpath.segment() : MemorySegment.NULL),
                (MemorySegment) (newpath != null ? newpath.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a file.
    ///
    /// If the file at `newpath` already exists, it will be overwritten with the
    /// contents of the file at `oldpath`.
    ///
    /// This function will block until the copy is complete, which might be a
    /// significant time for large files on slow disks. On some platforms, the copy
    /// can be handed off to the OS itself, but on others SDL might just open both
    /// paths, and read from one and write to the other.
    ///
    /// Note that this is not an atomic operation! If something tries to read from
    /// `newpath` while the copy is in progress, it will see an incomplete copy of
    /// the data, and if the calling thread terminates (or the power goes out)
    /// during the copy, `newpath`'s previous contents will be gone, replaced with
    /// an incomplete copy of the data. To avoid this risk, it is recommended that
    /// the app copy to a temporary file in the same directory as `newpath`, and if
    /// the copy is successful, use SDL_RenamePath() to replace `newpath` with the
    /// temporary file. This will ensure that reads of `newpath` will either see a
    /// complete copy of the data, or it will see the pre-copy state of `newpath`.
    ///
    /// This function attempts to synchronize the newly-copied data to disk before
    /// returning, if the platform allows it, so that the renaming trick will not
    /// have a problem in a system crash or power failure, where the file could be
    /// renamed but the contents never made it from the system file cache to the
    /// physical disk.
    ///
    /// If the copy fails for any reason, the state of `newpath` is undefined. It
    /// might be half a copy, it might be the untouched data of what was already
    /// there, or it might be a zero-byte file, etc.
    ///
    /// @param oldpath the old path.
    /// @param newpath the new path.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean copyFile(
        @Nullable BytePtr oldpath,
        @Nullable BytePtr newpath
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CopyFile);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (oldpath != null ? oldpath.segment() : MemorySegment.NULL),
                (MemorySegment) (newpath != null ? newpath.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get information about a filesystem path.
    ///
    /// @param path the path to query.
    /// @param info a pointer filled in with information about the path, or NULL to
    /// check for the existence of a file.
    /// @return true on success or false if the file doesn't exist, or another
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getPathInfo(
        @Nullable BytePtr path,
        @Nullable @Pointer ISDL_PathInfo info
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPathInfo);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                (MemorySegment) (info != null ? info.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Enumerate a directory tree, filtered by pattern, and return a list.
    ///
    /// Files are filtered out if they don't match the string in `pattern`, which
    /// may contain wildcard characters '\*' (match everything) and '?' (match one
    /// character). If pattern is NULL, no filtering is done and all results are
    /// returned. Subdirectories are permitted, and are specified with a path
    /// separator of '/'. Wildcard characters '\*' and '?' never match a path
    /// separator.
    ///
    /// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
    /// case-insensitive.
    ///
    /// The returned array is always NULL-terminated, for your iterating
    /// convenience, but if `count` is non-NULL, on return it will contain the
    /// number of items in the array, not counting the NULL terminator.
    ///
    /// @param path the path of the directory to enumerate.
    /// @param pattern the pattern that files in the directory must match. Can be
    /// NULL.
    /// @param flags `SDL_GLOB_*` bitflags that affect this search.
    /// @param count on return, will be set to the number of items in the returned
    /// array. Can be NULL.
    /// @return an array of strings on success or NULL on failure; call
    /// SDL_GetError() for more information. This is a single allocation
    /// that should be freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public PointerPtr globDirectory(
        @Nullable BytePtr path,
        @Nullable BytePtr pattern,
        @EnumType(SDL_GlobFlags.class) int flags,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GlobDirectory);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                (MemorySegment) (pattern != null ? pattern.segment() : MemorySegment.NULL),
                flags,
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get what the system believes is the "current working directory."
    ///
    /// For systems without a concept of a current working directory, this will
    /// still attempt to provide something reasonable.
    ///
    /// SDL does not provide a means to _change_ the current working directory; for
    /// platforms without this concept, this would cause surprises with file access
    /// outside of SDL.
    ///
    /// The returned path is guaranteed to end with a path separator ('\\' on
    /// Windows, '/' on most other platforms).
    ///
    /// @return a UTF-8 string of the current working directory in
    /// platform-dependent notation. NULL if there's a problem. This
    /// should be freed with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getCurrentDirectory() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentDirectory);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add support for gamepads that SDL is unaware of or change the binding of an
    /// existing gamepad.
    ///
    /// The mapping string has the format "GUID,name,mapping", where GUID is the
    /// string value from SDL_GUIDToString(), name is the human readable string for
    /// the device and mappings are gamepad mappings to joystick ones. Under
    /// Windows there is a reserved GUID of "xinput" that covers all XInput
    /// devices. The mapping format for joystick is:
    ///
    /// - `bX`: a joystick button, index X
    /// - `hX.Y`: hat X with value Y
    /// - `aX`: axis X of the joystick
    ///
    /// Buttons can be used as a gamepad axes and vice versa.
    ///
    /// If a device with this GUID is already plugged in, SDL will generate an
    /// SDL_EVENT_GAMEPAD_ADDED event.
    ///
    /// This string shows an example of a valid mapping for a gamepad:
    ///
    /// ```c
    /// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
    /// ```
    ///
    /// @param mapping the mapping string.
    /// @return 1 if a new mapping is added, 0 if an existing mapping is updated,
    /// -1 on failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addGamepadMappingsFromFile
    /// @see #addGamepadMappingsFromIO
    /// @see #getGamepadMapping
    /// @see #getGamepadMappingForGUID
    /// @see #HINT_GAMECONTROLLERCONFIG
    /// @see #HINT_GAMECONTROLLERCONFIG_FILE
    /// @see #GAMEPAD_ADDED
    public int addGamepadMapping(
        @Nullable BytePtr mapping
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddGamepadMapping);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (mapping != null ? mapping.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load a set of gamepad mappings from an SDL_IOStream.
    ///
    /// You can call this function several times, if needed, to load different
    /// database files.
    ///
    /// If a new mapping is loaded for an already known gamepad GUID, the later
    /// version will overwrite the one currently loaded.
    ///
    /// Any new mappings for already plugged in controllers will generate
    /// SDL_EVENT_GAMEPAD_ADDED events.
    ///
    /// Mappings not belonging to the current platform or with no platform field
    /// specified will be ignored (i.e. mappings for Linux will be ignored in
    /// Windows, etc).
    ///
    /// This function will load the text database entirely in memory before
    /// processing it, so take this into consideration if you are in a memory
    /// constrained environment.
    ///
    /// @param src the data stream for the mappings to be added.
    /// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
    /// in the case of an error.
    /// @return the number of mappings added or -1 on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addGamepadMapping
    /// @see #addGamepadMappingsFromFile
    /// @see #getGamepadMapping
    /// @see #getGamepadMappingForGUID
    /// @see #HINT_GAMECONTROLLERCONFIG
    /// @see #HINT_GAMECONTROLLERCONFIG_FILE
    /// @see #GAMEPAD_ADDED
    public int addGamepadMappingsFromIO(
        @Nullable SDL_IOStream src,
        @NativeType("boolean") boolean closeio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddGamepadMappingsFromIO);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                closeio
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load a set of gamepad mappings from a file.
    ///
    /// You can call this function several times, if needed, to load different
    /// database files.
    ///
    /// If a new mapping is loaded for an already known gamepad GUID, the later
    /// version will overwrite the one currently loaded.
    ///
    /// Any new mappings for already plugged in controllers will generate
    /// SDL_EVENT_GAMEPAD_ADDED events.
    ///
    /// Mappings not belonging to the current platform or with no platform field
    /// specified will be ignored (i.e. mappings for Linux will be ignored in
    /// Windows, etc).
    ///
    /// @param file the mappings file to load.
    /// @return the number of mappings added or -1 on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addGamepadMapping
    /// @see #addGamepadMappingsFromIO
    /// @see #getGamepadMapping
    /// @see #getGamepadMappingForGUID
    /// @see #HINT_GAMECONTROLLERCONFIG
    /// @see #HINT_GAMECONTROLLERCONFIG_FILE
    /// @see #GAMEPAD_ADDED
    public int addGamepadMappingsFromFile(
        @Nullable BytePtr file
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddGamepadMappingsFromFile);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Reinitialize the SDL mapping database to its initial state.
    ///
    /// This will generate gamepad events as needed if device mappings change.
    ///
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean reloadGamepadMappings() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReloadGamepadMappings);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current gamepad mappings.
    ///
    /// @param count a pointer filled in with the number of mappings returned, can
    /// be NULL.
    /// @return an array of the mapping strings, NULL-terminated, or NULL on
    /// failure; call SDL_GetError() for more information. This is a
    /// single allocation that should be freed with SDL_free() when it is
    /// no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public PointerPtr getGamepadMappings(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadMappings);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the gamepad mapping string for a given GUID.
    ///
    /// @param guid a structure containing the GUID for which a mapping is desired.
    /// @return a mapping string or NULL on failure; call SDL_GetError() for more
    /// information. This should be freed with SDL_free() when it is no
    /// longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickGUIDForID
    /// @see #getJoystickGUID
    public BytePtr getGamepadMappingForGUID(
        SDL_GUID guid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadMappingForGUID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                guid.segment()
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current mapping of a gamepad.
    ///
    /// Details about mappings are discussed with SDL_AddGamepadMapping().
    ///
    /// @param gamepad the gamepad you want to get the current mapping for.
    /// @return a string that has the gamepad's mapping or NULL if no mapping is
    /// available; call SDL_GetError() for more information. This should
    /// be freed with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addGamepadMapping
    /// @see #getGamepadMappingForID
    /// @see #getGamepadMappingForGUID
    /// @see #setGamepadMapping
    public BytePtr getGamepadMapping(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadMapping);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the current mapping of a joystick or gamepad.
    ///
    /// Details about mappings are discussed with SDL_AddGamepadMapping().
    ///
    /// @param instance_id the joystick instance ID.
    /// @param mapping the mapping to use for this device, or NULL to clear the
    /// mapping.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addGamepadMapping
    /// @see #getGamepadMapping
    public @NativeType("boolean") boolean setGamepadMapping(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id,
        @Nullable BytePtr mapping
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGamepadMapping);
        try {
            return (boolean) hFunction.invokeExact(
                instance_id,
                (MemorySegment) (mapping != null ? mapping.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a gamepad is currently connected.
    ///
    /// @return true if a gamepad is connected, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepads
    public @NativeType("boolean") boolean hasGamepad() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasGamepad);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected gamepads.
    ///
    /// @param count a pointer filled in with the number of gamepads returned, may
    /// be NULL.
    /// @return a 0 terminated array of joystick instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasGamepad
    /// @see #openGamepad
    public @Pointer(comment="SDL_JoystickID") @Unsigned IntPtr getGamepads(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepads);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check if the given joystick is supported by the gamepad interface.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return true if the given joystick is supported by the gamepad interface,
    /// false if it isn't or it's an invalid index.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoysticks
    /// @see #openGamepad
    public @NativeType("boolean") boolean isGamepad(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsGamepad);
        try {
            return (boolean) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a gamepad.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the name of the selected gamepad. If no name can be found, this
    /// function returns NULL; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadName
    /// @see #getGamepads
    public BytePtr getGamepadNameForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadNameForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent path of a gamepad.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the path of the selected gamepad. If no path can be found, this
    /// function returns NULL; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadPath
    /// @see #getGamepads
    public BytePtr getGamepadPathForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadPathForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the player index of a gamepad.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the player index of a gamepad, or -1 if it's not available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadPlayerIndex
    /// @see #getGamepads
    public int getGamepadPlayerIndexForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadPlayerIndexForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation-dependent GUID of a gamepad.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the GUID of the selected gamepad. If called on an invalid index,
    /// this function returns a zero GUID.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GUIDToString
    /// @see #getGamepads
    public SDL_GUID getGamepadGUIDForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadGUIDForID);
        try {
            return new SDL_GUID((MemorySegment) hFunction.invokeExact(
                instance_id
            ));
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB vendor ID of a gamepad, if available.
    ///
    /// This can be called before any gamepads are opened. If the vendor ID isn't
    /// available this function returns 0.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the USB vendor ID of the selected gamepad. If called on an invalid
    /// index, this function returns zero.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadVendor
    /// @see #getGamepads
    public @NativeType("Uint16") @Unsigned short getGamepadVendorForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadVendorForID);
        try {
            return (short) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB product ID of a gamepad, if available.
    ///
    /// This can be called before any gamepads are opened. If the product ID isn't
    /// available this function returns 0.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the USB product ID of the selected gamepad. If called on an
    /// invalid index, this function returns zero.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadProduct
    /// @see #getGamepads
    public @NativeType("Uint16") @Unsigned short getGamepadProductForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadProductForID);
        try {
            return (short) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the product version of a gamepad, if available.
    ///
    /// This can be called before any gamepads are opened. If the product version
    /// isn't available this function returns 0.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the product version of the selected gamepad. If called on an
    /// invalid index, this function returns zero.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadProductVersion
    /// @see #getGamepads
    public @NativeType("Uint16") @Unsigned short getGamepadProductVersionForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadProductVersionForID);
        try {
            return (short) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of a gamepad.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the gamepad type.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadType
    /// @see #getGamepads
    /// @see #getRealGamepadTypeForID
    public @EnumType(SDL_GamepadType.class) int getGamepadTypeForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadTypeForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of a gamepad, ignoring any mapping override.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the gamepad type.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadTypeForID
    /// @see #getGamepads
    /// @see #getRealGamepadType
    public @EnumType(SDL_GamepadType.class) int getRealGamepadTypeForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRealGamepadTypeForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the mapping of a gamepad.
    ///
    /// This can be called before any gamepads are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the mapping string. Returns NULL if no mapping is available. This
    /// should be freed with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepads
    /// @see #getGamepadMapping
    public BytePtr getGamepadMappingForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadMappingForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a gamepad for use.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return a gamepad identifier or NULL if an error occurred; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeGamepad
    /// @see #isGamepad
    public SDL_Gamepad openGamepad(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenGamepad);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Gamepad(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_Gamepad associated with a joystick instance ID, if it has been
    /// opened.
    ///
    /// @param instance_id the joystick instance ID of the gamepad.
    /// @return an SDL_Gamepad on success or NULL on failure or if it hasn't been
    /// opened yet; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Gamepad getGamepadFromID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadFromID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Gamepad(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_Gamepad associated with a player index.
    ///
    /// @param player_index the player index, which different from the instance ID.
    /// @return the SDL_Gamepad associated with a player index.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadPlayerIndex
    /// @see #setGamepadPlayerIndex
    public SDL_Gamepad getGamepadFromPlayerIndex(
        int player_index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadFromPlayerIndex);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                player_index
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Gamepad(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with an opened gamepad.
    ///
    /// These properties are shared with the underlying joystick object.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED
    /// that has adjustable brightness
    /// - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED
    /// that has adjustable color
    /// - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a
    /// player LED
    /// - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has
    /// left/right rumble
    /// - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has
    /// simple trigger rumble
    ///
    /// @param gamepad a gamepad identifier previously returned by
    /// SDL_OpenGamepad().
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getGamepadProperties(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the instance ID of an opened gamepad.
    ///
    /// @param gamepad a gamepad identifier previously returned by
    /// SDL_OpenGamepad().
    /// @return the instance ID of the specified gamepad on success or 0 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_JoystickID") @Unsigned int getGamepadID(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadID);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation-dependent name for an opened gamepad.
    ///
    /// @param gamepad a gamepad identifier previously returned by
    /// SDL_OpenGamepad().
    /// @return the implementation dependent name for the gamepad, or NULL if
    /// there is no name or the identifier passed is invalid.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadNameForID
    public BytePtr getGamepadName(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation-dependent path for an opened gamepad.
    ///
    /// @param gamepad a gamepad identifier previously returned by
    /// SDL_OpenGamepad().
    /// @return the implementation dependent path for the gamepad, or NULL if
    /// there is no path or the identifier passed is invalid.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadPathForID
    public BytePtr getGamepadPath(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadPath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of an opened gamepad.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
    /// available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadTypeForID
    public @EnumType(SDL_GamepadType.class) int getGamepadType(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadType);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of an opened gamepad, ignoring any mapping override.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
    /// available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRealGamepadTypeForID
    public @EnumType(SDL_GamepadType.class) int getRealGamepadType(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRealGamepadType);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the player index of an opened gamepad.
    ///
    /// For XInput gamepads this returns the XInput user index.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the player index for gamepad, or -1 if it's not available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setGamepadPlayerIndex
    public int getGamepadPlayerIndex(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadPlayerIndex);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the player index of an opened gamepad.
    ///
    /// @param gamepad the gamepad object to adjust.
    /// @param player_index player index to assign to this gamepad, or -1 to clear
    /// the player index and turn off player LEDs.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadPlayerIndex
    public @NativeType("boolean") boolean setGamepadPlayerIndex(
        @Nullable SDL_Gamepad gamepad,
        int player_index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGamepadPlayerIndex);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                player_index
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB vendor ID of an opened gamepad, if available.
    ///
    /// If the vendor ID isn't available this function returns 0.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the USB vendor ID, or zero if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadVendorForID
    public @NativeType("Uint16") @Unsigned short getGamepadVendor(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadVendor);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB product ID of an opened gamepad, if available.
    ///
    /// If the product ID isn't available this function returns 0.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the USB product ID, or zero if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadProductForID
    public @NativeType("Uint16") @Unsigned short getGamepadProduct(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadProduct);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the product version of an opened gamepad, if available.
    ///
    /// If the product version isn't available this function returns 0.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the USB product version, or zero if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadProductVersionForID
    public @NativeType("Uint16") @Unsigned short getGamepadProductVersion(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadProductVersion);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the firmware version of an opened gamepad, if available.
    ///
    /// If the firmware version isn't available this function returns 0.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the gamepad firmware version, or zero if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint16") @Unsigned short getGamepadFirmwareVersion(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadFirmwareVersion);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the serial number of an opened gamepad, if available.
    ///
    /// Returns the serial number of the gamepad, or NULL if it is not available.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the serial number, or NULL if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getGamepadSerial(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadSerial);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the Steam Input handle of an opened gamepad, if available.
    ///
    /// Returns an InputHandle_t for the gamepad that can be used with Steam Input
    /// API: https://partner.steamgames.com/doc/api/ISteamInput
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the gamepad handle, or 0 if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint64") @Unsigned long getGamepadSteamHandle(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadSteamHandle);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the connection state of a gamepad.
    ///
    /// @param gamepad the gamepad object to query.
    /// @return the connection state on success or
    /// `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_JoystickConnectionState.class) int getGamepadConnectionState(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadConnectionState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the battery state of a gamepad.
    ///
    /// You should never take a battery status as absolute truth. Batteries
    /// (especially failing batteries) are delicate hardware, and the values
    /// reported here are best estimates based on what that hardware reports. It's
    /// not uncommon for older batteries to lose stored power much faster than it
    /// reports, or completely drain when reporting it has 20 percent left, etc.
    ///
    /// @param gamepad the gamepad object to query.
    /// @param percent a pointer filled in with the percentage of battery life
    /// left, between 0 and 100, or NULL to ignore. This will be
    /// filled in with -1 we can't determine a value or there is no
    /// battery.
    /// @return the current battery state.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_PowerState.class) int getGamepadPowerInfo(
        @Nullable SDL_Gamepad gamepad,
        @Nullable IntPtr percent
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadPowerInfo);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                (MemorySegment) (percent != null ? percent.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check if a gamepad has been opened and is currently connected.
    ///
    /// @param gamepad a gamepad identifier previously returned by
    /// SDL_OpenGamepad().
    /// @return true if the gamepad has been opened and is currently connected, or
    /// false if not.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean gamepadConnected(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GamepadConnected);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the underlying joystick from a gamepad.
    ///
    /// This function will give you a SDL_Joystick object, which allows you to use
    /// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful
    /// for getting a joystick's position at any given time, even if it hasn't
    /// moved (moving it would produce an event, which would have the axis' value).
    ///
    /// The pointer returned is owned by the SDL_Gamepad. You should not call
    /// SDL_CloseJoystick() on it, for example, since doing so will likely cause
    /// SDL to crash.
    ///
    /// @param gamepad the gamepad object that you want to get a joystick from.
    /// @return an SDL_Joystick object, or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Joystick getGamepadJoystick(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadJoystick);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Joystick(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the state of gamepad event processing.
    ///
    /// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
    /// and check the state of the gamepad when you want gamepad information.
    ///
    /// @param enabled whether to process gamepad events or not.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #gamepadEventsEnabled
    /// @see #updateGamepads
    public void setGamepadEventsEnabled(
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGamepadEventsEnabled);
        try {
            hFunction.invokeExact(
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the state of gamepad event processing.
    ///
    /// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
    /// and check the state of the gamepad when you want gamepad information.
    ///
    /// @return true if gamepad events are being processed, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setGamepadEventsEnabled
    public @NativeType("boolean") boolean gamepadEventsEnabled() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GamepadEventsEnabled);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL joystick layer bindings for a gamepad.
    ///
    /// @param gamepad a gamepad.
    /// @param count a pointer filled in with the number of bindings returned.
    /// @return a NULL terminated array of pointers to bindings or NULL on
    /// failure; call SDL_GetError() for more information. This is a
    /// single allocation that should be freed with SDL_free() when it is
    /// no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public PointerPtr getGamepadBindings(
        @Nullable SDL_Gamepad gamepad,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadBindings);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Manually pump gamepad updates if not using the loop.
    ///
    /// This function is called automatically by the event loop if events are
    /// enabled. Under such circumstances, it will not be necessary to call this
    /// function.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void updateGamepads() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateGamepads);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a string into SDL_GamepadType enum.
    ///
    /// This function is called internally to translate SDL_Gamepad mapping strings
    /// for the underlying joystick device into the consistent SDL_Gamepad mapping.
    /// You do not normally need to call this function unless you are parsing
    /// SDL_Gamepad mappings in your own code.
    ///
    /// @param str string representing a SDL_GamepadType type.
    /// @return the SDL_GamepadType enum corresponding to the input string, or
    /// `SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadStringForType
    public @EnumType(SDL_GamepadType.class) int getGamepadTypeFromString(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadTypeFromString);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert from an SDL_GamepadType enum to a string.
    ///
    /// @param type an enum value for a given SDL_GamepadType.
    /// @return a string for the given type, or NULL if an invalid type is
    /// specified. The string returned is of the format used by
    /// SDL_Gamepad mapping strings.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadTypeFromString
    public BytePtr getGamepadStringForType(
        @EnumType(SDL_GamepadType.class) int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadStringForType);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                type
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a string into SDL_GamepadAxis enum.
    ///
    /// This function is called internally to translate SDL_Gamepad mapping strings
    /// for the underlying joystick device into the consistent SDL_Gamepad mapping.
    /// You do not normally need to call this function unless you are parsing
    /// SDL_Gamepad mappings in your own code.
    ///
    /// Note specially that "righttrigger" and "lefttrigger" map to
    /// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,
    /// respectively.
    ///
    /// @param str string representing a SDL_Gamepad axis.
    /// @return the SDL_GamepadAxis enum corresponding to the input string, or
    /// `SDL_GAMEPAD_AXIS_INVALID` if no match was found.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadStringForAxis
    public @EnumType(SDL_GamepadAxis.class) int getGamepadAxisFromString(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadAxisFromString);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert from an SDL_GamepadAxis enum to a string.
    ///
    /// @param axis an enum value for a given SDL_GamepadAxis.
    /// @return a string for the given axis, or NULL if an invalid axis is
    /// specified. The string returned is of the format used by
    /// SDL_Gamepad mapping strings.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadAxisFromString
    public BytePtr getGamepadStringForAxis(
        @EnumType(SDL_GamepadAxis.class) int axis
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadStringForAxis);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                axis
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether a gamepad has a given axis.
    ///
    /// This merely reports whether the gamepad's mapping defined this axis, as
    /// that is all the information SDL has about the physical device.
    ///
    /// @param gamepad a gamepad.
    /// @param axis an axis enum value (an SDL_GamepadAxis value).
    /// @return true if the gamepad has this axis, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #gamepadHasButton
    /// @see #getGamepadAxis
    public @NativeType("boolean") boolean gamepadHasAxis(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadAxis.class) int axis
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GamepadHasAxis);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                axis
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of an axis control on a gamepad.
    ///
    /// The axis indices start at index 0.
    ///
    /// For thumbsticks, the state is a value ranging from -32768 (up/left) to
    /// 32767 (down/right).
    ///
    /// Triggers range from 0 when released to 32767 when fully pressed, and never
    /// return a negative value. Note that this differs from the value reported by
    /// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.
    ///
    /// @param gamepad a gamepad.
    /// @param axis an axis index (one of the SDL_GamepadAxis values).
    /// @return axis state (including 0) on success or 0 (also) on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #gamepadHasAxis
    /// @see #getGamepadButton
    public @NativeType("Sint16") short getGamepadAxis(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadAxis.class) int axis
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadAxis);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                axis
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a string into an SDL_GamepadButton enum.
    ///
    /// This function is called internally to translate SDL_Gamepad mapping strings
    /// for the underlying joystick device into the consistent SDL_Gamepad mapping.
    /// You do not normally need to call this function unless you are parsing
    /// SDL_Gamepad mappings in your own code.
    ///
    /// @param str string representing a SDL_Gamepad axis.
    /// @return the SDL_GamepadButton enum corresponding to the input string, or
    /// `SDL_GAMEPAD_BUTTON_INVALID` if no match was found.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadStringForButton
    public @EnumType(SDL_GamepadButton.class) int getGamepadButtonFromString(
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadButtonFromString);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert from an SDL_GamepadButton enum to a string.
    ///
    /// @param button an enum value for a given SDL_GamepadButton.
    /// @return a string for the given button, or NULL if an invalid button is
    /// specified. The string returned is of the format used by
    /// SDL_Gamepad mapping strings.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadButtonFromString
    public BytePtr getGamepadStringForButton(
        @EnumType(SDL_GamepadButton.class) int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadStringForButton);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                button
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether a gamepad has a given button.
    ///
    /// This merely reports whether the gamepad's mapping defined this button, as
    /// that is all the information SDL has about the physical device.
    ///
    /// @param gamepad a gamepad.
    /// @param button a button enum value (an SDL_GamepadButton value).
    /// @return true if the gamepad has this button, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #gamepadHasAxis
    public @NativeType("boolean") boolean gamepadHasButton(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadButton.class) int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GamepadHasButton);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                button
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of a button on a gamepad.
    ///
    /// @param gamepad a gamepad.
    /// @param button a button index (one of the SDL_GamepadButton values).
    /// @return true if the button is pressed, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #gamepadHasButton
    /// @see #getGamepadAxis
    public @NativeType("boolean") boolean getGamepadButton(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadButton.class) int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadButton);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                button
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the label of a button on a gamepad.
    ///
    /// @param type the type of gamepad to check.
    /// @param button a button index (one of the SDL_GamepadButton values).
    /// @return the SDL_GamepadButtonLabel enum corresponding to the button label.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadButtonLabel
    public @EnumType(SDL_GamepadButtonLabel.class) int getGamepadButtonLabelForType(
        @EnumType(SDL_GamepadType.class) int type,
        @EnumType(SDL_GamepadButton.class) int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadButtonLabelForType);
        try {
            return (int) hFunction.invokeExact(
                type,
                button
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the label of a button on a gamepad.
    ///
    /// @param gamepad a gamepad.
    /// @param button a button index (one of the SDL_GamepadButton values).
    /// @return the SDL_GamepadButtonLabel enum corresponding to the button label.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadButtonLabelForType
    public @EnumType(SDL_GamepadButtonLabel.class) int getGamepadButtonLabel(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadButton.class) int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadButtonLabel);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                button
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of touchpads on a gamepad.
    ///
    /// @param gamepad a gamepad.
    /// @return number of touchpads.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumGamepadTouchpadFingers
    public int getNumGamepadTouchpads(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumGamepadTouchpads);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of supported simultaneous fingers on a touchpad on a game
    /// gamepad.
    ///
    /// @param gamepad a gamepad.
    /// @param touchpad a touchpad.
    /// @return number of supported simultaneous fingers.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadTouchpadFinger
    /// @see #getNumGamepadTouchpads
    public int getNumGamepadTouchpadFingers(
        @Nullable SDL_Gamepad gamepad,
        int touchpad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumGamepadTouchpadFingers);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                touchpad
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of a finger on a touchpad on a gamepad.
    ///
    /// @param gamepad a gamepad.
    /// @param touchpad a touchpad.
    /// @param finger a finger.
    /// @param down a pointer filled with true if the finger is down, false
    /// otherwise, may be NULL.
    /// @param x a pointer filled with the x position, normalized 0 to 1, with the
    /// origin in the upper left, may be NULL.
    /// @param y a pointer filled with the y position, normalized 0 to 1, with the
    /// origin in the upper left, may be NULL.
    /// @param pressure a pointer filled with pressure value, may be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumGamepadTouchpadFingers
    public @NativeType("boolean") boolean getGamepadTouchpadFinger(
        @Nullable SDL_Gamepad gamepad,
        int touchpad,
        int finger,
        @Nullable @Pointer(comment="boolean") BytePtr down,
        @Nullable FloatPtr x,
        @Nullable FloatPtr y,
        @Nullable FloatPtr pressure
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadTouchpadFinger);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                touchpad,
                finger,
                (MemorySegment) (down != null ? down.segment() : MemorySegment.NULL),
                (MemorySegment) (x != null ? x.segment() : MemorySegment.NULL),
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL),
                (MemorySegment) (pressure != null ? pressure.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a gamepad has a particular sensor.
    ///
    /// @param gamepad the gamepad to query.
    /// @param type the type of sensor to query.
    /// @return true if the sensor exists, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadSensorData
    /// @see #getGamepadSensorDataRate
    /// @see #setGamepadSensorEnabled
    public @NativeType("boolean") boolean gamepadHasSensor(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_SensorType.class) int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GamepadHasSensor);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                type
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set whether data reporting for a gamepad sensor is enabled.
    ///
    /// @param gamepad the gamepad to update.
    /// @param type the type of sensor to enable/disable.
    /// @param enabled whether data reporting should be enabled.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #gamepadHasSensor
    /// @see #gamepadSensorEnabled
    public @NativeType("boolean") boolean setGamepadSensorEnabled(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_SensorType.class) int type,
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGamepadSensorEnabled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                type,
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether sensor data reporting is enabled for a gamepad.
    ///
    /// @param gamepad the gamepad to query.
    /// @param type the type of sensor to query.
    /// @return true if the sensor is enabled, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setGamepadSensorEnabled
    public @NativeType("boolean") boolean gamepadSensorEnabled(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_SensorType.class) int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GamepadSensorEnabled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                type
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the data rate (number of events per second) of a gamepad sensor.
    ///
    /// @param gamepad the gamepad to query.
    /// @param type the type of sensor to query.
    /// @return the data rate, or 0.0f if the data rate is not available.
    ///
    /// @since This function is available since SDL 3.2.0.
    public float getGamepadSensorDataRate(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_SensorType.class) int type
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadSensorDataRate);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                type
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of a gamepad sensor.
    ///
    /// The number of values and interpretation of the data is sensor dependent.
    /// See SDL_sensor.h for the details for each type of sensor.
    ///
    /// @param gamepad the gamepad to query.
    /// @param type the type of sensor to query.
    /// @param data a pointer filled with the current sensor state.
    /// @param num_values the number of values to write to data.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getGamepadSensorData(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_SensorType.class) int type,
        @Nullable FloatPtr data,
        int num_values
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadSensorData);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                type,
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                num_values
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start a rumble effect on a gamepad.
    ///
    /// Each call to this function cancels any previous rumble effect, and calling
    /// it with 0 intensity stops any rumbling.
    ///
    /// This function requires you to process SDL events or call
    /// SDL_UpdateJoysticks() to update rumble state.
    ///
    /// @param gamepad the gamepad to vibrate.
    /// @param low_frequency_rumble the intensity of the low frequency (left)
    /// rumble motor, from 0 to 0xFFFF.
    /// @param high_frequency_rumble the intensity of the high frequency (right)
    /// rumble motor, from 0 to 0xFFFF.
    /// @param duration_ms the duration of the rumble effect, in milliseconds.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean rumbleGamepad(
        @Nullable SDL_Gamepad gamepad,
        @NativeType("Uint16") @Unsigned short low_frequency_rumble,
        @NativeType("Uint16") @Unsigned short high_frequency_rumble,
        @NativeType("Uint32") @Unsigned int duration_ms
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RumbleGamepad);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                low_frequency_rumble,
                high_frequency_rumble,
                duration_ms
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start a rumble effect in the gamepad's triggers.
    ///
    /// Each call to this function cancels any previous trigger rumble effect, and
    /// calling it with 0 intensity stops any rumbling.
    ///
    /// Note that this is rumbling of the _triggers_ and not the gamepad as a
    /// whole. This is currently only supported on Xbox One gamepads. If you want
    /// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.
    ///
    /// This function requires you to process SDL events or call
    /// SDL_UpdateJoysticks() to update rumble state.
    ///
    /// @param gamepad the gamepad to vibrate.
    /// @param left_rumble the intensity of the left trigger rumble motor, from 0
    /// to 0xFFFF.
    /// @param right_rumble the intensity of the right trigger rumble motor, from 0
    /// to 0xFFFF.
    /// @param duration_ms the duration of the rumble effect, in milliseconds.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rumbleGamepad
    public @NativeType("boolean") boolean rumbleGamepadTriggers(
        @Nullable SDL_Gamepad gamepad,
        @NativeType("Uint16") @Unsigned short left_rumble,
        @NativeType("Uint16") @Unsigned short right_rumble,
        @NativeType("Uint32") @Unsigned int duration_ms
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RumbleGamepadTriggers);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                left_rumble,
                right_rumble,
                duration_ms
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update a gamepad's LED color.
    ///
    /// An example of a joystick LED is the light on the back of a PlayStation 4's
    /// DualShock 4 controller.
    ///
    /// For gamepads with a single color LED, the maximum of the RGB values will be
    /// used as the LED brightness.
    ///
    /// @param gamepad the gamepad to update.
    /// @param red the intensity of the red LED.
    /// @param green the intensity of the green LED.
    /// @param blue the intensity of the blue LED.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setGamepadLED(
        @Nullable SDL_Gamepad gamepad,
        @NativeType("Uint8") @Unsigned byte red,
        @NativeType("Uint8") @Unsigned byte green,
        @NativeType("Uint8") @Unsigned byte blue
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGamepadLED);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                red,
                green,
                blue
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Send a gamepad specific effect packet.
    ///
    /// @param gamepad the gamepad to affect.
    /// @param data the data to send to the gamepad.
    /// @param size the size of the data to send to the gamepad.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean sendGamepadEffect(
        @Nullable SDL_Gamepad gamepad,
        @Pointer(comment="void*") MemorySegment data,
        int size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SendGamepadEffect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                data,
                size
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close a gamepad previously opened with SDL_OpenGamepad().
    ///
    /// @param gamepad a gamepad identifier previously returned by
    /// SDL_OpenGamepad().
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openGamepad
    public void closeGamepad(
        @Nullable SDL_Gamepad gamepad
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseGamepad);
        try {
            hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return the sfSymbolsName for a given button on a gamepad on Apple
    /// platforms.
    ///
    /// @param gamepad the gamepad to query.
    /// @param button a button on the gamepad.
    /// @return the sfSymbolsName or NULL if the name can't be found.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadAppleSFSymbolsNameForAxis
    public BytePtr getGamepadAppleSFSymbolsNameForButton(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadButton.class) int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadAppleSFSymbolsNameForButton);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                button
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.
    ///
    /// @param gamepad the gamepad to query.
    /// @param axis an axis on the gamepad.
    /// @return the sfSymbolsName or NULL if the name can't be found.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGamepadAppleSFSymbolsNameForButton
    public BytePtr getGamepadAppleSFSymbolsNameForAxis(
        @Nullable SDL_Gamepad gamepad,
        @EnumType(SDL_GamepadAxis.class) int axis
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGamepadAppleSFSymbolsNameForAxis);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (gamepad != null ? gamepad.segment() : MemorySegment.NULL),
                axis
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Checks for GPU runtime support.
    ///
    /// @param format_flags a bitflag indicating which shader formats the app is
    /// able to provide.
    /// @param name the preferred GPU driver, or NULL to let SDL pick the optimal
    /// driver.
    /// @return true if supported, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUDevice
    public @NativeType("boolean") boolean GPUSupportsShaderFormats(
        @EnumType(SDL_GPUShaderFormat.class) int format_flags,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GPUSupportsShaderFormats);
        try {
            return (boolean) hFunction.invokeExact(
                format_flags,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Checks for GPU runtime support.
    ///
    /// @param props the properties to use.
    /// @return true if supported, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUDeviceWithProperties
    public @NativeType("boolean") boolean GPUSupportsProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GPUSupportsProperties);
        try {
            return (boolean) hFunction.invokeExact(
                props
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a GPU context.
    ///
    /// @param format_flags a bitflag indicating which shader formats the app is
    /// able to provide.
    /// @param debug_mode enable debug mode properties and validations.
    /// @param name the preferred GPU driver, or NULL to let SDL pick the optimal
    /// driver.
    /// @return a GPU context on success or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGPUShaderFormats
    /// @see #getGPUDeviceDriver
    /// @see #destroyGPUDevice
    /// @see #GPUSupportsShaderFormats
    public SDL_GPUDevice createGPUDevice(
        @EnumType(SDL_GPUShaderFormat.class) int format_flags,
        @NativeType("boolean") boolean debug_mode,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUDevice);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                format_flags,
                debug_mode,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUDevice(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a GPU context.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode
    /// properties and validations, defaults to true.
    /// - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer
    /// energy efficiency over maximum GPU performance, defaults to false.
    /// - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to
    /// use, if a specific one is desired.
    ///
    /// These are the current shader format properties:
    ///
    /// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to
    /// provide shaders for an NDA platform.
    /// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to
    /// provide SPIR-V shaders if applicable.
    /// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to
    /// provide DXBC shaders if applicable
    /// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to
    /// provide DXIL shaders if applicable.
    /// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to
    /// provide MSL shaders if applicable.
    /// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to
    /// provide Metal shader libraries if applicable.
    ///
    /// With the D3D12 renderer:
    ///
    /// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to
    /// use for all vertex semantics, default is "TEXCOORD".
    ///
    /// @param props the properties to use.
    /// @return a GPU context on success or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGPUShaderFormats
    /// @see #getGPUDeviceDriver
    /// @see #destroyGPUDevice
    /// @see #GPUSupportsProperties
    public SDL_GPUDevice createGPUDeviceWithProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUDeviceWithProperties);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUDevice(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroys a GPU context previously returned by SDL_CreateGPUDevice.
    ///
    /// @param device a GPU Context to destroy.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUDevice
    public void destroyGPUDevice(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyGPUDevice);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of GPU drivers compiled into SDL.
    ///
    /// @return the number of built in GPU drivers.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGPUDriver
    public int getNumGPUDrivers() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumGPUDrivers);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of a built in GPU driver.
    ///
    /// The GPU drivers are presented in the order in which they are normally
    /// checked during initialization.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",
    /// "metal" or "direct3d12". These never have Unicode characters, and are not
    /// meant to be proper names.
    ///
    /// @param index the index of a GPU driver.
    /// @return the name of the GPU driver with the given **index**.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumGPUDrivers
    public BytePtr getGPUDriver(
        int index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGPUDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                index
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Returns the name of the backend used to create this GPU context.
    ///
    /// @param device a GPU context to query.
    /// @return the name of the device's driver, or NULL on error.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getGPUDeviceDriver(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGPUDeviceDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Returns the supported shader formats for this GPU context.
    ///
    /// @param device a GPU context to query.
    /// @return a bitflag indicating which shader formats the driver is able to
    /// consume.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_GPUShaderFormat.class) int getGPUShaderFormats(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGPUShaderFormats);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a pipeline object to be used in a compute workflow.
    ///
    /// Shader resource bindings must be authored to follow a particular order
    /// depending on the shader format.
    ///
    /// For SPIR-V shaders, use the following resource sets:
    ///
    /// - 0: Sampled textures, followed by read-only storage textures, followed by
    /// read-only storage buffers
    /// - 1: Read-write storage textures, followed by read-write storage buffers
    /// - 2: Uniform buffers
    ///
    /// For DXBC and DXIL shaders, use the following register order:
    ///
    /// - (t[n], space0): Sampled textures, followed by read-only storage textures,
    /// followed by read-only storage buffers
    /// - (u[n], space1): Read-write storage textures, followed by read-write
    /// storage buffers
    /// - (b[n], space2): Uniform buffers
    ///
    /// For MSL/metallib, use the following order:
    ///
    /// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,
    /// followed by read-write storage buffers
    /// - [[texture]]: Sampled textures, followed by read-only storage textures,
    /// followed by read-write storage textures
    ///
    /// There are optional properties that can be provided through `props`. These
    /// are the supported properties:
    ///
    /// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be
    /// displayed in debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the compute pipeline to
    /// create.
    /// @return a compute pipeline object on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindGPUComputePipeline
    /// @see #releaseGPUComputePipeline
    public SDL_GPUComputePipeline createGPUComputePipeline(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUComputePipelineCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUComputePipeline);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUComputePipeline(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a pipeline object to be used in a graphics workflow.
    ///
    /// There are optional properties that can be provided through `props`. These
    /// are the supported properties:
    ///
    /// - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be
    /// displayed in debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the graphics pipeline to
    /// create.
    /// @return a graphics pipeline object on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    /// @see #bindGPUGraphicsPipeline
    /// @see #releaseGPUGraphicsPipeline
    public SDL_GPUGraphicsPipeline createGPUGraphicsPipeline(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUGraphicsPipelineCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUGraphicsPipeline);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUGraphicsPipeline(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a sampler object to be used when binding textures in a graphics
    /// workflow.
    ///
    /// There are optional properties that can be provided through `props`. These
    /// are the supported properties:
    ///
    /// - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed
    /// in debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the sampler to create.
    /// @return a sampler object on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #bindGPUVertexSamplers
    /// @see #bindGPUFragmentSamplers
    /// @see #releaseGPUSampler
    public SDL_GPUSampler createGPUSampler(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUSamplerCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUSampler);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUSampler(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a shader to be used when creating a graphics pipeline.
    ///
    /// Shader resource bindings must be authored to follow a particular order
    /// depending on the shader format.
    ///
    /// For SPIR-V shaders, use the following resource sets:
    ///
    /// For vertex shaders:
    ///
    /// - 0: Sampled textures, followed by storage textures, followed by storage
    /// buffers
    /// - 1: Uniform buffers
    ///
    /// For fragment shaders:
    ///
    /// - 2: Sampled textures, followed by storage textures, followed by storage
    /// buffers
    /// - 3: Uniform buffers
    ///
    /// For DXBC and DXIL shaders, use the following register order:
    ///
    /// For vertex shaders:
    ///
    /// - (t[n], space0): Sampled textures, followed by storage textures, followed
    /// by storage buffers
    /// - (s[n], space0): Samplers with indices corresponding to the sampled
    /// textures
    /// - (b[n], space1): Uniform buffers
    ///
    /// For pixel shaders:
    ///
    /// - (t[n], space2): Sampled textures, followed by storage textures, followed
    /// by storage buffers
    /// - (s[n], space2): Samplers with indices corresponding to the sampled
    /// textures
    /// - (b[n], space3): Uniform buffers
    ///
    /// For MSL/metallib, use the following order:
    ///
    /// - [[texture]]: Sampled textures, followed by storage textures
    /// - [[sampler]]: Samplers with indices corresponding to the sampled textures
    /// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0
    /// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.
    /// Rather than manually authoring vertex buffer indices, use the
    /// [[stage_in]] attribute which will automatically use the vertex input
    /// information from the SDL_GPUGraphicsPipeline.
    ///
    /// Shader semantics other than system-value semantics do not matter in D3D12
    /// and for ease of use the SDL implementation assumes that non system-value
    /// semantics will all be TEXCOORD. If you are using HLSL as the shader source
    /// language, your vertex semantics should start at TEXCOORD0 and increment
    /// like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic
    /// prefix to something other than TEXCOORD you can use
    /// SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with
    /// SDL_CreateGPUDeviceWithProperties().
    ///
    /// There are optional properties that can be provided through `props`. These
    /// are the supported properties:
    ///
    /// - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in
    /// debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the shader to create.
    /// @return a shader object on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUGraphicsPipeline
    /// @see #releaseGPUShader
    public SDL_GPUShader createGPUShader(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUShaderCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUShader);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUShader(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a texture object to be used in graphics or compute workflows.
    ///
    /// The contents of this texture are undefined until data is written to the
    /// texture.
    ///
    /// Note that certain combinations of usage flags are invalid. For example, a
    /// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.
    ///
    /// If you request a sample count higher than the hardware supports, the
    /// implementation will automatically fall back to the highest available sample
    /// count.
    ///
    /// There are optional properties that can be provided through
    /// SDL_GPUTextureCreateInfo's `props`. These are the supported properties:
    ///
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if
    /// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
    /// to a color with this red intensity. Defaults to zero.
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if
    /// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
    /// to a color with this green intensity. Defaults to zero.
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if
    /// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
    /// to a color with this blue intensity. Defaults to zero.
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if
    /// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
    /// to a color with this alpha intensity. Defaults to zero.
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)
    /// if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear
    /// the texture to a depth of this value. Defaults to zero.
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER`: (Direct3D 12
    /// only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,
    /// clear the texture to a stencil of this Uint8 value. Defaults to zero.
    /// - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed
    /// in debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the texture to create.
    /// @return a texture object on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #uploadToGPUTexture
    /// @see #downloadFromGPUTexture
    /// @see #bindGPUVertexSamplers
    /// @see #bindGPUVertexStorageTextures
    /// @see #bindGPUFragmentSamplers
    /// @see #bindGPUFragmentStorageTextures
    /// @see #bindGPUComputeStorageTextures
    /// @see #blitGPUTexture
    /// @see #releaseGPUTexture
    /// @see #GPUTextureSupportsFormat
    public SDL_GPUTexture createGPUTexture(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUTextureCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUTexture);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUTexture(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a buffer object to be used in graphics or compute workflows.
    ///
    /// The contents of this buffer are undefined until data is written to the
    /// buffer.
    ///
    /// Note that certain combinations of usage flags are invalid. For example, a
    /// buffer cannot have both the VERTEX and INDEX flags.
    ///
    /// If you use a STORAGE flag, the data in the buffer must respect std140
    /// layout conventions. In practical terms this means you must ensure that vec3
    /// and vec4 fields are 16-byte aligned.
    ///
    /// For better understanding of underlying concepts and memory management with
    /// SDL GPU API, you may refer
    /// [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)
    /// .
    ///
    /// There are optional properties that can be provided through `props`. These
    /// are the supported properties:
    ///
    /// - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in
    /// debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the buffer to create.
    /// @return a buffer object on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #uploadToGPUBuffer
    /// @see #downloadFromGPUBuffer
    /// @see #copyGPUBufferToBuffer
    /// @see #bindGPUVertexBuffers
    /// @see #bindGPUIndexBuffer
    /// @see #bindGPUVertexStorageBuffers
    /// @see #bindGPUFragmentStorageBuffers
    /// @see #drawGPUPrimitivesIndirect
    /// @see #drawGPUIndexedPrimitivesIndirect
    /// @see #bindGPUComputeStorageBuffers
    /// @see #dispatchGPUComputeIndirect
    /// @see #releaseGPUBuffer
    public SDL_GPUBuffer createGPUBuffer(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUBufferCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUBuffer);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUBuffer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a transfer buffer to be used when uploading to or downloading from
    /// graphics resources.
    ///
    /// Download buffers can be particularly expensive to create, so it is good
    /// practice to reuse them if data will be downloaded regularly.
    ///
    /// There are optional properties that can be provided through `props`. These
    /// are the supported properties:
    ///
    /// - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be
    /// displayed in debugging tools.
    ///
    /// @param device a GPU Context.
    /// @param createinfo a struct describing the state of the transfer buffer to
    /// create.
    /// @return a transfer buffer on success, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #uploadToGPUBuffer
    /// @see #downloadFromGPUBuffer
    /// @see #uploadToGPUTexture
    /// @see #downloadFromGPUTexture
    /// @see #releaseGPUTransferBuffer
    public SDL_GPUTransferBuffer createGPUTransferBuffer(
        @Nullable SDL_GPUDevice device,
        @Nullable @Pointer ISDL_GPUTransferBufferCreateInfo createinfo
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateGPUTransferBuffer);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (createinfo != null ? createinfo.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUTransferBuffer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets an arbitrary string constant to label a buffer.
    ///
    /// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with
    /// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.
    ///
    /// @param device a GPU Context.
    /// @param buffer a buffer to attach the name to.
    /// @param text a UTF-8 string constant to mark as the name of the buffer.
    ///
    /// @threadsafety This function is not thread safe, you must make sure the
    /// buffer is not simultaneously used by any other thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUBuffer
    public void setGPUBufferName(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUBuffer buffer,
        @Nullable BytePtr text
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUBufferName);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (buffer != null ? buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (text != null ? text.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets an arbitrary string constant to label a texture.
    ///
    /// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with
    /// SDL_CreateGPUTexture instead of this function to avoid thread safety
    /// issues.
    ///
    /// @param device a GPU Context.
    /// @param texture a texture to attach the name to.
    /// @param text a UTF-8 string constant to mark as the name of the texture.
    ///
    /// @threadsafety This function is not thread safe, you must make sure the
    /// texture is not simultaneously used by any other thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUTexture
    public void setGPUTextureName(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUTexture texture,
        @Nullable BytePtr text
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUTextureName);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (text != null ? text.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Inserts an arbitrary string label into the command buffer callstream.
    ///
    /// Useful for debugging.
    ///
    /// @param command_buffer a command buffer.
    /// @param text a UTF-8 string constant to insert as the label.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void insertGPUDebugLabel(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable BytePtr text
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_InsertGPUDebugLabel);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (text != null ? text.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Begins a debug group with an arbitary name.
    ///
    /// Used for denoting groups of calls when viewing the command buffer
    /// callstream in a graphics debugging tool.
    ///
    /// Each call to SDL_PushGPUDebugGroup must have a corresponding call to
    /// SDL_PopGPUDebugGroup.
    ///
    /// On some backends (e.g. Metal), pushing a debug group during a
    /// render/blit/compute pass will create a group that is scoped to the native
    /// pass rather than the command buffer. For best results, if you push a debug
    /// group during a pass, always pop it in the same pass.
    ///
    /// @param command_buffer a command buffer.
    /// @param name a UTF-8 string constant that names the group.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #popGPUDebugGroup
    public void pushGPUDebugGroup(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PushGPUDebugGroup);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Ends the most-recently pushed debug group.
    ///
    /// @param command_buffer a command buffer.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pushGPUDebugGroup
    public void popGPUDebugGroup(
        @Nullable SDL_GPUCommandBuffer command_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PopGPUDebugGroup);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given texture as soon as it is safe to do so.
    ///
    /// You must not reference the texture after calling this function.
    ///
    /// @param device a GPU context.
    /// @param texture a texture to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUTexture(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUTexture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given sampler as soon as it is safe to do so.
    ///
    /// You must not reference the sampler after calling this function.
    ///
    /// @param device a GPU context.
    /// @param sampler a sampler to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUSampler(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUSampler sampler
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUSampler);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (sampler != null ? sampler.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given buffer as soon as it is safe to do so.
    ///
    /// You must not reference the buffer after calling this function.
    ///
    /// @param device a GPU context.
    /// @param buffer a buffer to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUBuffer(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUBuffer buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (buffer != null ? buffer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given transfer buffer as soon as it is safe to do so.
    ///
    /// You must not reference the transfer buffer after calling this function.
    ///
    /// @param device a GPU context.
    /// @param transfer_buffer a transfer buffer to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUTransferBuffer(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUTransferBuffer transfer_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUTransferBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (transfer_buffer != null ? transfer_buffer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given compute pipeline as soon as it is safe to do so.
    ///
    /// You must not reference the compute pipeline after calling this function.
    ///
    /// @param device a GPU context.
    /// @param compute_pipeline a compute pipeline to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUComputePipeline(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUComputePipeline compute_pipeline
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUComputePipeline);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (compute_pipeline != null ? compute_pipeline.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given shader as soon as it is safe to do so.
    ///
    /// You must not reference the shader after calling this function.
    ///
    /// @param device a GPU context.
    /// @param shader a shader to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUShader(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUShader shader
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUShader);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (shader != null ? shader.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Frees the given graphics pipeline as soon as it is safe to do so.
    ///
    /// You must not reference the graphics pipeline after calling this function.
    ///
    /// @param device a GPU context.
    /// @param graphics_pipeline a graphics pipeline to be destroyed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void releaseGPUGraphicsPipeline(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUGraphicsPipeline graphics_pipeline
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUGraphicsPipeline);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (graphics_pipeline != null ? graphics_pipeline.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Acquire a command buffer.
    ///
    /// This command buffer is managed by the implementation and should not be
    /// freed by the user. The command buffer may only be used on the thread it was
    /// acquired on. The command buffer should be submitted on the thread it was
    /// acquired on.
    ///
    /// It is valid to acquire multiple command buffers on the same thread at once.
    /// In fact a common design pattern is to acquire two command buffers per frame
    /// where one is dedicated to render and compute passes and the other is
    /// dedicated to copy passes and other preparatory work such as generating
    /// mipmaps. Interleaving commands between the two command buffers reduces the
    /// total amount of passes overall which improves rendering performance.
    ///
    /// @param device a GPU context.
    /// @return a command buffer, or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #submitGPUCommandBuffer
    /// @see #submitGPUCommandBufferAndAcquireFence
    public SDL_GPUCommandBuffer acquireGPUCommandBuffer(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AcquireGPUCommandBuffer);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUCommandBuffer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Pushes data to a vertex uniform slot on the command buffer.
    ///
    /// Subsequent draw calls will use this uniform data.
    ///
    /// The data being pushed must respect std140 layout conventions. In practical
    /// terms this means you must ensure that vec3 and vec4 fields are 16-byte
    /// aligned.
    ///
    /// @param command_buffer a command buffer.
    /// @param slot_index the vertex uniform slot to push data to.
    /// @param data client data to write.
    /// @param length the length of the data to write.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void pushGPUVertexUniformData(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @NativeType("Uint32") @Unsigned int slot_index,
        @Pointer(comment="void*") MemorySegment data,
        @NativeType("Uint32") @Unsigned int length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PushGPUVertexUniformData);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                slot_index,
                data,
                length
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Pushes data to a fragment uniform slot on the command buffer.
    ///
    /// Subsequent draw calls will use this uniform data.
    ///
    /// The data being pushed must respect std140 layout conventions. In practical
    /// terms this means you must ensure that vec3 and vec4 fields are 16-byte
    /// aligned.
    ///
    /// @param command_buffer a command buffer.
    /// @param slot_index the fragment uniform slot to push data to.
    /// @param data client data to write.
    /// @param length the length of the data to write.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void pushGPUFragmentUniformData(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @NativeType("Uint32") @Unsigned int slot_index,
        @Pointer(comment="void*") MemorySegment data,
        @NativeType("Uint32") @Unsigned int length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PushGPUFragmentUniformData);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                slot_index,
                data,
                length
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Pushes data to a uniform slot on the command buffer.
    ///
    /// Subsequent draw calls will use this uniform data.
    ///
    /// The data being pushed must respect std140 layout conventions. In practical
    /// terms this means you must ensure that vec3 and vec4 fields are 16-byte
    /// aligned.
    ///
    /// @param command_buffer a command buffer.
    /// @param slot_index the uniform slot to push data to.
    /// @param data client data to write.
    /// @param length the length of the data to write.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void pushGPUComputeUniformData(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @NativeType("Uint32") @Unsigned int slot_index,
        @Pointer(comment="void*") MemorySegment data,
        @NativeType("Uint32") @Unsigned int length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PushGPUComputeUniformData);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                slot_index,
                data,
                length
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Begins a render pass on a command buffer.
    ///
    /// A render pass consists of a set of texture subresources (or depth slices in
    /// the 3D texture case) which will be rendered to during the render pass,
    /// along with corresponding clear values and load/store operations. All
    /// operations related to graphics pipelines must take place inside of a render
    /// pass. A default viewport and scissor state are automatically set when this
    /// is called. You cannot begin another render pass, or begin a compute pass or
    /// copy pass until you have ended the render pass.
    ///
    /// @param command_buffer a command buffer.
    /// @param color_target_infos an array of texture subresources with
    /// corresponding clear values and load/store ops.
    /// @param num_color_targets the number of color targets in the
    /// color_target_infos array.
    /// @param depth_stencil_target_info a texture subresource with corresponding
    /// clear value and load/store ops, may be
    /// NULL.
    /// @return a render pass handle.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #endGPURenderPass
    public SDL_GPURenderPass beginGPURenderPass(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable @Pointer ISDL_GPUColorTargetInfo color_target_infos,
        @NativeType("Uint32") @Unsigned int num_color_targets,
        @Nullable @Pointer ISDL_GPUDepthStencilTargetInfo depth_stencil_target_info
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BeginGPURenderPass);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (color_target_infos != null ? color_target_infos.segment() : MemorySegment.NULL),
                num_color_targets,
                (MemorySegment) (depth_stencil_target_info != null ? depth_stencil_target_info.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPURenderPass(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds a graphics pipeline on a render pass to be used in rendering.
    ///
    /// A graphics pipeline must be bound before making any draw calls.
    ///
    /// @param render_pass a render pass handle.
    /// @param graphics_pipeline the graphics pipeline to bind.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void bindGPUGraphicsPipeline(
        @Nullable SDL_GPURenderPass render_pass,
        @Nullable SDL_GPUGraphicsPipeline graphics_pipeline
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUGraphicsPipeline);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (graphics_pipeline != null ? graphics_pipeline.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the current viewport state on a command buffer.
    ///
    /// @param render_pass a render pass handle.
    /// @param viewport the viewport to set.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void setGPUViewport(
        @Nullable SDL_GPURenderPass render_pass,
        @Nullable @Pointer ISDL_GPUViewport viewport
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUViewport);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (viewport != null ? viewport.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the current scissor state on a command buffer.
    ///
    /// @param render_pass a render pass handle.
    /// @param scissor the scissor area to set.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void setGPUScissor(
        @Nullable SDL_GPURenderPass render_pass,
        @Nullable @Pointer ISDL_Rect scissor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUScissor);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (scissor != null ? scissor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the current blend constants on a command buffer.
    ///
    /// @param render_pass a render pass handle.
    /// @param blend_constants the blend constant color.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #CONSTANT_COLOR
    /// @see #ONE_MINUS_CONSTANT_COLOR
    public void setGPUBlendConstants(
        @Nullable SDL_GPURenderPass render_pass,
        SDL_FColor blend_constants
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUBlendConstants);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                blend_constants.segment()
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the current stencil reference value on a command buffer.
    ///
    /// @param render_pass a render pass handle.
    /// @param reference the stencil reference value to set.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void setGPUStencilReference(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint8") @Unsigned byte reference
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUStencilReference);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                reference
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds vertex buffers on a command buffer for use with subsequent draw
    /// calls.
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the vertex buffer slot to begin binding from.
    /// @param bindings an array of SDL_GPUBufferBinding structs containing vertex
    /// buffers and offset values.
    /// @param num_bindings the number of bindings in the bindings array.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void bindGPUVertexBuffers(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer ISDL_GPUBufferBinding bindings,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUVertexBuffers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (bindings != null ? bindings.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds an index buffer on a command buffer for use with subsequent draw
    /// calls.
    ///
    /// @param render_pass a render pass handle.
    /// @param binding a pointer to a struct containing an index buffer and offset.
    /// @param index_element_size whether the index values in the buffer are 16- or
    /// 32-bit.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void bindGPUIndexBuffer(
        @Nullable SDL_GPURenderPass render_pass,
        @Nullable @Pointer ISDL_GPUBufferBinding binding,
        @EnumType(SDL_GPUIndexElementSize.class) int index_element_size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUIndexBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (binding != null ? binding.segment() : MemorySegment.NULL),
                index_element_size
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds texture-sampler pairs for use on the vertex shader.
    ///
    /// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the vertex sampler slot to begin binding from.
    /// @param texture_sampler_bindings an array of texture-sampler binding
    /// structs.
    /// @param num_bindings the number of texture-sampler pairs to bind from the
    /// array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUVertexSamplers(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer ISDL_GPUTextureSamplerBinding texture_sampler_bindings,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUVertexSamplers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (texture_sampler_bindings != null ? texture_sampler_bindings.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds storage textures for use on the vertex shader.
    ///
    /// These textures must have been created with
    /// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the vertex storage texture slot to begin binding from.
    /// @param storage_textures an array of storage textures.
    /// @param num_bindings the number of storage texture to bind from the array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUVertexStorageTextures(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer SDL_GPUTexture.Ptr storage_textures,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUVertexStorageTextures);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (storage_textures != null ? storage_textures.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds storage buffers for use on the vertex shader.
    ///
    /// These buffers must have been created with
    /// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the vertex storage buffer slot to begin binding from.
    /// @param storage_buffers an array of buffers.
    /// @param num_bindings the number of buffers to bind from the array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUVertexStorageBuffers(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer SDL_GPUBuffer.Ptr storage_buffers,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUVertexStorageBuffers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (storage_buffers != null ? storage_buffers.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds texture-sampler pairs for use on the fragment shader.
    ///
    /// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the fragment sampler slot to begin binding from.
    /// @param texture_sampler_bindings an array of texture-sampler binding
    /// structs.
    /// @param num_bindings the number of texture-sampler pairs to bind from the
    /// array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUFragmentSamplers(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer ISDL_GPUTextureSamplerBinding texture_sampler_bindings,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUFragmentSamplers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (texture_sampler_bindings != null ? texture_sampler_bindings.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds storage textures for use on the fragment shader.
    ///
    /// These textures must have been created with
    /// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the fragment storage texture slot to begin binding from.
    /// @param storage_textures an array of storage textures.
    /// @param num_bindings the number of storage textures to bind from the array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUFragmentStorageTextures(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer SDL_GPUTexture.Ptr storage_textures,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUFragmentStorageTextures);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (storage_textures != null ? storage_textures.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds storage buffers for use on the fragment shader.
    ///
    /// These buffers must have been created with
    /// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param render_pass a render pass handle.
    /// @param first_slot the fragment storage buffer slot to begin binding from.
    /// @param storage_buffers an array of storage buffers.
    /// @param num_bindings the number of storage buffers to bind from the array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUFragmentStorageBuffers(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer SDL_GPUBuffer.Ptr storage_buffers,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUFragmentStorageBuffers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (storage_buffers != null ? storage_buffers.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draws data using bound graphics state with an index buffer and instancing
    /// enabled.
    ///
    /// You must not call this function before binding a graphics pipeline.
    ///
    /// Note that the `first_vertex` and `first_instance` parameters are NOT
    /// compatible with built-in vertex/instance ID variables in shaders (for
    /// example, SV_VertexID); GPU APIs and shader languages do not define these
    /// built-in variables consistently, so if your shader depends on them, the
    /// only way to keep behavior consistent and portable is to always pass 0 for
    /// the correlating parameter in the draw calls.
    ///
    /// @param render_pass a render pass handle.
    /// @param num_indices the number of indices to draw per instance.
    /// @param num_instances the number of instances to draw.
    /// @param first_index the starting index within the index buffer.
    /// @param vertex_offset value added to vertex index before indexing into the
    /// vertex buffer.
    /// @param first_instance the ID of the first instance to draw.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void drawGPUIndexedPrimitives(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int num_indices,
        @NativeType("Uint32") @Unsigned int num_instances,
        @NativeType("Uint32") @Unsigned int first_index,
        @NativeType("Sint32") int vertex_offset,
        @NativeType("Uint32") @Unsigned int first_instance
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DrawGPUIndexedPrimitives);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                num_indices,
                num_instances,
                first_index,
                vertex_offset,
                first_instance
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draws data using bound graphics state.
    ///
    /// You must not call this function before binding a graphics pipeline.
    ///
    /// Note that the `first_vertex` and `first_instance` parameters are NOT
    /// compatible with built-in vertex/instance ID variables in shaders (for
    /// example, SV_VertexID); GPU APIs and shader languages do not define these
    /// built-in variables consistently, so if your shader depends on them, the
    /// only way to keep behavior consistent and portable is to always pass 0 for
    /// the correlating parameter in the draw calls.
    ///
    /// @param render_pass a render pass handle.
    /// @param num_vertices the number of vertices to draw.
    /// @param num_instances the number of instances that will be drawn.
    /// @param first_vertex the index of the first vertex to draw.
    /// @param first_instance the ID of the first instance to draw.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void drawGPUPrimitives(
        @Nullable SDL_GPURenderPass render_pass,
        @NativeType("Uint32") @Unsigned int num_vertices,
        @NativeType("Uint32") @Unsigned int num_instances,
        @NativeType("Uint32") @Unsigned int first_vertex,
        @NativeType("Uint32") @Unsigned int first_instance
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DrawGPUPrimitives);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                num_vertices,
                num_instances,
                first_vertex,
                first_instance
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draws data using bound graphics state and with draw parameters set from a
    /// buffer.
    ///
    /// The buffer must consist of tightly-packed draw parameter sets that each
    /// match the layout of SDL_GPUIndirectDrawCommand. You must not call this
    /// function before binding a graphics pipeline.
    ///
    /// @param render_pass a render pass handle.
    /// @param buffer a buffer containing draw parameters.
    /// @param offset the offset to start reading from the draw buffer.
    /// @param draw_count the number of draw parameter sets that should be read
    /// from the draw buffer.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void drawGPUPrimitivesIndirect(
        @Nullable SDL_GPURenderPass render_pass,
        @Nullable SDL_GPUBuffer buffer,
        @NativeType("Uint32") @Unsigned int offset,
        @NativeType("Uint32") @Unsigned int draw_count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DrawGPUPrimitivesIndirect);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (buffer != null ? buffer.segment() : MemorySegment.NULL),
                offset,
                draw_count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draws data using bound graphics state with an index buffer enabled and with
    /// draw parameters set from a buffer.
    ///
    /// The buffer must consist of tightly-packed draw parameter sets that each
    /// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call
    /// this function before binding a graphics pipeline.
    ///
    /// @param render_pass a render pass handle.
    /// @param buffer a buffer containing draw parameters.
    /// @param offset the offset to start reading from the draw buffer.
    /// @param draw_count the number of draw parameter sets that should be read
    /// from the draw buffer.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void drawGPUIndexedPrimitivesIndirect(
        @Nullable SDL_GPURenderPass render_pass,
        @Nullable SDL_GPUBuffer buffer,
        @NativeType("Uint32") @Unsigned int offset,
        @NativeType("Uint32") @Unsigned int draw_count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DrawGPUIndexedPrimitivesIndirect);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (buffer != null ? buffer.segment() : MemorySegment.NULL),
                offset,
                draw_count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Ends the given render pass.
    ///
    /// All bound graphics state on the render pass command buffer is unset. The
    /// render pass handle is now invalid.
    ///
    /// @param render_pass a render pass handle.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void endGPURenderPass(
        @Nullable SDL_GPURenderPass render_pass
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EndGPURenderPass);
        try {
            hFunction.invokeExact(
                (MemorySegment) (render_pass != null ? render_pass.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Begins a compute pass on a command buffer.
    ///
    /// A compute pass is defined by a set of texture subresources and buffers that
    /// may be written to by compute pipelines. These textures and buffers must
    /// have been created with the COMPUTE_STORAGE_WRITE bit or the
    /// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture
    /// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the
    /// texture in the compute pass. All operations related to compute pipelines
    /// must take place inside of a compute pass. You must not begin another
    /// compute pass, or a render pass or copy pass before ending the compute pass.
    ///
    /// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT
    /// implicitly synchronized. This means you may cause data races by both
    /// reading and writing a resource region in a compute pass, or by writing
    /// multiple times to a resource region. If your compute work depends on
    /// reading the completed output from a previous dispatch, you MUST end the
    /// current compute pass and begin a new one before you can safely access the
    /// data. Otherwise you will receive unexpected results. Reading and writing a
    /// texture in the same compute pass is only supported by specific texture
    /// formats. Make sure you check the format support!
    ///
    /// @param command_buffer a command buffer.
    /// @param storage_texture_bindings an array of writeable storage texture
    /// binding structs.
    /// @param num_storage_texture_bindings the number of storage textures to bind
    /// from the array.
    /// @param storage_buffer_bindings an array of writeable storage buffer binding
    /// structs.
    /// @param num_storage_buffer_bindings the number of storage buffers to bind
    /// from the array.
    /// @return a compute pass handle.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #endGPUComputePass
    public SDL_GPUComputePass beginGPUComputePass(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable @Pointer ISDL_GPUStorageTextureReadWriteBinding storage_texture_bindings,
        @NativeType("Uint32") @Unsigned int num_storage_texture_bindings,
        @Nullable @Pointer ISDL_GPUStorageBufferReadWriteBinding storage_buffer_bindings,
        @NativeType("Uint32") @Unsigned int num_storage_buffer_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BeginGPUComputePass);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (storage_texture_bindings != null ? storage_texture_bindings.segment() : MemorySegment.NULL),
                num_storage_texture_bindings,
                (MemorySegment) (storage_buffer_bindings != null ? storage_buffer_bindings.segment() : MemorySegment.NULL),
                num_storage_buffer_bindings
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUComputePass(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds a compute pipeline on a command buffer for use in compute dispatch.
    ///
    /// @param compute_pass a compute pass handle.
    /// @param compute_pipeline a compute pipeline to bind.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void bindGPUComputePipeline(
        @Nullable SDL_GPUComputePass compute_pass,
        @Nullable SDL_GPUComputePipeline compute_pipeline
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUComputePipeline);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (compute_pipeline != null ? compute_pipeline.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds texture-sampler pairs for use on the compute shader.
    ///
    /// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param compute_pass a compute pass handle.
    /// @param first_slot the compute sampler slot to begin binding from.
    /// @param texture_sampler_bindings an array of texture-sampler binding
    /// structs.
    /// @param num_bindings the number of texture-sampler bindings to bind from the
    /// array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUComputeSamplers(
        @Nullable SDL_GPUComputePass compute_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer ISDL_GPUTextureSamplerBinding texture_sampler_bindings,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUComputeSamplers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (texture_sampler_bindings != null ? texture_sampler_bindings.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds storage textures as readonly for use on the compute pipeline.
    ///
    /// These textures must have been created with
    /// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param compute_pass a compute pass handle.
    /// @param first_slot the compute storage texture slot to begin binding from.
    /// @param storage_textures an array of storage textures.
    /// @param num_bindings the number of storage textures to bind from the array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUComputeStorageTextures(
        @Nullable SDL_GPUComputePass compute_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer SDL_GPUTexture.Ptr storage_textures,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUComputeStorageTextures);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (storage_textures != null ? storage_textures.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Binds storage buffers as readonly for use on the compute pipeline.
    ///
    /// These buffers must have been created with
    /// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.
    ///
    /// Be sure your shader is set up according to the requirements documented in
    /// SDL_CreateGPUShader().
    ///
    /// @param compute_pass a compute pass handle.
    /// @param first_slot the compute storage buffer slot to begin binding from.
    /// @param storage_buffers an array of storage buffer binding structs.
    /// @param num_bindings the number of storage buffers to bind from the array.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createGPUShader
    public void bindGPUComputeStorageBuffers(
        @Nullable SDL_GPUComputePass compute_pass,
        @NativeType("Uint32") @Unsigned int first_slot,
        @Nullable @Pointer SDL_GPUBuffer.Ptr storage_buffers,
        @NativeType("Uint32") @Unsigned int num_bindings
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BindGPUComputeStorageBuffers);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL),
                first_slot,
                (MemorySegment) (storage_buffers != null ? storage_buffers.segment() : MemorySegment.NULL),
                num_bindings
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Dispatches compute work.
    ///
    /// You must not call this function before binding a compute pipeline.
    ///
    /// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
    /// the dispatches write to the same resource region as each other, there is no
    /// guarantee of which order the writes will occur. If the write order matters,
    /// you MUST end the compute pass and begin another one.
    ///
    /// @param compute_pass a compute pass handle.
    /// @param groupcount_x number of local workgroups to dispatch in the X
    /// dimension.
    /// @param groupcount_y number of local workgroups to dispatch in the Y
    /// dimension.
    /// @param groupcount_z number of local workgroups to dispatch in the Z
    /// dimension.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void dispatchGPUCompute(
        @Nullable SDL_GPUComputePass compute_pass,
        @NativeType("Uint32") @Unsigned int groupcount_x,
        @NativeType("Uint32") @Unsigned int groupcount_y,
        @NativeType("Uint32") @Unsigned int groupcount_z
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DispatchGPUCompute);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL),
                groupcount_x,
                groupcount_y,
                groupcount_z
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Dispatches compute work with parameters set from a buffer.
    ///
    /// The buffer layout should match the layout of
    /// SDL_GPUIndirectDispatchCommand. You must not call this function before
    /// binding a compute pipeline.
    ///
    /// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
    /// the dispatches write to the same resource region as each other, there is no
    /// guarantee of which order the writes will occur. If the write order matters,
    /// you MUST end the compute pass and begin another one.
    ///
    /// @param compute_pass a compute pass handle.
    /// @param buffer a buffer containing dispatch parameters.
    /// @param offset the offset to start reading from the dispatch buffer.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void dispatchGPUComputeIndirect(
        @Nullable SDL_GPUComputePass compute_pass,
        @Nullable SDL_GPUBuffer buffer,
        @NativeType("Uint32") @Unsigned int offset
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DispatchGPUComputeIndirect);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (buffer != null ? buffer.segment() : MemorySegment.NULL),
                offset
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Ends the current compute pass.
    ///
    /// All bound compute state on the command buffer is unset. The compute pass
    /// handle is now invalid.
    ///
    /// @param compute_pass a compute pass handle.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void endGPUComputePass(
        @Nullable SDL_GPUComputePass compute_pass
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EndGPUComputePass);
        try {
            hFunction.invokeExact(
                (MemorySegment) (compute_pass != null ? compute_pass.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Maps a transfer buffer into application address space.
    ///
    /// You must unmap the transfer buffer before encoding upload commands. The
    /// memory is owned by the graphics driver - do NOT call SDL_free() on the
    /// returned pointer.
    ///
    /// @param device a GPU context.
    /// @param transfer_buffer a transfer buffer.
    /// @param cycle if true, cycles the transfer buffer if it is already bound.
    /// @return the address of the mapped transfer buffer memory, or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="void*") MemorySegment mapGPUTransferBuffer(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUTransferBuffer transfer_buffer,
        @NativeType("boolean") boolean cycle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MapGPUTransferBuffer);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (transfer_buffer != null ? transfer_buffer.segment() : MemorySegment.NULL),
                cycle
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unmaps a previously mapped transfer buffer.
    ///
    /// @param device a GPU context.
    /// @param transfer_buffer a previously mapped transfer buffer.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void unmapGPUTransferBuffer(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUTransferBuffer transfer_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnmapGPUTransferBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (transfer_buffer != null ? transfer_buffer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Begins a copy pass on a command buffer.
    ///
    /// All operations related to copying to or from buffers or textures take place
    /// inside a copy pass. You must not begin another copy pass, or a render pass
    /// or compute pass before ending the copy pass.
    ///
    /// @param command_buffer a command buffer.
    /// @return a copy pass handle.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_GPUCopyPass beginGPUCopyPass(
        @Nullable SDL_GPUCommandBuffer command_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BeginGPUCopyPass);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUCopyPass(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Uploads data from a transfer buffer to a texture.
    ///
    /// The upload occurs on the GPU timeline. You may assume that the upload has
    /// finished in subsequent commands.
    ///
    /// You must align the data in the transfer buffer to a multiple of the texel
    /// size of the texture format.
    ///
    /// @param copy_pass a copy pass handle.
    /// @param source the source transfer buffer with image layout information.
    /// @param destination the destination texture region.
    /// @param cycle if true, cycles the texture if the texture is bound, otherwise
    /// overwrites the data.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void uploadToGPUTexture(
        @Nullable SDL_GPUCopyPass copy_pass,
        @Nullable @Pointer ISDL_GPUTextureTransferInfo source,
        @Nullable @Pointer ISDL_GPUTextureRegion destination,
        @NativeType("boolean") boolean cycle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UploadToGPUTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (source != null ? source.segment() : MemorySegment.NULL),
                (MemorySegment) (destination != null ? destination.segment() : MemorySegment.NULL),
                cycle
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Uploads data from a transfer buffer to a buffer.
    ///
    /// The upload occurs on the GPU timeline. You may assume that the upload has
    /// finished in subsequent commands.
    ///
    /// @param copy_pass a copy pass handle.
    /// @param source the source transfer buffer with offset.
    /// @param destination the destination buffer with offset and size.
    /// @param cycle if true, cycles the buffer if it is already bound, otherwise
    /// overwrites the data.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void uploadToGPUBuffer(
        @Nullable SDL_GPUCopyPass copy_pass,
        @Nullable @Pointer ISDL_GPUTransferBufferLocation source,
        @Nullable @Pointer ISDL_GPUBufferRegion destination,
        @NativeType("boolean") boolean cycle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UploadToGPUBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (source != null ? source.segment() : MemorySegment.NULL),
                (MemorySegment) (destination != null ? destination.segment() : MemorySegment.NULL),
                cycle
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Performs a texture-to-texture copy.
    ///
    /// This copy occurs on the GPU timeline. You may assume the copy has finished
    /// in subsequent commands.
    ///
    /// @param copy_pass a copy pass handle.
    /// @param source a source texture region.
    /// @param destination a destination texture region.
    /// @param w the width of the region to copy.
    /// @param h the height of the region to copy.
    /// @param d the depth of the region to copy.
    /// @param cycle if true, cycles the destination texture if the destination
    /// texture is bound, otherwise overwrites the data.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void copyGPUTextureToTexture(
        @Nullable SDL_GPUCopyPass copy_pass,
        @Nullable @Pointer ISDL_GPUTextureLocation source,
        @Nullable @Pointer ISDL_GPUTextureLocation destination,
        @NativeType("Uint32") @Unsigned int w,
        @NativeType("Uint32") @Unsigned int h,
        @NativeType("Uint32") @Unsigned int d,
        @NativeType("boolean") boolean cycle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CopyGPUTextureToTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (source != null ? source.segment() : MemorySegment.NULL),
                (MemorySegment) (destination != null ? destination.segment() : MemorySegment.NULL),
                w,
                h,
                d,
                cycle
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Performs a buffer-to-buffer copy.
    ///
    /// This copy occurs on the GPU timeline. You may assume the copy has finished
    /// in subsequent commands.
    ///
    /// @param copy_pass a copy pass handle.
    /// @param source the buffer and offset to copy from.
    /// @param destination the buffer and offset to copy to.
    /// @param size the length of the buffer to copy.
    /// @param cycle if true, cycles the destination buffer if it is already bound,
    /// otherwise overwrites the data.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void copyGPUBufferToBuffer(
        @Nullable SDL_GPUCopyPass copy_pass,
        @Nullable @Pointer ISDL_GPUBufferLocation source,
        @Nullable @Pointer ISDL_GPUBufferLocation destination,
        @NativeType("Uint32") @Unsigned int size,
        @NativeType("boolean") boolean cycle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CopyGPUBufferToBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (source != null ? source.segment() : MemorySegment.NULL),
                (MemorySegment) (destination != null ? destination.segment() : MemorySegment.NULL),
                size,
                cycle
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copies data from a texture to a transfer buffer on the GPU timeline.
    ///
    /// This data is not guaranteed to be copied until the command buffer fence is
    /// signaled.
    ///
    /// @param copy_pass a copy pass handle.
    /// @param source the source texture region.
    /// @param destination the destination transfer buffer with image layout
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void downloadFromGPUTexture(
        @Nullable SDL_GPUCopyPass copy_pass,
        @Nullable @Pointer ISDL_GPUTextureRegion source,
        @Nullable @Pointer ISDL_GPUTextureTransferInfo destination
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DownloadFromGPUTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (source != null ? source.segment() : MemorySegment.NULL),
                (MemorySegment) (destination != null ? destination.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copies data from a buffer to a transfer buffer on the GPU timeline.
    ///
    /// This data is not guaranteed to be copied until the command buffer fence is
    /// signaled.
    ///
    /// @param copy_pass a copy pass handle.
    /// @param source the source buffer with offset and size.
    /// @param destination the destination transfer buffer with offset.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void downloadFromGPUBuffer(
        @Nullable SDL_GPUCopyPass copy_pass,
        @Nullable @Pointer ISDL_GPUBufferRegion source,
        @Nullable @Pointer ISDL_GPUTransferBufferLocation destination
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DownloadFromGPUBuffer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL),
                (MemorySegment) (source != null ? source.segment() : MemorySegment.NULL),
                (MemorySegment) (destination != null ? destination.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Ends the current copy pass.
    ///
    /// @param copy_pass a copy pass handle.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void endGPUCopyPass(
        @Nullable SDL_GPUCopyPass copy_pass
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EndGPUCopyPass);
        try {
            hFunction.invokeExact(
                (MemorySegment) (copy_pass != null ? copy_pass.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generates mipmaps for the given texture.
    ///
    /// This function must not be called inside of any pass.
    ///
    /// @param command_buffer a command_buffer.
    /// @param texture a texture with more than 1 mip level.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void generateMipmapsForGPUTexture(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable SDL_GPUTexture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GenerateMipmapsForGPUTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Blits from a source texture region to a destination texture region.
    ///
    /// This function must not be called inside of any pass.
    ///
    /// @param command_buffer a command buffer.
    /// @param info the blit info struct containing the blit parameters.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void blitGPUTexture(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable @Pointer ISDL_GPUBlitInfo info
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitGPUTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (info != null ? info.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determines whether a swapchain composition is supported by the window.
    ///
    /// The window must be claimed before calling this function.
    ///
    /// @param device a GPU context.
    /// @param window an SDL_Window.
    /// @param swapchain_composition the swapchain composition to check.
    /// @return true if supported, false if unsupported.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #claimWindowForGPUDevice
    public @NativeType("boolean") boolean windowSupportsGPUSwapchainComposition(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window,
        @EnumType(SDL_GPUSwapchainComposition.class) int swapchain_composition
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WindowSupportsGPUSwapchainComposition);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                swapchain_composition
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determines whether a presentation mode is supported by the window.
    ///
    /// The window must be claimed before calling this function.
    ///
    /// @param device a GPU context.
    /// @param window an SDL_Window.
    /// @param present_mode the presentation mode to check.
    /// @return true if supported, false if unsupported.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #claimWindowForGPUDevice
    public @NativeType("boolean") boolean windowSupportsGPUPresentMode(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window,
        @EnumType(SDL_GPUPresentMode.class) int present_mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WindowSupportsGPUPresentMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                present_mode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Claims a window, creating a swapchain structure for it.
    ///
    /// This must be called before SDL_AcquireGPUSwapchainTexture is called using
    /// the window. You should only call this function from the thread that created
    /// the window.
    ///
    /// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and
    /// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain
    /// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the
    /// window.
    ///
    /// @param device a GPU context.
    /// @param window an SDL_Window.
    /// @return true on success, or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called from the thread that
    /// created the window.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #waitAndAcquireGPUSwapchainTexture
    /// @see #releaseWindowFromGPUDevice
    /// @see #windowSupportsGPUPresentMode
    /// @see #windowSupportsGPUSwapchainComposition
    public @NativeType("boolean") boolean claimWindowForGPUDevice(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClaimWindowForGPUDevice);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unclaims a window, destroying its swapchain structure.
    ///
    /// @param device a GPU context.
    /// @param window an SDL_Window that has been claimed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #claimWindowForGPUDevice
    public void releaseWindowFromGPUDevice(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseWindowFromGPUDevice);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Changes the swapchain parameters for the given claimed window.
    ///
    /// This function will fail if the requested present mode or swapchain
    /// composition are unsupported by the device. Check if the parameters are
    /// supported via SDL_WindowSupportsGPUPresentMode /
    /// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.
    ///
    /// SDL_GPU_PRESENTMODE_VSYNC with SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always
    /// supported.
    ///
    /// @param device a GPU context.
    /// @param window an SDL_Window that has been claimed.
    /// @param swapchain_composition the desired composition of the swapchain.
    /// @param present_mode the desired present mode for the swapchain.
    /// @return true if successful, false on error; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #windowSupportsGPUPresentMode
    /// @see #windowSupportsGPUSwapchainComposition
    public @NativeType("boolean") boolean setGPUSwapchainParameters(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window,
        @EnumType(SDL_GPUSwapchainComposition.class) int swapchain_composition,
        @EnumType(SDL_GPUPresentMode.class) int present_mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUSwapchainParameters);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                swapchain_composition,
                present_mode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Configures the maximum allowed number of frames in flight.
    ///
    /// The default value when the device is created is 2. This means that after
    /// you have submitted 2 frames for presentation, if the GPU has not finished
    /// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the
    /// swapchain texture pointer with NULL, and
    /// SDL_WaitAndAcquireGPUSwapchainTexture() will block.
    ///
    /// Higher values increase throughput at the expense of visual latency. Lower
    /// values decrease visual latency at the expense of throughput.
    ///
    /// Note that calling this function will stall and flush the command queue to
    /// prevent synchronization issues.
    ///
    /// The minimum value of allowed frames in flight is 1, and the maximum is 3.
    ///
    /// @param device a GPU context.
    /// @param allowed_frames_in_flight the maximum number of frames that can be
    /// pending on the GPU.
    /// @return true if successful, false on error; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setGPUAllowedFramesInFlight(
        @Nullable SDL_GPUDevice device,
        @NativeType("Uint32") @Unsigned int allowed_frames_in_flight
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetGPUAllowedFramesInFlight);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                allowed_frames_in_flight
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Obtains the texture format of the swapchain for the given window.
    ///
    /// Note that this format can change if the swapchain parameters change.
    ///
    /// @param device a GPU context.
    /// @param window an SDL_Window that has been claimed.
    /// @return the texture format of the swapchain.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_GPUTextureFormat.class) int getGPUSwapchainTextureFormat(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGPUSwapchainTextureFormat);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Acquire a texture to use in presentation.
    ///
    /// When a swapchain texture is acquired on a command buffer, it will
    /// automatically be submitted for presentation when the command buffer is
    /// submitted. The swapchain texture should only be referenced by the command
    /// buffer used to acquire it.
    ///
    /// This function will fill the swapchain texture handle with NULL if too many
    /// frames are in flight. This is not an error.
    ///
    /// If you use this function, it is possible to create a situation where many
    /// command buffers are allocated while the rendering context waits for the GPU
    /// to catch up, which will cause memory usage to grow. You should use
    /// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing
    /// with timing.
    ///
    /// The swapchain texture is managed by the implementation and must not be
    /// freed by the user. You MUST NOT call this function from any thread other
    /// than the one that created the window.
    ///
    /// @param command_buffer a command buffer.
    /// @param window a window that has been claimed.
    /// @param swapchain_texture a pointer filled in with a swapchain texture
    /// handle.
    /// @param swapchain_texture_width a pointer filled in with the swapchain
    /// texture width, may be NULL.
    /// @param swapchain_texture_height a pointer filled in with the swapchain
    /// texture height, may be NULL.
    /// @return true on success, false on error; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called from the thread that
    /// created the window.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #claimWindowForGPUDevice
    /// @see #submitGPUCommandBuffer
    /// @see #submitGPUCommandBufferAndAcquireFence
    /// @see #cancelGPUCommandBuffer
    /// @see #getWindowSizeInPixels
    /// @see #waitForGPUSwapchain
    /// @see #waitAndAcquireGPUSwapchainTexture
    /// @see #setGPUAllowedFramesInFlight
    public @NativeType("boolean") boolean acquireGPUSwapchainTexture(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable SDL_Window window,
        @Nullable @Pointer SDL_GPUTexture.Ptr swapchain_texture,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr swapchain_texture_width,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr swapchain_texture_height
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AcquireGPUSwapchainTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (swapchain_texture != null ? swapchain_texture.segment() : MemorySegment.NULL),
                (MemorySegment) (swapchain_texture_width != null ? swapchain_texture_width.segment() : MemorySegment.NULL),
                (MemorySegment) (swapchain_texture_height != null ? swapchain_texture_height.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Blocks the thread until a swapchain texture is available to be acquired.
    ///
    /// @param device a GPU context.
    /// @param window a window that has been claimed.
    /// @return true on success, false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called from the thread that
    /// created the window.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #acquireGPUSwapchainTexture
    /// @see #waitAndAcquireGPUSwapchainTexture
    /// @see #setGPUAllowedFramesInFlight
    public @NativeType("boolean") boolean waitForGPUSwapchain(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitForGPUSwapchain);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Blocks the thread until a swapchain texture is available to be acquired,
    /// and then acquires it.
    ///
    /// When a swapchain texture is acquired on a command buffer, it will
    /// automatically be submitted for presentation when the command buffer is
    /// submitted. The swapchain texture should only be referenced by the command
    /// buffer used to acquire it. It is an error to call
    /// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.
    ///
    /// This function can fill the swapchain texture handle with NULL in certain
    /// cases, for example if the window is minimized. This is not an error. You
    /// should always make sure to check whether the pointer is NULL before
    /// actually using it.
    ///
    /// The swapchain texture is managed by the implementation and must not be
    /// freed by the user. You MUST NOT call this function from any thread other
    /// than the one that created the window.
    ///
    /// The swapchain texture is write-only and cannot be used as a sampler or for
    /// another reading operation.
    ///
    /// @param command_buffer a command buffer.
    /// @param window a window that has been claimed.
    /// @param swapchain_texture a pointer filled in with a swapchain texture
    /// handle.
    /// @param swapchain_texture_width a pointer filled in with the swapchain
    /// texture width, may be NULL.
    /// @param swapchain_texture_height a pointer filled in with the swapchain
    /// texture height, may be NULL.
    /// @return true on success, false on error; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called from the thread that
    /// created the window.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #submitGPUCommandBuffer
    /// @see #submitGPUCommandBufferAndAcquireFence
    /// @see #acquireGPUSwapchainTexture
    public @NativeType("boolean") boolean waitAndAcquireGPUSwapchainTexture(
        @Nullable SDL_GPUCommandBuffer command_buffer,
        @Nullable SDL_Window window,
        @Nullable @Pointer SDL_GPUTexture.Ptr swapchain_texture,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr swapchain_texture_width,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr swapchain_texture_height
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitAndAcquireGPUSwapchainTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (swapchain_texture != null ? swapchain_texture.segment() : MemorySegment.NULL),
                (MemorySegment) (swapchain_texture_width != null ? swapchain_texture_width.segment() : MemorySegment.NULL),
                (MemorySegment) (swapchain_texture_height != null ? swapchain_texture_height.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Submits a command buffer so its commands can be processed on the GPU.
    ///
    /// It is invalid to use the command buffer after this is called.
    ///
    /// This must be called from the thread the command buffer was acquired on.
    ///
    /// All commands in the submission are guaranteed to begin executing before any
    /// command in a subsequent submission begins executing.
    ///
    /// @param command_buffer a command buffer.
    /// @return true on success, false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #acquireGPUCommandBuffer
    /// @see #waitAndAcquireGPUSwapchainTexture
    /// @see #acquireGPUSwapchainTexture
    /// @see #submitGPUCommandBufferAndAcquireFence
    public @NativeType("boolean") boolean submitGPUCommandBuffer(
        @Nullable SDL_GPUCommandBuffer command_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SubmitGPUCommandBuffer);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Submits a command buffer so its commands can be processed on the GPU, and
    /// acquires a fence associated with the command buffer.
    ///
    /// You must release this fence when it is no longer needed or it will cause a
    /// leak. It is invalid to use the command buffer after this is called.
    ///
    /// This must be called from the thread the command buffer was acquired on.
    ///
    /// All commands in the submission are guaranteed to begin executing before any
    /// command in a subsequent submission begins executing.
    ///
    /// @param command_buffer a command buffer.
    /// @return a fence associated with the command buffer, or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #acquireGPUCommandBuffer
    /// @see #waitAndAcquireGPUSwapchainTexture
    /// @see #acquireGPUSwapchainTexture
    /// @see #submitGPUCommandBuffer
    /// @see #releaseGPUFence
    public SDL_GPUFence submitGPUCommandBufferAndAcquireFence(
        @Nullable SDL_GPUCommandBuffer command_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SubmitGPUCommandBufferAndAcquireFence);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GPUFence(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Cancels a command buffer.
    ///
    /// None of the enqueued commands are executed.
    ///
    /// It is an error to call this function after a swapchain texture has been
    /// acquired.
    ///
    /// This must be called from the thread the command buffer was acquired on.
    ///
    /// You must not reference the command buffer after calling this function.
    ///
    /// @param command_buffer a command buffer.
    /// @return true on success, false on error; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #waitAndAcquireGPUSwapchainTexture
    /// @see #acquireGPUCommandBuffer
    /// @see #acquireGPUSwapchainTexture
    public @NativeType("boolean") boolean cancelGPUCommandBuffer(
        @Nullable SDL_GPUCommandBuffer command_buffer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CancelGPUCommandBuffer);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (command_buffer != null ? command_buffer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Blocks the thread until the GPU is completely idle.
    ///
    /// @param device a GPU context.
    /// @return true on success, false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #waitForGPUFences
    public @NativeType("boolean") boolean waitForGPUIdle(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitForGPUIdle);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Blocks the thread until the given fences are signaled.
    ///
    /// @param device a GPU context.
    /// @param wait_all if 0, wait for any fence to be signaled, if 1, wait for all
    /// fences to be signaled.
    /// @param fences an array of fences to wait on.
    /// @param num_fences the number of fences in the fences array.
    /// @return true on success, false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #submitGPUCommandBufferAndAcquireFence
    /// @see #waitForGPUIdle
    public @NativeType("boolean") boolean waitForGPUFences(
        @Nullable SDL_GPUDevice device,
        @NativeType("boolean") boolean wait_all,
        @Nullable @Pointer SDL_GPUFence.Ptr fences,
        @NativeType("Uint32") @Unsigned int num_fences
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitForGPUFences);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                wait_all,
                (MemorySegment) (fences != null ? fences.segment() : MemorySegment.NULL),
                num_fences
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Checks the status of a fence.
    ///
    /// @param device a GPU context.
    /// @param fence a fence.
    /// @return true if the fence is signaled, false if it is not.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #submitGPUCommandBufferAndAcquireFence
    public @NativeType("boolean") boolean queryGPUFence(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUFence fence
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_QueryGPUFence);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (fence != null ? fence.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.
    ///
    /// You must not reference the fence after calling this function.
    ///
    /// @param device a GPU context.
    /// @param fence a fence.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #submitGPUCommandBufferAndAcquireFence
    public void releaseGPUFence(
        @Nullable SDL_GPUDevice device,
        @Nullable SDL_GPUFence fence
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReleaseGPUFence);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                (MemorySegment) (fence != null ? fence.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Obtains the texel block size for a texture format.
    ///
    /// @param format the texture format you want to know the texel size of.
    /// @return the texel block size of the texture format.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #uploadToGPUTexture
    public @NativeType("Uint32") @Unsigned int GPUTextureFormatTexelBlockSize(
        @EnumType(SDL_GPUTextureFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GPUTextureFormatTexelBlockSize);
        try {
            return (int) hFunction.invokeExact(
                format
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determines whether a texture format is supported for a given type and
    /// usage.
    ///
    /// @param device a GPU context.
    /// @param format the texture format to check.
    /// @param type the type of texture (2D, 3D, Cube).
    /// @param usage a bitmask of all usage scenarios to check.
    /// @return whether the texture format is supported for this type and usage.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean GPUTextureSupportsFormat(
        @Nullable SDL_GPUDevice device,
        @EnumType(SDL_GPUTextureFormat.class) int format,
        @EnumType(SDL_GPUTextureType.class) int type,
        @EnumType(SDL_GPUTextureUsageFlags.class) int usage
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GPUTextureSupportsFormat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                format,
                type,
                usage
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determines if a sample count for a texture format is supported.
    ///
    /// @param device a GPU context.
    /// @param format the texture format to check.
    /// @param sample_count the sample count to check.
    /// @return whether the sample count is supported for this texture format.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean GPUTextureSupportsSampleCount(
        @Nullable SDL_GPUDevice device,
        @EnumType(SDL_GPUTextureFormat.class) int format,
        @EnumType(SDL_GPUSampleCount.class) int sample_count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GPUTextureSupportsSampleCount);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL),
                format,
                sample_count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the size in bytes of a texture format with dimensions.
    ///
    /// @param format a texture format.
    /// @param width width in pixels.
    /// @param height height in pixels.
    /// @param depth_or_layer_count depth for 3D textures or layer count otherwise.
    /// @return the size of a texture with this format and dimensions.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint32") @Unsigned int calculateGPUTextureFormatSize(
        @EnumType(SDL_GPUTextureFormat.class) int format,
        @NativeType("Uint32") @Unsigned int width,
        @NativeType("Uint32") @Unsigned int height,
        @NativeType("Uint32") @Unsigned int depth_or_layer_count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CalculateGPUTextureFormatSize);
        try {
            return (int) hFunction.invokeExact(
                format,
                width,
                height,
                depth_or_layer_count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Call this to suspend GPU operation on Xbox when you receive the
    /// SDL_EVENT_DID_ENTER_BACKGROUND event.
    ///
    /// Do NOT call any SDL_GPU functions after calling this function! This must
    /// also be called before calling SDL_GDKSuspendComplete.
    ///
    /// @param device a GPU context.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addEventWatch
    public void GDKSuspendGPU(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GDKSuspendGPU);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Call this to resume GPU operation on Xbox when you receive the
    /// SDL_EVENT_WILL_ENTER_FOREGROUND event.
    ///
    /// When resuming, this function MUST be called before calling any other
    /// SDL_GPU functions.
    ///
    /// @param device a GPU context.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addEventWatch
    public void GDKResumeGPU(
        @Nullable SDL_GPUDevice device
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GDKResumeGPU);
        try {
            hFunction.invokeExact(
                (MemorySegment) (device != null ? device.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get an ASCII string representation for a given SDL_GUID.
    ///
    /// @param guid the SDL_GUID you wish to convert to string.
    /// @param pszGUID buffer in which to write the ASCII string.
    /// @param cbGUID the size of pszGUID, should be at least 33 bytes.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #stringToGUID
    public void GUIDToString(
        SDL_GUID guid,
        @Nullable BytePtr pszGUID,
        int cbGUID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GUIDToString);
        try {
            hFunction.invokeExact(
                guid.segment(),
                (MemorySegment) (pszGUID != null ? pszGUID.segment() : MemorySegment.NULL),
                cbGUID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a GUID string into a SDL_GUID structure.
    ///
    /// Performs no error checking. If this function is given a string containing
    /// an invalid GUID, the function will silently succeed, but the GUID generated
    /// will not be useful.
    ///
    /// @param pchGUID string containing an ASCII representation of a GUID.
    /// @return a SDL_GUID structure.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GUIDToString
    public SDL_GUID stringToGUID(
        @Nullable BytePtr pchGUID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StringToGUID);
        try {
            return new SDL_GUID((MemorySegment) hFunction.invokeExact(
                (MemorySegment) (pchGUID != null ? pchGUID.segment() : MemorySegment.NULL)
            ));
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected haptic devices.
    ///
    /// @param count a pointer filled in with the number of haptic devices
    /// returned, may be NULL.
    /// @return a 0 terminated array of haptic device instance IDs or NULL on
    /// failure; call SDL_GetError() for more information. This should be
    /// freed with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openHaptic
    public @Pointer(comment="SDL_HapticID") @Unsigned IntPtr getHaptics(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHaptics);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a haptic device.
    ///
    /// This can be called before any haptic devices are opened.
    ///
    /// @param instance_id the haptic device instance ID.
    /// @return the name of the selected haptic device. If no name can be found,
    /// this function returns NULL; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHapticName
    /// @see #openHaptic
    public BytePtr getHapticNameForID(
        @NativeType("SDL_HapticID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHapticNameForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a haptic device for use.
    ///
    /// The index passed as an argument refers to the N'th haptic device on this
    /// system.
    ///
    /// When opening a haptic device, its gain will be set to maximum and
    /// autocenter will be disabled. To modify these values use SDL_SetHapticGain()
    /// and SDL_SetHapticAutocenter().
    ///
    /// @param instance_id the haptic device instance ID.
    /// @return the device identifier or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeHaptic
    /// @see #getHaptics
    /// @see #openHapticFromJoystick
    /// @see #openHapticFromMouse
    /// @see #setHapticAutocenter
    /// @see #setHapticGain
    public SDL_Haptic openHaptic(
        @NativeType("SDL_HapticID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenHaptic);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Haptic(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_Haptic associated with an instance ID, if it has been opened.
    ///
    /// @param instance_id the instance ID to get the SDL_Haptic for.
    /// @return an SDL_Haptic on success or NULL on failure or if it hasn't been
    /// opened yet; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Haptic getHapticFromID(
        @NativeType("SDL_HapticID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHapticFromID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Haptic(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the instance ID of an opened haptic device.
    ///
    /// @param haptic the SDL_Haptic device to query.
    /// @return the instance ID of the specified haptic device on success or 0 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_HapticID") @Unsigned int getHapticID(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHapticID);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a haptic device.
    ///
    /// @param haptic the SDL_Haptic obtained from SDL_OpenJoystick().
    /// @return the name of the selected haptic device. If no name can be found,
    /// this function returns NULL; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHapticNameForID
    public BytePtr getHapticName(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHapticName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether or not the current mouse has haptic capabilities.
    ///
    /// @return true if the mouse is haptic or false if it isn't.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openHapticFromMouse
    public @NativeType("boolean") boolean isMouseHaptic() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsMouseHaptic);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Try to open a haptic device from the current mouse.
    ///
    /// @return the haptic device identifier or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeHaptic
    /// @see #isMouseHaptic
    public SDL_Haptic openHapticFromMouse() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenHapticFromMouse);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Haptic(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if a joystick has haptic features.
    ///
    /// @param joystick the SDL_Joystick to test for haptic capabilities.
    /// @return true if the joystick is haptic or false if it isn't.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openHapticFromJoystick
    public @NativeType("boolean") boolean isJoystickHaptic(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsJoystickHaptic);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a haptic device for use from a joystick device.
    ///
    /// You must still close the haptic device separately. It will not be closed
    /// with the joystick.
    ///
    /// When opened from a joystick you should first close the haptic device before
    /// closing the joystick device. If not, on some implementations the haptic
    /// device will also get unallocated and you'll be unable to use force feedback
    /// on that device.
    ///
    /// @param joystick the SDL_Joystick to create a haptic device from.
    /// @return a valid haptic device identifier on success or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeHaptic
    /// @see #isJoystickHaptic
    public SDL_Haptic openHapticFromJoystick(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenHapticFromJoystick);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Haptic(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close a haptic device previously opened with SDL_OpenHaptic().
    ///
    /// @param haptic the SDL_Haptic device to close.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openHaptic
    public void closeHaptic(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseHaptic);
        try {
            hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of effects a haptic device can store.
    ///
    /// On some platforms this isn't fully supported, and therefore is an
    /// approximation. Always check to see if your created effect was actually
    /// created and do not rely solely on SDL_GetMaxHapticEffects().
    ///
    /// @param haptic the SDL_Haptic device to query.
    /// @return the number of effects the haptic device can store or a negative
    /// error code on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMaxHapticEffectsPlaying
    /// @see #getHapticFeatures
    public int getMaxHapticEffects(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMaxHapticEffects);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of effects a haptic device can play at the same time.
    ///
    /// This is not supported on all platforms, but will always return a value.
    ///
    /// @param haptic the SDL_Haptic device to query maximum playing effects.
    /// @return the number of effects the haptic device can play at the same time
    /// or -1 on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMaxHapticEffects
    /// @see #getHapticFeatures
    public int getMaxHapticEffectsPlaying(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMaxHapticEffectsPlaying);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the haptic device's supported features in bitwise manner.
    ///
    /// @param haptic the SDL_Haptic device to query.
    /// @return a list of supported haptic features in bitwise manner (OR'd), or 0
    /// on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hapticEffectSupported
    /// @see #getMaxHapticEffects
    public @NativeType("Uint32") @Unsigned int getHapticFeatures(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHapticFeatures);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of haptic axes the device has.
    ///
    /// The number of haptic axes might be useful if working with the
    /// SDL_HapticDirection effect.
    ///
    /// @param haptic the SDL_Haptic device to query.
    /// @return the number of axes on success or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getNumHapticAxes(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumHapticAxes);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check to see if an effect is supported by a haptic device.
    ///
    /// @param haptic the SDL_Haptic device to query.
    /// @param effect the desired effect to query.
    /// @return true if the effect is supported or false if it isn't.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createHapticEffect
    /// @see #getHapticFeatures
    public @NativeType("boolean") boolean hapticEffectSupported(
        @Nullable SDL_Haptic haptic,
        @Nullable @Pointer ISDL_HapticEffect effect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HapticEffectSupported);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                (MemorySegment) (effect != null ? effect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new haptic effect on a specified device.
    ///
    /// @param haptic an SDL_Haptic device to create the effect on.
    /// @param effect an SDL_HapticEffect structure containing the properties of
    /// the effect to create.
    /// @return the ID of the effect on success or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyHapticEffect
    /// @see #runHapticEffect
    /// @see #updateHapticEffect
    public int createHapticEffect(
        @Nullable SDL_Haptic haptic,
        @Nullable @Pointer ISDL_HapticEffect effect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateHapticEffect);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                (MemorySegment) (effect != null ? effect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update the properties of an effect.
    ///
    /// Can be used dynamically, although behavior when dynamically changing
    /// direction may be strange. Specifically the effect may re-upload itself and
    /// start playing from the start. You also cannot change the type either when
    /// running SDL_UpdateHapticEffect().
    ///
    /// @param haptic the SDL_Haptic device that has the effect.
    /// @param effect the identifier of the effect to update.
    /// @param data an SDL_HapticEffect structure containing the new effect
    /// properties to use.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createHapticEffect
    /// @see #runHapticEffect
    public @NativeType("boolean") boolean updateHapticEffect(
        @Nullable SDL_Haptic haptic,
        int effect,
        @Nullable @Pointer ISDL_HapticEffect data
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateHapticEffect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                effect,
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Run the haptic effect on its associated haptic device.
    ///
    /// To repeat the effect over and over indefinitely, set `iterations` to
    /// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
    /// one instance of the effect last indefinitely (so the effect does not fade),
    /// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
    /// instead.
    ///
    /// @param haptic the SDL_Haptic device to run the effect on.
    /// @param effect the ID of the haptic effect to run.
    /// @param iterations the number of iterations to run the effect; use
    /// `SDL_HAPTIC_INFINITY` to repeat forever.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHapticEffectStatus
    /// @see #stopHapticEffect
    /// @see #stopHapticEffects
    public @NativeType("boolean") boolean runHapticEffect(
        @Nullable SDL_Haptic haptic,
        int effect,
        @NativeType("Uint32") @Unsigned int iterations
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RunHapticEffect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                effect,
                iterations
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Stop the haptic effect on its associated haptic device.
    ///
    /// @param haptic the SDL_Haptic device to stop the effect on.
    /// @param effect the ID of the haptic effect to stop.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #runHapticEffect
    /// @see #stopHapticEffects
    public @NativeType("boolean") boolean stopHapticEffect(
        @Nullable SDL_Haptic haptic,
        int effect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StopHapticEffect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                effect
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a haptic effect on the device.
    ///
    /// This will stop the effect if it's running. Effects are automatically
    /// destroyed when the device is closed.
    ///
    /// @param haptic the SDL_Haptic device to destroy the effect on.
    /// @param effect the ID of the haptic effect to destroy.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createHapticEffect
    public void destroyHapticEffect(
        @Nullable SDL_Haptic haptic,
        int effect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyHapticEffect);
        try {
            hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                effect
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the status of the current effect on the specified haptic device.
    ///
    /// Device must support the SDL_HAPTIC_STATUS feature.
    ///
    /// @param haptic the SDL_Haptic device to query for the effect status on.
    /// @param effect the ID of the haptic effect to query its status.
    /// @return true if it is playing, false if it isn't playing or haptic status
    /// isn't supported.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHapticFeatures
    public @NativeType("boolean") boolean getHapticEffectStatus(
        @Nullable SDL_Haptic haptic,
        int effect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHapticEffectStatus);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                effect
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the global gain of the specified haptic device.
    ///
    /// Device must support the SDL_HAPTIC_GAIN feature.
    ///
    /// The user may specify the maximum gain by setting the environment variable
    /// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
    /// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
    /// maximum.
    ///
    /// @param haptic the SDL_Haptic device to set the gain on.
    /// @param gain value to set the gain to, should be between 0 and 100 (0 -
    /// 100).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHapticFeatures
    public @NativeType("boolean") boolean setHapticGain(
        @Nullable SDL_Haptic haptic,
        int gain
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetHapticGain);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                gain
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the global autocenter of the device.
    ///
    /// Autocenter should be between 0 and 100. Setting it to 0 will disable
    /// autocentering.
    ///
    /// Device must support the SDL_HAPTIC_AUTOCENTER feature.
    ///
    /// @param haptic the SDL_Haptic device to set autocentering on.
    /// @param autocenter value to set autocenter to (0-100).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHapticFeatures
    public @NativeType("boolean") boolean setHapticAutocenter(
        @Nullable SDL_Haptic haptic,
        int autocenter
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetHapticAutocenter);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                autocenter
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Pause a haptic device.
    ///
    /// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()
    /// to resume playback.
    ///
    /// Do not modify the effects nor add new ones while the device is paused. That
    /// can cause all sorts of weird errors.
    ///
    /// @param haptic the SDL_Haptic device to pause.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #resumeHaptic
    public @NativeType("boolean") boolean pauseHaptic(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PauseHaptic);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Resume a haptic device.
    ///
    /// Call to unpause after SDL_PauseHaptic().
    ///
    /// @param haptic the SDL_Haptic device to unpause.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pauseHaptic
    public @NativeType("boolean") boolean resumeHaptic(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResumeHaptic);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Stop all the currently playing effects on a haptic device.
    ///
    /// @param haptic the SDL_Haptic device to stop.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #runHapticEffect
    /// @see #stopHapticEffects
    public @NativeType("boolean") boolean stopHapticEffects(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StopHapticEffects);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check whether rumble is supported on a haptic device.
    ///
    /// @param haptic haptic device to check for rumble support.
    /// @return true if the effect is supported or false if it isn't.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #initHapticRumble
    public @NativeType("boolean") boolean hapticRumbleSupported(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HapticRumbleSupported);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Initialize a haptic device for simple rumble playback.
    ///
    /// @param haptic the haptic device to initialize for simple rumble playback.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #playHapticRumble
    /// @see #stopHapticRumble
    /// @see #hapticRumbleSupported
    public @NativeType("boolean") boolean initHapticRumble(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_InitHapticRumble);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Run a simple rumble effect on a haptic device.
    ///
    /// @param haptic the haptic device to play the rumble effect on.
    /// @param strength strength of the rumble to play as a 0-1 float value.
    /// @param length length of the rumble to play in milliseconds.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #initHapticRumble
    /// @see #stopHapticRumble
    public @NativeType("boolean") boolean playHapticRumble(
        @Nullable SDL_Haptic haptic,
        float strength,
        @NativeType("Uint32") @Unsigned int length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PlayHapticRumble);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL),
                strength,
                length
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Stop the simple rumble on a haptic device.
    ///
    /// @param haptic the haptic device to stop the rumble effect on.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #playHapticRumble
    public @NativeType("boolean") boolean stopHapticRumble(
        @Nullable SDL_Haptic haptic
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StopHapticRumble);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (haptic != null ? haptic.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Initialize the HIDAPI library.
    ///
    /// This function initializes the HIDAPI library. Calling it is not strictly
    /// necessary, as it will be called automatically by SDL_hid_enumerate() and
    /// any of the SDL_hid_open_*() functions if it is needed. This function should
    /// be called at the beginning of execution however, if there is a chance of
    /// HIDAPI handles being opened by different threads simultaneously.
    ///
    /// Each call to this function should have a matching call to SDL_hid_exit()
    ///
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hid_exit
    public int hid_init() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_init);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Finalize the HIDAPI library.
    ///
    /// This function frees all of the static data associated with HIDAPI. It
    /// should be called at the end of execution to avoid memory leaks.
    ///
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hid_init
    public int hid_exit() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_exit);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check to see if devices may have been added or removed.
    ///
    /// Enumerating the HID devices is an expensive operation, so you can call this
    /// to see if there have been any system device changes since the last call to
    /// this function. A change in the counter returned doesn't necessarily mean
    /// that anything has changed, but you can call SDL_hid_enumerate() to get an
    /// updated device list.
    ///
    /// Calling this function for the first time may cause a thread or other system
    /// resource to be allocated to track device change notifications.
    ///
    /// @return a change counter that is incremented with each potential device
    /// change, or 0 if device change detection isn't available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hid_enumerate
    public @NativeType("Uint32") @Unsigned int hid_device_change_count() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_device_change_count);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Enumerate the HID Devices.
    ///
    /// This function returns a linked list of all the HID devices attached to the
    /// system which match vendor_id and product_id. If `vendor_id` is set to 0
    /// then any vendor matches. If `product_id` is set to 0 then any product
    /// matches. If `vendor_id` and `product_id` are both set to 0, then all HID
    /// devices will be returned.
    ///
    /// By default SDL will only enumerate controllers, to reduce risk of hanging
    /// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS
    /// can be set to "0" to enumerate all HID devices.
    ///
    /// @param vendor_id the Vendor ID (VID) of the types of device to open, or 0
    /// to match any vendor.
    /// @param product_id the Product ID (PID) of the types of device to open, or 0
    /// to match any product.
    /// @return a pointer to a linked list of type SDL_hid_device_info, containing
    /// information about the HID devices attached to the system, or NULL
    /// in the case of failure. Free this linked list by calling
    /// SDL_hid_free_enumeration().
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hid_device_change_count
    public @Pointer ISDL_hid_device_info hid_enumerate(
        short vendor_id,
        short product_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_enumerate);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                vendor_id,
                product_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_hid_device_info(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free an enumeration linked list.
    ///
    /// This function frees a linked list created by SDL_hid_enumerate().
    ///
    /// @param devs pointer to a list of struct_device returned from
    /// SDL_hid_enumerate().
    ///
    /// @since This function is available since SDL 3.2.0.
    public void hid_free_enumeration(
        @Nullable @Pointer ISDL_hid_device_info devs
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_free_enumeration);
        try {
            hFunction.invokeExact(
                (MemorySegment) (devs != null ? devs.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally
    /// a serial number.
    ///
    /// If `serial_number` is NULL, the first device with the specified VID and PID
    /// is opened.
    ///
    /// @param vendor_id the Vendor ID (VID) of the device to open.
    /// @param product_id the Product ID (PID) of the device to open.
    /// @param serial_number the Serial Number of the device to open (Optionally
    /// NULL).
    /// @return a pointer to a SDL_hid_device object on success or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_hid_device hid_open(
        short vendor_id,
        short product_id,
        @Pointer(comment="wchar_t*") MemorySegment serial_number
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_open);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                vendor_id,
                product_id,
                serial_number
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_hid_device(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a HID device by its path name.
    ///
    /// The path name be determined by calling SDL_hid_enumerate(), or a
    /// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).
    ///
    /// @param path the path name of the device to open.
    /// @return a pointer to a SDL_hid_device object on success or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_hid_device hid_open_path(
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_open_path);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_hid_device(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Write an Output report to a HID device.
    ///
    /// The first byte of `data` must contain the Report ID. For devices which only
    /// support a single report, this must be set to 0x0. The remaining bytes
    /// contain the report data. Since the Report ID is mandatory, calls to
    /// SDL_hid_write() will always contain one more byte than the report contains.
    /// For example, if a hid report is 16 bytes long, 17 bytes must be passed to
    /// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),
    /// followed by the report data (16 bytes). In this example, the length passed
    /// in would be 17.
    ///
    /// SDL_hid_write() will send the data on the first OUT endpoint, if one
    /// exists. If it does not, it will send the data through the Control Endpoint
    /// (Endpoint 0).
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param data the data to send, including the report number as the first
    /// byte.
    /// @param length the length in bytes of the data to send.
    /// @return the actual number of bytes written and -1 on on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_write(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr data,
        long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_write);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(length)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Read an Input report from a HID device with timeout.
    ///
    /// Input reports are returned to the host through the INTERRUPT IN endpoint.
    /// The first byte will contain the Report number if the device uses numbered
    /// reports.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param data a buffer to put the read data into.
    /// @param length the number of bytes to read. For devices with multiple
    /// reports, make sure to read an extra byte for the report
    /// number.
    /// @param milliseconds timeout in milliseconds or -1 for blocking wait.
    /// @return the actual number of bytes read and -1 on on failure; call
    /// SDL_GetError() for more information. If no packet was available to
    /// be read within the timeout period, this function returns 0.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_read_timeout(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr data,
        long length,
        int milliseconds
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_read_timeout);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(length),
                milliseconds
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Read an Input report from a HID device.
    ///
    /// Input reports are returned to the host through the INTERRUPT IN endpoint.
    /// The first byte will contain the Report number if the device uses numbered
    /// reports.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param data a buffer to put the read data into.
    /// @param length the number of bytes to read. For devices with multiple
    /// reports, make sure to read an extra byte for the report
    /// number.
    /// @return the actual number of bytes read and -1 on failure; call
    /// SDL_GetError() for more information. If no packet was available to
    /// be read and the handle is in non-blocking mode, this function
    /// returns 0.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_read(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr data,
        long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_read);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(length)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the device handle to be non-blocking.
    ///
    /// In non-blocking mode calls to SDL_hid_read() will return immediately with a
    /// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()
    /// will wait (block) until there is data to read before returning.
    ///
    /// Nonblocking can be turned on and off at any time.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param nonblock enable or not the nonblocking reads - 1 to enable
    /// nonblocking - 0 to disable nonblocking.
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_set_nonblocking(
        @Nullable SDL_hid_device dev,
        int nonblock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_set_nonblocking);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                nonblock
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Send a Feature report to the device.
    ///
    /// Feature reports are sent over the Control endpoint as a Set_Report
    /// transfer. The first byte of `data` must contain the Report ID. For devices
    /// which only support a single report, this must be set to 0x0. The remaining
    /// bytes contain the report data. Since the Report ID is mandatory, calls to
    /// SDL_hid_send_feature_report() will always contain one more byte than the
    /// report contains. For example, if a hid report is 16 bytes long, 17 bytes
    /// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for
    /// devices which do not use numbered reports), followed by the report data (16
    /// bytes). In this example, the length passed in would be 17.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param data the data to send, including the report number as the first
    /// byte.
    /// @param length the length in bytes of the data to send, including the report
    /// number.
    /// @return the actual number of bytes written and -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_send_feature_report(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr data,
        long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_send_feature_report);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(length)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a feature report from a HID device.
    ///
    /// Set the first byte of `data` to the Report ID of the report to be read.
    /// Make sure to allow space for this extra byte in `data`. Upon return, the
    /// first byte will still contain the Report ID, and the report data will start
    /// in data[1].
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param data a buffer to put the read data into, including the Report ID.
    /// Set the first byte of `data` to the Report ID of the report to
    /// be read, or set it to zero if your device does not use numbered
    /// reports.
    /// @param length the number of bytes to read, including an extra byte for the
    /// report ID. The buffer can be longer than the actual report.
    /// @return the number of bytes read plus one for the report ID (which is
    /// still in the first byte), or -1 on on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_feature_report(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr data,
        long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_feature_report);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(length)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get an input report from a HID device.
    ///
    /// Set the first byte of `data` to the Report ID of the report to be read.
    /// Make sure to allow space for this extra byte in `data`. Upon return, the
    /// first byte will still contain the Report ID, and the report data will start
    /// in data[1].
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param data a buffer to put the read data into, including the Report ID.
    /// Set the first byte of `data` to the Report ID of the report to
    /// be read, or set it to zero if your device does not use numbered
    /// reports.
    /// @param length the number of bytes to read, including an extra byte for the
    /// report ID. The buffer can be longer than the actual report.
    /// @return the number of bytes read plus one for the report ID (which is
    /// still in the first byte), or -1 on on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_input_report(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr data,
        long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_input_report);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(length)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close a HID device.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_close(
        @Nullable SDL_hid_device dev
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_close);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get The Manufacturer String from a HID device.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param string a wide string buffer to put the data into.
    /// @param maxlen the length of the buffer in multiples of wchar_t.
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_manufacturer_string(
        @Nullable SDL_hid_device dev,
        @Pointer(comment="wchar_t*") MemorySegment string,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_manufacturer_string);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                string,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get The Product String from a HID device.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param string a wide string buffer to put the data into.
    /// @param maxlen the length of the buffer in multiples of wchar_t.
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_product_string(
        @Nullable SDL_hid_device dev,
        @Pointer(comment="wchar_t*") MemorySegment string,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_product_string);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                string,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get The Serial Number String from a HID device.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param string a wide string buffer to put the data into.
    /// @param maxlen the length of the buffer in multiples of wchar_t.
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_serial_number_string(
        @Nullable SDL_hid_device dev,
        @Pointer(comment="wchar_t*") MemorySegment string,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_serial_number_string);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                string,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a string from a HID device, based on its string index.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param string_index the index of the string to get.
    /// @param string a wide string buffer to put the data into.
    /// @param maxlen the length of the buffer in multiples of wchar_t.
    /// @return 0 on success or a negative error code on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_indexed_string(
        @Nullable SDL_hid_device dev,
        int string_index,
        @Pointer(comment="wchar_t*") MemorySegment string,
        long maxlen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_indexed_string);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                string_index,
                string,
                MemorySegment.ofAddress(maxlen)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the device info from a HID device.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @return a pointer to the SDL_hid_device_info for this hid_device or NULL
    /// on failure; call SDL_GetError() for more information. This struct
    /// is valid until the device is closed with SDL_hid_close().
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer ISDL_hid_device_info hid_get_device_info(
        @Nullable SDL_hid_device dev
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_device_info);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_hid_device_info(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a report descriptor from a HID device.
    ///
    /// User has to provide a preallocated buffer where descriptor will be copied
    /// to. The recommended size for a preallocated buffer is 4096 bytes.
    ///
    /// @param dev a device handle returned from SDL_hid_open().
    /// @param buf the buffer to copy descriptor into.
    /// @param buf_size the size of the buffer in bytes.
    /// @return the number of bytes actually copied or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int hid_get_report_descriptor(
        @Nullable SDL_hid_device dev,
        @Nullable BytePtr buf,
        long buf_size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_get_report_descriptor);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (dev != null ? dev.segment() : MemorySegment.NULL),
                (MemorySegment) (buf != null ? buf.segment() : MemorySegment.NULL),
                MemorySegment.ofAddress(buf_size)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.
    ///
    /// @param active true to start the scan, false to stop the scan.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void hid_ble_scan(
        @NativeType("boolean") boolean active
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_hid_ble_scan);
        try {
            hFunction.invokeExact(
                active
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a hint with a specific priority.
    ///
    /// The priority controls the behavior when setting a hint that already has a
    /// value. Hints will replace existing hints of their priority and lower.
    /// Environment variables are considered to have override priority.
    ///
    /// @param name the hint to set.
    /// @param value the value of the hint variable.
    /// @param priority the SDL_HintPriority level for the hint.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHint
    /// @see #resetHint
    /// @see #setHint
    public @NativeType("boolean") boolean setHintWithPriority(
        @Nullable BytePtr name,
        @Nullable BytePtr value,
        @EnumType(SDL_HintPriority.class) int priority
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetHintWithPriority);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL),
                priority
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a hint with normal priority.
    ///
    /// Hints will not be set if there is an existing override hint or environment
    /// variable that takes precedence. You can use SDL_SetHintWithPriority() to
    /// set the hint with override priority instead.
    ///
    /// @param name the hint to set.
    /// @param value the value of the hint variable.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHint
    /// @see #resetHint
    /// @see #setHintWithPriority
    public @NativeType("boolean") boolean setHint(
        @Nullable BytePtr name,
        @Nullable BytePtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetHint);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Reset a hint to the default value.
    ///
    /// This will reset a hint to the value of the environment variable, or NULL if
    /// the environment isn't set. Callbacks will be called normally with this
    /// change.
    ///
    /// @param name the hint to set.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setHint
    /// @see #resetHints
    public @NativeType("boolean") boolean resetHint(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResetHint);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Reset all hints to the default values.
    ///
    /// This will reset all hints to the value of the associated environment
    /// variable, or NULL if the environment isn't set. Callbacks will be called
    /// normally with this change.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #resetHint
    public void resetHints() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResetHints);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the value of a hint.
    ///
    /// @param name the hint to query.
    /// @return the string value of a hint or NULL if the hint isn't set.
    ///
    /// @threadsafety It is safe to call this function from any thread, however the
    /// return value only remains valid until the hint is changed; if
    /// another thread might do so, the app should supply locks
    /// and/or make a copy of the string. Note that using a hint
    /// callback instead is always thread-safe, as SDL holds a lock
    /// on the thread subsystem during the callback.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setHint
    /// @see #setHintWithPriority
    public BytePtr getHint(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHint);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the boolean value of a hint variable.
    ///
    /// @param name the name of the hint to get the boolean value from.
    /// @param default_value the value to return if the hint does not exist.
    /// @return the boolean value of a hint or the provided default value if the
    /// hint does not exist.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getHint
    /// @see #setHint
    public @NativeType("boolean") boolean getHintBoolean(
        @Nullable BytePtr name,
        @NativeType("boolean") boolean default_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetHintBoolean);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                default_value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add a function to watch a particular hint.
    ///
    /// The callback function is called _during_ this function, to provide it an
    /// initial value, and again each time the hint's value changes.
    ///
    /// @param name the hint to watch.
    /// @param callback An SDL_HintCallback function that will be called when the
    /// hint value changes.
    /// @param userdata a pointer to pass to the callback function.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #removeHintCallback
    public @NativeType("boolean") boolean addHintCallback(
        @Nullable BytePtr name,
        @Pointer(comment="SDL_HintCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddHintCallback);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Remove a function watching a particular hint.
    ///
    /// @param name the hint being watched.
    /// @param callback an SDL_HintCallback function that will be called when the
    /// hint value changes.
    /// @param userdata a pointer being passed to the callback function.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addHintCallback
    public void removeHintCallback(
        @Nullable BytePtr name,
        @Pointer(comment="SDL_HintCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemoveHintCallback);
        try {
            hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Initialize the SDL library.
    ///
    /// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
    /// two may be used interchangeably. Though for readability of your code
    /// SDL_InitSubSystem() might be preferred.
    ///
    /// The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)
    /// subsystems are initialized by default. Message boxes
    /// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
    /// video subsystem, in hopes of being useful in showing an error dialog when
    /// SDL_Init fails. You must specifically initialize other subsystems if you
    /// use them in your application.
    ///
    /// Logging (such as SDL_Log) works without initialization, too.
    ///
    /// `flags` may be any of the following OR'd together:
    ///
    /// - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events
    /// subsystem
    /// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
    /// subsystem, should be initialized on the main thread.
    /// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
    /// events subsystem
    /// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
    /// - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the
    /// joystick subsystem
    /// - `SDL_INIT_EVENTS`: events subsystem
    /// - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events
    /// subsystem
    /// - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events
    /// subsystem
    ///
    /// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
    /// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
    /// call SDL_Quit() to force shutdown). If a subsystem is already loaded then
    /// this call will increase the ref-count and return.
    ///
    /// Consider reporting some basic metadata about your application before
    /// calling SDL_Init, using either SDL_SetAppMetadata() or
    /// SDL_SetAppMetadataProperty().
    ///
    /// @param flags subsystem initialization flags.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAppMetadata
    /// @see #setAppMetadataProperty
    /// @see #initSubSystem
    /// @see #quit
    /// @see `SDL_SetMainReady`
    /// @see #wasInit
    public @NativeType("boolean") boolean init(
        @EnumType(SDL_InitFlags.class) int flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_Init);
        try {
            return (boolean) hFunction.invokeExact(
                flags
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Compatibility function to initialize the SDL library.
    ///
    /// This function and SDL_Init() are interchangeable.
    ///
    /// @param flags any of the flags used by SDL_Init(); see SDL_Init for details.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #init
    /// @see #quit
    /// @see #quitSubSystem
    public @NativeType("boolean") boolean initSubSystem(
        @EnumType(SDL_InitFlags.class) int flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_InitSubSystem);
        try {
            return (boolean) hFunction.invokeExact(
                flags
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Shut down specific SDL subsystems.
    ///
    /// You still need to call SDL_Quit() even if you close all open subsystems
    /// with SDL_QuitSubSystem().
    ///
    /// @param flags any of the flags used by SDL_Init(); see SDL_Init for details.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #initSubSystem
    /// @see #quit
    public void quitSubSystem(
        @EnumType(SDL_InitFlags.class) int flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_QuitSubSystem);
        try {
            hFunction.invokeExact(
                flags
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a mask of the specified subsystems which are currently initialized.
    ///
    /// @param flags any of the flags used by SDL_Init(); see SDL_Init for details.
    /// @return a mask of all initialized subsystems if `flags` is 0, otherwise it
    /// returns the initialization status of the specified subsystems.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #init
    /// @see #initSubSystem
    public @EnumType(SDL_InitFlags.class) int wasInit(
        @EnumType(SDL_InitFlags.class) int flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WasInit);
        try {
            return (int) hFunction.invokeExact(
                flags
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clean up all initialized subsystems.
    ///
    /// You should call this function even if you have already shutdown each
    /// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
    /// function even in the case of errors in initialization.
    ///
    /// You can use this function with atexit() to ensure that it is run when your
    /// application is shutdown, but it is not wise to do this from a library or
    /// other dynamically loaded code.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #init
    /// @see #quitSubSystem
    public void quit() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_Quit);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether this is the main thread.
    ///
    /// On Apple platforms, the main thread is the thread that runs your program's
    /// main() entry point. On other platforms, the main thread is the one that
    /// calls SDL_Init(SDL_INIT_VIDEO), which should usually be the one that runs
    /// your program's main() entry point. If you are using the main callbacks,
    /// SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the
    /// main thread.
    ///
    /// @return true if this thread is the main thread, or false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #runOnMainThread
    public @NativeType("boolean") boolean isMainThread() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsMainThread);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Call a function on the main thread during event processing.
    ///
    /// If this is called on the main thread, the callback is executed immediately.
    /// If this is called on another thread, this callback is queued for execution
    /// on the main thread during event processing.
    ///
    /// Be careful of deadlocks when using this functionality. You should not have
    /// the main thread wait for the current thread while this function is being
    /// called with `wait_complete` true.
    ///
    /// @param callback the callback to call on the main thread.
    /// @param userdata a pointer that is passed to `callback`.
    /// @param wait_complete true to wait for the callback to complete, false to
    /// return immediately.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #isMainThread
    public @NativeType("boolean") boolean runOnMainThread(
        @Pointer(comment="SDL_MainThreadCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata,
        @NativeType("boolean") boolean wait_complete
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RunOnMainThread);
        try {
            return (boolean) hFunction.invokeExact(
                callback,
                userdata,
                wait_complete
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Specify basic metadata about your app.
    ///
    /// You can optionally provide metadata about your app to SDL. This is not
    /// required, but strongly encouraged.
    ///
    /// There are several locations where SDL can make use of metadata (an "About"
    /// box in the macOS menu bar, the name of the app can be shown on some audio
    /// mixers, etc). Any piece of metadata can be left as NULL, if a specific
    /// detail doesn't make sense for the app.
    ///
    /// This function should be called as early as possible, before SDL_Init.
    /// Multiple calls to this function are allowed, but various state might not
    /// change once it has been set up with a previous call to this function.
    ///
    /// Passing a NULL removes any previous metadata.
    ///
    /// This is a simplified interface for the most important information. You can
    /// supply significantly more detailed metadata with
    /// SDL_SetAppMetadataProperty().
    ///
    /// @param appname The name of the application ("My Game 2: Bad Guy's
    /// Revenge!").
    /// @param appversion The version of the application ("1.0.0beta5" or a git
    /// hash, or whatever makes sense).
    /// @param appidentifier A unique string in reverse-domain format that
    /// identifies this app ("com.example.mygame2").
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAppMetadataProperty
    public @NativeType("boolean") boolean setAppMetadata(
        @Nullable BytePtr appname,
        @Nullable BytePtr appversion,
        @Nullable BytePtr appidentifier
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAppMetadata);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (appname != null ? appname.segment() : MemorySegment.NULL),
                (MemorySegment) (appversion != null ? appversion.segment() : MemorySegment.NULL),
                (MemorySegment) (appidentifier != null ? appidentifier.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Specify metadata about your app through a set of properties.
    ///
    /// You can optionally provide metadata about your app to SDL. This is not
    /// required, but strongly encouraged.
    ///
    /// There are several locations where SDL can make use of metadata (an "About"
    /// box in the macOS menu bar, the name of the app can be shown on some audio
    /// mixers, etc). Any piece of metadata can be left out, if a specific detail
    /// doesn't make sense for the app.
    ///
    /// This function should be called as early as possible, before SDL_Init.
    /// Multiple calls to this function are allowed, but various state might not
    /// change once it has been set up with a previous call to this function.
    ///
    /// Once set, this metadata can be read using SDL_GetAppMetadataProperty().
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the
    /// application, like "My Game 2: Bad Guy's Revenge!". This will show up
    /// anywhere the OS shows the name of the application separately from window
    /// titles, such as volume control applets, etc. This defaults to "SDL
    /// Application".
    /// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is
    /// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,
    /// 2024" and a git hash are all valid options. This has no default.
    /// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that
    /// identifies this app. This must be in reverse-domain format, like
    /// "com.example.mygame2". This string is used by desktop compositors to
    /// identify and group windows together, as well as match applications with
    /// associated desktop settings and icons. If you plan to package your
    /// application in a container such as Flatpak, the app ID should match the
    /// name of your Flatpak container as well. This has no default.
    /// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the
    /// creator/developer/maker of this app, like "MojoWorkshop, LLC"
    /// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright
    /// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this
    /// to one line, don't paste a copy of a whole software license in here. This
    /// has no default.
    /// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a
    /// product page, or a storefront, or even a GitHub repository, for user's
    /// further information This has no default.
    /// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.
    /// Currently this string can be "game" for a video game, "mediaplayer" for a
    /// media player, or generically "application" if nothing else applies.
    /// Future versions of SDL might add new types. This defaults to
    /// "application".
    ///
    /// @param name the name of the metadata property to set.
    /// @param value the value of the property, or NULL to remove that property.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAppMetadataProperty
    /// @see #setAppMetadata
    public @NativeType("boolean") boolean setAppMetadataProperty(
        @Nullable BytePtr name,
        @Nullable BytePtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetAppMetadataProperty);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get metadata about your app.
    ///
    /// This returns metadata previously set using SDL_SetAppMetadata() or
    /// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list
    /// of available properties and their meanings.
    ///
    /// @param name the name of the metadata property to get.
    /// @return the current value of the metadata property, or the default if it
    /// is not set, NULL for properties with no default.
    ///
    /// @threadsafety It is safe to call this function from any thread, although
    /// the string returned is not protected and could potentially be
    /// freed if you call SDL_SetAppMetadataProperty() to set that
    /// property from another thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setAppMetadata
    /// @see #setAppMetadataProperty
    public BytePtr getAppMetadataProperty(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAppMetadataProperty);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to create a new SDL_IOStream structure for reading from
    /// and/or writing to a named file.
    ///
    /// The `mode` string is treated roughly the same as in a call to the C
    /// library's fopen(), even if SDL doesn't happen to use fopen() behind the
    /// scenes.
    ///
    /// Available `mode` strings:
    ///
    /// - "r": Open a file for reading. The file must exist.
    /// - "w": Create an empty file for writing. If a file with the same name
    /// already exists its content is erased and the file is treated as a new
    /// empty file.
    /// - "a": Append to a file. Writing operations append data at the end of the
    /// file. The file is created if it does not exist.
    /// - "r+": Open a file for update both reading and writing. The file must
    /// exist.
    /// - "w+": Create an empty file for both reading and writing. If a file with
    /// the same name already exists its content is erased and the file is
    /// treated as a new empty file.
    /// - "a+": Open a file for reading and appending. All writing operations are
    /// performed at the end of the file, protecting the previous content to be
    /// overwritten. You can reposition (fseek, rewind) the internal pointer to
    /// anywhere in the file for reading, but writing operations will move it
    /// back to the end of file. The file is created if it does not exist.
    ///
    /// **NOTE**: In order to open a file as a binary file, a "b" character has to
    /// be included in the `mode` string. This additional "b" character can either
    /// be appended at the end of the string (thus making the following compound
    /// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
    /// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
    /// Additional characters may follow the sequence, although they should have no
    /// effect. For example, "t" is sometimes appended to make explicit the file is
    /// a text file.
    ///
    /// This function supports Unicode filenames, but they must be encoded in UTF-8
    /// format, regardless of the underlying operating system.
    ///
    /// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a
    /// fallback, SDL_IOFromFile() will transparently open a matching filename in
    /// the app's `assets`.
    ///
    /// Closing the SDL_IOStream will close SDL's internal file handle.
    ///
    /// The following properties may be set at creation time by SDL:
    ///
    /// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast
    /// to a win32 `HANDLE`, that this SDL_IOStream is using to access the
    /// filesystem. If the program isn't running on Windows, or SDL used some
    /// other method to access the filesystem, this property will not be set.
    /// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a
    /// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.
    /// If SDL used some other method to access the filesystem, this property
    /// will not be set. PLEASE NOTE that if SDL is using a different C runtime
    /// than your app, trying to use this pointer will almost certainly result in
    /// a crash! This is mostly a problem on Windows; make sure you build SDL and
    /// your app with the same compiler and settings to avoid it.
    /// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this
    /// SDL_IOStream is using to access the filesystem.
    /// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast
    /// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access
    /// the filesystem. If SDL used some other method to access the filesystem,
    /// this property will not be set.
    ///
    /// @param file a UTF-8 string representing the filename to open.
    /// @param mode an ASCII string representing the mode to be used for opening
    /// the file.
    /// @return a pointer to the SDL_IOStream structure that is created or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeIO
    /// @see #flushIO
    /// @see #readIO
    /// @see #seekIO
    /// @see #tellIO
    /// @see #writeIO
    public SDL_IOStream IOFromFile(
        @Nullable BytePtr file,
        @Nullable BytePtr mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IOFromFile);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL),
                (MemorySegment) (mode != null ? mode.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to prepare a read-write memory buffer for use with
    /// SDL_IOStream.
    ///
    /// This function sets up an SDL_IOStream struct based on a memory area of a
    /// certain size, for both read and write access.
    ///
    /// This memory buffer is not copied by the SDL_IOStream; the pointer you
    /// provide must remain valid until you close the stream. Closing the stream
    /// will not free the original buffer.
    ///
    /// If you need to make sure the SDL_IOStream never writes to the memory
    /// buffer, you should use SDL_IOFromConstMem() with a read-only buffer of
    /// memory instead.
    ///
    /// The following properties will be set at creation time by SDL:
    ///
    /// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that
    /// was passed to this function.
    /// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter
    /// that was passed to this function.
    ///
    /// @param mem a pointer to a buffer to feed an SDL_IOStream stream.
    /// @param size the buffer size, in bytes.
    /// @return a pointer to a new SDL_IOStream structure or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #IOFromConstMem
    /// @see #closeIO
    /// @see #flushIO
    /// @see #readIO
    /// @see #seekIO
    /// @see #tellIO
    /// @see #writeIO
    public SDL_IOStream IOFromMem(
        @Pointer(comment="void*") MemorySegment mem,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IOFromMem);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                mem,
                MemorySegment.ofAddress(size)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to prepare a read-only memory buffer for use with
    /// SDL_IOStream.
    ///
    /// This function sets up an SDL_IOStream struct based on a memory area of a
    /// certain size. It assumes the memory area is not writable.
    ///
    /// Attempting to write to this SDL_IOStream stream will report an error
    /// without writing to the memory buffer.
    ///
    /// This memory buffer is not copied by the SDL_IOStream; the pointer you
    /// provide must remain valid until you close the stream. Closing the stream
    /// will not free the original buffer.
    ///
    /// If you need to write to a memory buffer, you should use SDL_IOFromMem()
    /// with a writable buffer of memory instead.
    ///
    /// The following properties will be set at creation time by SDL:
    ///
    /// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that
    /// was passed to this function.
    /// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter
    /// that was passed to this function.
    ///
    /// @param mem a pointer to a read-only buffer to feed an SDL_IOStream stream.
    /// @param size the buffer size, in bytes.
    /// @return a pointer to a new SDL_IOStream structure or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #IOFromMem
    /// @see #closeIO
    /// @see #readIO
    /// @see #seekIO
    /// @see #tellIO
    public SDL_IOStream IOFromConstMem(
        @Pointer(comment="void*") MemorySegment mem,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IOFromConstMem);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                mem,
                MemorySegment.ofAddress(size)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to create an SDL_IOStream that is backed by dynamically
    /// allocated memory.
    ///
    /// This supports the following properties to provide access to the memory and
    /// control over allocations:
    ///
    /// - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal
    /// memory of the stream. This can be set to NULL to transfer ownership of
    /// the memory to the application, which should free the memory with
    /// SDL_free(). If this is done, the next operation on the stream must be
    /// SDL_CloseIO().
    /// - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in
    /// multiples of this size, defaulting to 1024.
    ///
    /// @return a pointer to a new SDL_IOStream structure or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeIO
    /// @see #readIO
    /// @see #seekIO
    /// @see #tellIO
    /// @see #writeIO
    public SDL_IOStream IOFromDynamicMem() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IOFromDynamicMem);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a custom SDL_IOStream.
    ///
    /// Applications do not need to use this function unless they are providing
    /// their own SDL_IOStream implementation. If you just need an SDL_IOStream to
    /// read/write a common data source, you should use the built-in
    /// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.
    ///
    /// This function makes a copy of `iface` and the caller does not need to keep
    /// it around after this call.
    ///
    /// @param iface the interface that implements this SDL_IOStream, initialized
    /// using SDL_INIT_INTERFACE().
    /// @param userdata the pointer that will be passed to the interface functions.
    /// @return a pointer to the allocated memory on success or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeIO
    /// @see `SDL_INIT_INTERFACE`
    /// @see #IOFromConstMem
    /// @see #IOFromFile
    /// @see #IOFromMem
    public SDL_IOStream openIO(
        @Nullable @Pointer ISDL_IOStreamInterface iface,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenIO);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (iface != null ? iface.segment() : MemorySegment.NULL),
                userdata
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close and free an allocated SDL_IOStream structure.
    ///
    /// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any
    /// resources used by the stream and frees the SDL_IOStream itself. This
    /// returns true on success, or false if the stream failed to flush to its
    /// output (e.g. to disk).
    ///
    /// Note that if this fails to flush the stream for any reason, this function
    /// reports an error, but the SDL_IOStream is still invalid once this function
    /// returns.
    ///
    /// This call flushes any buffered writes to the operating system, but there
    /// are no guarantees that those writes have gone to physical media; they might
    /// be in the OS's file cache, waiting to go to disk later. If it's absolutely
    /// crucial that writes go to disk immediately, so they are definitely stored
    /// even if the power fails before the file cache would have caught up, one
    /// should call SDL_FlushIO() before closing. Note that flushing takes time and
    /// makes the system and your app operate less efficiently, so do so sparingly.
    ///
    /// @param context SDL_IOStream structure to close.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openIO
    public @NativeType("boolean") boolean closeIO(
        @Nullable SDL_IOStream context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseIO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with an SDL_IOStream.
    ///
    /// @param context a pointer to an SDL_IOStream structure.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getIOProperties(
        @Nullable SDL_IOStream context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetIOProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the stream status of an SDL_IOStream.
    ///
    /// This information can be useful to decide if a short read or write was due
    /// to an error, an EOF, or a non-blocking operation that isn't yet ready to
    /// complete.
    ///
    /// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or
    /// SDL_WriteIO call; don't expect it to change if you just call this query
    /// function in a tight loop.
    ///
    /// @param context the SDL_IOStream to query.
    /// @return an SDL_IOStatus enum with the current state.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_IOStatus.class) int getIOStatus(
        @Nullable SDL_IOStream context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetIOStatus);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the size of the data stream in an SDL_IOStream.
    ///
    /// @param context the SDL_IOStream to get the size of the data stream from.
    /// @return the size of the data stream in the SDL_IOStream on success or a
    /// negative error code on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Sint64") long getIOSize(
        @Nullable SDL_IOStream context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetIOSize);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Seek within an SDL_IOStream data stream.
    ///
    /// This function seeks to byte `offset`, relative to `whence`.
    ///
    /// `whence` may be any of the following values:
    ///
    /// - `SDL_IO_SEEK_SET`: seek from the beginning of data
    /// - `SDL_IO_SEEK_CUR`: seek relative to current read point
    /// - `SDL_IO_SEEK_END`: seek relative to the end of data
    ///
    /// If this stream can not seek, it will return -1.
    ///
    /// @param context a pointer to an SDL_IOStream structure.
    /// @param offset an offset in bytes, relative to `whence` location; can be
    /// negative.
    /// @param whence any of `SDL_IO_SEEK_SET`, `SDL_IO_SEEK_CUR`,
    /// `SDL_IO_SEEK_END`.
    /// @return the final offset in the data stream after the seek or -1 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #tellIO
    public @NativeType("Sint64") long seekIO(
        @Nullable SDL_IOStream context,
        @NativeType("Sint64") long offset,
        @EnumType(SDL_IOWhence.class) int whence
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SeekIO);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL),
                offset,
                whence
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine the current read/write offset in an SDL_IOStream data stream.
    ///
    /// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's
    /// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to
    /// simplify application development.
    ///
    /// @param context an SDL_IOStream data stream object from which to get the
    /// current offset.
    /// @return the current offset in the stream, or -1 if the information can not
    /// be determined.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #seekIO
    public @NativeType("Sint64") long tellIO(
        @Nullable SDL_IOStream context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TellIO);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Read from a data source.
    ///
    /// This function reads up `size` bytes from the data source to the area
    /// pointed at by `ptr`. This function may read less bytes than requested.
    ///
    /// This function will return zero when the data stream is completely read, and
    /// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and
    /// the stream is not at EOF, SDL_GetIOStatus() will return a different error
    /// value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param context a pointer to an SDL_IOStream structure.
    /// @param ptr a pointer to a buffer to read data into.
    /// @param size the number of bytes to read from the data source.
    /// @return the number of bytes read, or 0 on end of file or other failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #writeIO
    /// @see #getIOStatus
    public long readIO(
        @Nullable SDL_IOStream context,
        @Pointer(comment="void*") MemorySegment ptr,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadIO);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL),
                ptr,
                MemorySegment.ofAddress(size)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Write to an SDL_IOStream data stream.
    ///
    /// This function writes exactly `size` bytes from the area pointed at by `ptr`
    /// to the stream. If this fails for any reason, it'll return less than `size`
    /// to demonstrate how far the write progressed. On success, it returns `size`.
    ///
    /// On error, this function still attempts to write as much as possible, so it
    /// might return a positive value less than the requested write size.
    ///
    /// The caller can use SDL_GetIOStatus() to determine if the problem is
    /// recoverable, such as a non-blocking write that can simply be retried later,
    /// or a fatal error.
    ///
    /// @param context a pointer to an SDL_IOStream structure.
    /// @param ptr a pointer to a buffer containing data to write.
    /// @param size the number of bytes to write.
    /// @return the number of bytes written, which will be less than `size` on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #IOprintf
    /// @see #readIO
    /// @see #seekIO
    /// @see #flushIO
    /// @see #getIOStatus
    public long writeIO(
        @Nullable SDL_IOStream context,
        @Pointer(comment="void*") MemorySegment ptr,
        long size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteIO);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL),
                ptr,
                MemorySegment.ofAddress(size)
            );
            return s.address();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Flush any buffered data in the stream.
    ///
    /// This function makes sure that any buffered data is written to the stream.
    /// Normally this isn't necessary but if the stream is a pipe or socket it
    /// guarantees that any pending data is sent.
    ///
    /// @param context SDL_IOStream structure to flush.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openIO
    /// @see #writeIO
    public @NativeType("boolean") boolean flushIO(
        @Nullable SDL_IOStream context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlushIO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load all the data from an SDL data stream.
    ///
    /// The data is allocated with a zero byte at the end (null terminated) for
    /// convenience. This extra byte is not included in the value reported via
    /// `datasize`.
    ///
    /// The data should be freed with SDL_free().
    ///
    /// @param src the SDL_IOStream to read all available data from.
    /// @param datasize a pointer filled in with the number of bytes read, may be
    /// NULL.
    /// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
    /// in the case of an error.
    /// @return the data or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadFile
    /// @see #saveFile_IO
    public @Pointer(comment="void*") MemorySegment loadFile_IO(
        @Nullable SDL_IOStream src,
        @Nullable PointerPtr datasize,
        @NativeType("boolean") boolean closeio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadFile_IO);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (datasize != null ? datasize.segment() : MemorySegment.NULL),
                closeio
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load all the data from a file path.
    ///
    /// The data is allocated with a zero byte at the end (null terminated) for
    /// convenience. This extra byte is not included in the value reported via
    /// `datasize`.
    ///
    /// The data should be freed with SDL_free().
    ///
    /// @param file the path to read all available data from.
    /// @param datasize if not NULL, will store the number of bytes read.
    /// @return the data or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadFile_IO
    /// @see #saveFile
    public @Pointer(comment="void*") MemorySegment loadFile(
        @Nullable BytePtr file,
        @Nullable PointerPtr datasize
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadFile);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL),
                (MemorySegment) (datasize != null ? datasize.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Save all the data into an SDL data stream.
    ///
    /// @param src the SDL_IOStream to write all data to.
    /// @param data the data to be written. If datasize is 0, may be NULL or a
    /// invalid pointer.
    /// @param datasize the number of bytes to be written.
    /// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
    /// in the case of an error.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #saveFile
    /// @see #loadFile_IO
    public @NativeType("boolean") boolean saveFile_IO(
        @Nullable SDL_IOStream src,
        @Pointer(comment="void*") MemorySegment data,
        long datasize,
        @NativeType("boolean") boolean closeio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SaveFile_IO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                data,
                MemorySegment.ofAddress(datasize),
                closeio
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Save all the data into a file path.
    ///
    /// @param file the path to write all available data into.
    /// @param data the data to be written. If datasize is 0, may be NULL or a
    /// invalid pointer.
    /// @param datasize the number of bytes to be written.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #saveFile_IO
    /// @see #loadFile
    public @NativeType("boolean") boolean saveFile(
        @Nullable BytePtr file,
        @Pointer(comment="void*") MemorySegment data,
        long datasize
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SaveFile);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL),
                data,
                MemorySegment.ofAddress(datasize)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read a byte from an SDL_IOStream.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the SDL_IOStream to read from.
    /// @param value a pointer filled in with the data read.
    /// @return true on success or false on failure or EOF; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU8(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU8);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read a signed byte from an SDL_IOStream.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the SDL_IOStream to read from.
    /// @param value a pointer filled in with the data read.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS8(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint8") BytePtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS8);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 16 bits of little-endian data from an
    /// SDL_IOStream and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU16LE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint16") @Unsigned ShortPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU16LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 16 bits of little-endian data from an
    /// SDL_IOStream and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS16LE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint16") ShortPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS16LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 16 bits of big-endian data from an SDL_IOStream
    /// and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU16BE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint16") @Unsigned ShortPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU16BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 16 bits of big-endian data from an SDL_IOStream
    /// and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS16BE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint16") ShortPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS16BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 32 bits of little-endian data from an
    /// SDL_IOStream and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU32LE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU32LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 32 bits of little-endian data from an
    /// SDL_IOStream and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS32LE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint32") IntPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS32LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 32 bits of big-endian data from an SDL_IOStream
    /// and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU32BE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU32BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 32 bits of big-endian data from an SDL_IOStream
    /// and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS32BE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint32") IntPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS32BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 64 bits of little-endian data from an
    /// SDL_IOStream and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU64LE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU64LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 64 bits of little-endian data from an
    /// SDL_IOStream and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS64LE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint64") LongPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS64LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 64 bits of big-endian data from an SDL_IOStream
    /// and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readU64BE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadU64BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to read 64 bits of big-endian data from an SDL_IOStream
    /// and return in native format.
    ///
    /// SDL byteswaps the data only if necessary, so the data returned will be in
    /// the native byte order.
    ///
    /// This function will return false when the data stream is completely read,
    /// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
    /// and the stream is not at EOF, SDL_GetIOStatus() will return a different
    /// error value and SDL_GetError() will offer a human-readable message.
    ///
    /// @param src the stream from which to read data.
    /// @param value a pointer filled in with the data read.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readS64BE(
        @Nullable SDL_IOStream src,
        @Nullable @Pointer(comment="Sint64") LongPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadS64BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write a byte to an SDL_IOStream.
    ///
    /// @param dst the SDL_IOStream to write to.
    /// @param value the byte value to write.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU8(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint8") @Unsigned byte value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU8);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write a signed byte to an SDL_IOStream.
    ///
    /// @param dst the SDL_IOStream to write to.
    /// @param value the byte value to write.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS8(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint8") byte value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS8);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 16 bits in native format to an SDL_IOStream as
    /// little-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in little-endian
    /// format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU16LE(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint16") @Unsigned short value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU16LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 16 bits in native format to an SDL_IOStream as
    /// little-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in little-endian
    /// format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS16LE(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint16") short value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS16LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 16 bits in native format to an SDL_IOStream as
    /// big-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in big-endian format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU16BE(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint16") @Unsigned short value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU16BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 16 bits in native format to an SDL_IOStream as
    /// big-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in big-endian format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS16BE(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint16") short value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS16BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 32 bits in native format to an SDL_IOStream as
    /// little-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in little-endian
    /// format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU32LE(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint32") @Unsigned int value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU32LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 32 bits in native format to an SDL_IOStream as
    /// little-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in little-endian
    /// format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS32LE(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint32") int value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS32LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 32 bits in native format to an SDL_IOStream as
    /// big-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in big-endian format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU32BE(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint32") @Unsigned int value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU32BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 32 bits in native format to an SDL_IOStream as
    /// big-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in big-endian format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS32BE(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint32") int value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS32BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 64 bits in native format to an SDL_IOStream as
    /// little-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in little-endian
    /// format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU64LE(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint64") @Unsigned long value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU64LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 64 bits in native format to an SDL_IOStream as
    /// little-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in little-endian
    /// format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS64LE(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint64") long value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS64LE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 64 bits in native format to an SDL_IOStream as
    /// big-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in big-endian format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeU64BE(
        @Nullable SDL_IOStream dst,
        @NativeType("Uint64") @Unsigned long value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteU64BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to write 64 bits in native format to an SDL_IOStream as
    /// big-endian data.
    ///
    /// SDL byteswaps the data only if necessary, so the application always
    /// specifies native format, and the data written will be in big-endian format.
    ///
    /// @param dst the stream to which data will be written.
    /// @param value the data to be written, in native format.
    /// @return true on successful write or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeS64BE(
        @Nullable SDL_IOStream dst,
        @NativeType("Sint64") long value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteS64BE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Locking for atomic access to the joystick API.
    ///
    /// The SDL joystick functions are thread-safe, however you can lock the
    /// joysticks while processing to guarantee that the joystick list won't change
    /// and joystick and gamepad events will not be delivered.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void lockJoysticks() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockJoysticks);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlocking for atomic access to the joystick API.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void unlockJoysticks() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockJoysticks);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a joystick is currently connected.
    ///
    /// @return true if a joystick is connected, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoysticks
    public @NativeType("boolean") boolean hasJoystick() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasJoystick);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected joysticks.
    ///
    /// @param count a pointer filled in with the number of joysticks returned, may
    /// be NULL.
    /// @return a 0 terminated array of joystick instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasJoystick
    /// @see #openJoystick
    public @Pointer(comment="SDL_JoystickID") @Unsigned IntPtr getJoysticks(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoysticks);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a joystick.
    ///
    /// This can be called before any joysticks are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the name of the selected joystick. If no name can be found, this
    /// function returns NULL; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickName
    /// @see #getJoysticks
    public BytePtr getJoystickNameForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickNameForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent path of a joystick.
    ///
    /// This can be called before any joysticks are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the path of the selected joystick. If no path can be found, this
    /// function returns NULL; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickPath
    /// @see #getJoysticks
    public BytePtr getJoystickPathForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickPathForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the player index of a joystick.
    ///
    /// This can be called before any joysticks are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the player index of a joystick, or -1 if it's not available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickPlayerIndex
    /// @see #getJoysticks
    public int getJoystickPlayerIndexForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickPlayerIndexForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation-dependent GUID of a joystick.
    ///
    /// This can be called before any joysticks are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the GUID of the selected joystick. If called with an invalid
    /// instance_id, this function returns a zero GUID.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickGUID
    /// @see #GUIDToString
    public SDL_GUID getJoystickGUIDForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickGUIDForID);
        try {
            return new SDL_GUID((MemorySegment) hFunction.invokeExact(
                instance_id
            ));
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB vendor ID of a joystick, if available.
    ///
    /// This can be called before any joysticks are opened. If the vendor ID isn't
    /// available this function returns 0.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the USB vendor ID of the selected joystick. If called with an
    /// invalid instance_id, this function returns 0.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickVendor
    /// @see #getJoysticks
    public @NativeType("Uint16") @Unsigned short getJoystickVendorForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickVendorForID);
        try {
            return (short) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB product ID of a joystick, if available.
    ///
    /// This can be called before any joysticks are opened. If the product ID isn't
    /// available this function returns 0.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the USB product ID of the selected joystick. If called with an
    /// invalid instance_id, this function returns 0.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickProduct
    /// @see #getJoysticks
    public @NativeType("Uint16") @Unsigned short getJoystickProductForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickProductForID);
        try {
            return (short) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the product version of a joystick, if available.
    ///
    /// This can be called before any joysticks are opened. If the product version
    /// isn't available this function returns 0.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the product version of the selected joystick. If called with an
    /// invalid instance_id, this function returns 0.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickProductVersion
    /// @see #getJoysticks
    public @NativeType("Uint16") @Unsigned short getJoystickProductVersionForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickProductVersionForID);
        try {
            return (short) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of a joystick, if available.
    ///
    /// This can be called before any joysticks are opened.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return the SDL_JoystickType of the selected joystick. If called with an
    /// invalid instance_id, this function returns
    /// `SDL_JOYSTICK_TYPE_UNKNOWN`.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickType
    /// @see #getJoysticks
    public @EnumType(SDL_JoystickType.class) int getJoystickTypeForID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickTypeForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a joystick for use.
    ///
    /// The joystick subsystem must be initialized before a joystick can be opened
    /// for use.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return a joystick identifier or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeJoystick
    public SDL_Joystick openJoystick(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenJoystick);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Joystick(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_Joystick associated with an instance ID, if it has been opened.
    ///
    /// @param instance_id the instance ID to get the SDL_Joystick for.
    /// @return an SDL_Joystick on success or NULL on failure or if it hasn't been
    /// opened yet; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Joystick getJoystickFromID(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickFromID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Joystick(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_Joystick associated with a player index.
    ///
    /// @param player_index the player index to get the SDL_Joystick for.
    /// @return an SDL_Joystick on success or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickPlayerIndex
    /// @see #setJoystickPlayerIndex
    public SDL_Joystick getJoystickFromPlayerIndex(
        int player_index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickFromPlayerIndex);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                player_index
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Joystick(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Attach a new virtual joystick.
    ///
    /// @param desc joystick description, initialized using SDL_INIT_INTERFACE().
    /// @return the joystick instance ID, or 0 on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #detachVirtualJoystick
    public @NativeType("SDL_JoystickID") @Unsigned int attachVirtualJoystick(
        @Nullable @Pointer ISDL_VirtualJoystickDesc desc
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AttachVirtualJoystick);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (desc != null ? desc.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Detach a virtual joystick.
    ///
    /// @param instance_id the joystick instance ID, previously returned from
    /// SDL_AttachVirtualJoystick().
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #attachVirtualJoystick
    public @NativeType("boolean") boolean detachVirtualJoystick(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DetachVirtualJoystick);
        try {
            return (boolean) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether or not a joystick is virtual.
    ///
    /// @param instance_id the joystick instance ID.
    /// @return true if the joystick is virtual, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isJoystickVirtual(
        @NativeType("SDL_JoystickID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsJoystickVirtual);
        try {
            return (boolean) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the state of an axis on an opened virtual joystick.
    ///
    /// Please note that values set here will not be applied until the next call to
    /// SDL_UpdateJoysticks, which can either be called directly, or can be called
    /// indirectly through various other SDL APIs, including, but not limited to
    /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
    /// SDL_WaitEvent.
    ///
    /// Note that when sending trigger axes, you should scale the value to the full
    /// range of Sint16. For example, a trigger at rest would have the value of
    /// `SDL_JOYSTICK_AXIS_MIN`.
    ///
    /// @param joystick the virtual joystick on which to set state.
    /// @param axis the index of the axis on the virtual joystick to update.
    /// @param value the new value for the specified axis.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setJoystickVirtualAxis(
        @Nullable SDL_Joystick joystick,
        int axis,
        @NativeType("Sint16") short value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickVirtualAxis);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                axis,
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Generate ball motion on an opened virtual joystick.
    ///
    /// Please note that values set here will not be applied until the next call to
    /// SDL_UpdateJoysticks, which can either be called directly, or can be called
    /// indirectly through various other SDL APIs, including, but not limited to
    /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
    /// SDL_WaitEvent.
    ///
    /// @param joystick the virtual joystick on which to set state.
    /// @param ball the index of the ball on the virtual joystick to update.
    /// @param xrel the relative motion on the X axis.
    /// @param yrel the relative motion on the Y axis.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setJoystickVirtualBall(
        @Nullable SDL_Joystick joystick,
        int ball,
        @NativeType("Sint16") short xrel,
        @NativeType("Sint16") short yrel
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickVirtualBall);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                ball,
                xrel,
                yrel
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the state of a button on an opened virtual joystick.
    ///
    /// Please note that values set here will not be applied until the next call to
    /// SDL_UpdateJoysticks, which can either be called directly, or can be called
    /// indirectly through various other SDL APIs, including, but not limited to
    /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
    /// SDL_WaitEvent.
    ///
    /// @param joystick the virtual joystick on which to set state.
    /// @param button the index of the button on the virtual joystick to update.
    /// @param down true if the button is pressed, false otherwise.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setJoystickVirtualButton(
        @Nullable SDL_Joystick joystick,
        int button,
        @NativeType("boolean") boolean down
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickVirtualButton);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                button,
                down
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the state of a hat on an opened virtual joystick.
    ///
    /// Please note that values set here will not be applied until the next call to
    /// SDL_UpdateJoysticks, which can either be called directly, or can be called
    /// indirectly through various other SDL APIs, including, but not limited to
    /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
    /// SDL_WaitEvent.
    ///
    /// @param joystick the virtual joystick on which to set state.
    /// @param hat the index of the hat on the virtual joystick to update.
    /// @param value the new value for the specified hat.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setJoystickVirtualHat(
        @Nullable SDL_Joystick joystick,
        int hat,
        @NativeType("Uint8") @Unsigned byte value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickVirtualHat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                hat,
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set touchpad finger state on an opened virtual joystick.
    ///
    /// Please note that values set here will not be applied until the next call to
    /// SDL_UpdateJoysticks, which can either be called directly, or can be called
    /// indirectly through various other SDL APIs, including, but not limited to
    /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
    /// SDL_WaitEvent.
    ///
    /// @param joystick the virtual joystick on which to set state.
    /// @param touchpad the index of the touchpad on the virtual joystick to
    /// update.
    /// @param finger the index of the finger on the touchpad to set.
    /// @param down true if the finger is pressed, false if the finger is released.
    /// @param x the x coordinate of the finger on the touchpad, normalized 0 to 1,
    /// with the origin in the upper left.
    /// @param y the y coordinate of the finger on the touchpad, normalized 0 to 1,
    /// with the origin in the upper left.
    /// @param pressure the pressure of the finger.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setJoystickVirtualTouchpad(
        @Nullable SDL_Joystick joystick,
        int touchpad,
        int finger,
        @NativeType("boolean") boolean down,
        float x,
        float y,
        float pressure
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickVirtualTouchpad);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                touchpad,
                finger,
                down,
                x,
                y,
                pressure
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Send a sensor update for an opened virtual joystick.
    ///
    /// Please note that values set here will not be applied until the next call to
    /// SDL_UpdateJoysticks, which can either be called directly, or can be called
    /// indirectly through various other SDL APIs, including, but not limited to
    /// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
    /// SDL_WaitEvent.
    ///
    /// @param joystick the virtual joystick on which to set state.
    /// @param type the type of the sensor on the virtual joystick to update.
    /// @param sensor_timestamp a 64-bit timestamp in nanoseconds associated with
    /// the sensor reading.
    /// @param data the data associated with the sensor reading.
    /// @param num_values the number of values pointed to by `data`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean sendJoystickVirtualSensorData(
        @Nullable SDL_Joystick joystick,
        @EnumType(SDL_SensorType.class) int type,
        @NativeType("Uint64") @Unsigned long sensor_timestamp,
        @Nullable FloatPtr data,
        int num_values
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SendJoystickVirtualSensorData);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                type,
                sensor_timestamp,
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                num_values
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a joystick.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an
    /// LED that has adjustable brightness
    /// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED
    /// that has adjustable color
    /// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a
    /// player LED
    /// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has
    /// left/right rumble
    /// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has
    /// simple trigger rumble
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getJoystickProperties(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a joystick.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the name of the selected joystick. If no name can be found, this
    /// function returns NULL; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickNameForID
    public BytePtr getJoystickName(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent path of a joystick.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the path of the selected joystick. If no path can be found, this
    /// function returns NULL; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickPathForID
    public BytePtr getJoystickPath(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickPath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the player index of an opened joystick.
    ///
    /// For XInput controllers this returns the XInput user index. Many joysticks
    /// will not be able to supply this information.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the player index, or -1 if it's not available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setJoystickPlayerIndex
    public int getJoystickPlayerIndex(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickPlayerIndex);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the player index of an opened joystick.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @param player_index player index to assign to this joystick, or -1 to clear
    /// the player index and turn off player LEDs.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickPlayerIndex
    public @NativeType("boolean") boolean setJoystickPlayerIndex(
        @Nullable SDL_Joystick joystick,
        int player_index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickPlayerIndex);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                player_index
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation-dependent GUID for the joystick.
    ///
    /// This function requires an open joystick.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the GUID of the given joystick. If called on an invalid index,
    /// this function returns a zero GUID; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickGUIDForID
    /// @see #GUIDToString
    public SDL_GUID getJoystickGUID(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickGUID);
        try {
            return new SDL_GUID((MemorySegment) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            ));
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB vendor ID of an opened joystick, if available.
    ///
    /// If the vendor ID isn't available this function returns 0.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the USB vendor ID of the selected joystick, or 0 if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickVendorForID
    public @NativeType("Uint16") @Unsigned short getJoystickVendor(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickVendor);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the USB product ID of an opened joystick, if available.
    ///
    /// If the product ID isn't available this function returns 0.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the USB product ID of the selected joystick, or 0 if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickProductForID
    public @NativeType("Uint16") @Unsigned short getJoystickProduct(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickProduct);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the product version of an opened joystick, if available.
    ///
    /// If the product version isn't available this function returns 0.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the product version of the selected joystick, or 0 if unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickProductVersionForID
    public @NativeType("Uint16") @Unsigned short getJoystickProductVersion(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickProductVersion);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the firmware version of an opened joystick, if available.
    ///
    /// If the firmware version isn't available this function returns 0.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the firmware version of the selected joystick, or 0 if
    /// unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint16") @Unsigned short getJoystickFirmwareVersion(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickFirmwareVersion);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the serial number of an opened joystick, if available.
    ///
    /// Returns the serial number of the joystick, or NULL if it is not available.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the serial number of the selected joystick, or NULL if
    /// unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getJoystickSerial(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickSerial);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of an opened joystick.
    ///
    /// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
    /// @return the SDL_JoystickType of the selected joystick.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickTypeForID
    public @EnumType(SDL_JoystickType.class) int getJoystickType(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickType);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the device information encoded in a SDL_GUID structure.
    ///
    /// @param guid the SDL_GUID you wish to get info about.
    /// @param vendor a pointer filled in with the device VID, or 0 if not
    /// available.
    /// @param product a pointer filled in with the device PID, or 0 if not
    /// available.
    /// @param version a pointer filled in with the device version, or 0 if not
    /// available.
    /// @param crc16 a pointer filled in with a CRC used to distinguish different
    /// products with the same VID/PID, or 0 if not available.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickGUIDForID
    public void getJoystickGUIDInfo(
        SDL_GUID guid,
        @Nullable @Pointer(comment="Uint16") @Unsigned ShortPtr vendor,
        @Nullable @Pointer(comment="Uint16") @Unsigned ShortPtr product,
        @Nullable @Pointer(comment="Uint16") @Unsigned ShortPtr version,
        @Nullable @Pointer(comment="Uint16") @Unsigned ShortPtr crc16
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickGUIDInfo);
        try {
            hFunction.invokeExact(
                guid.segment(),
                (MemorySegment) (vendor != null ? vendor.segment() : MemorySegment.NULL),
                (MemorySegment) (product != null ? product.segment() : MemorySegment.NULL),
                (MemorySegment) (version != null ? version.segment() : MemorySegment.NULL),
                (MemorySegment) (crc16 != null ? crc16.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the status of a specified joystick.
    ///
    /// @param joystick the joystick to query.
    /// @return true if the joystick has been opened, false if it has not; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean joystickConnected(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_JoystickConnected);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the instance ID of an opened joystick.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @return the instance ID of the specified joystick on success or 0 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_JoystickID") @Unsigned int getJoystickID(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickID);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of general axis controls on a joystick.
    ///
    /// Often, the directional pad on a game controller will either look like 4
    /// separate buttons or a POV hat, and not axes, but all of this is up to the
    /// device and platform.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @return the number of axis controls/number of axes on success or -1 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickAxis
    /// @see #getNumJoystickBalls
    /// @see #getNumJoystickButtons
    /// @see #getNumJoystickHats
    public int getNumJoystickAxes(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumJoystickAxes);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of trackballs on a joystick.
    ///
    /// Joystick trackballs have only relative motion events associated with them
    /// and their state cannot be polled.
    ///
    /// Most joysticks do not have trackballs.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @return the number of trackballs on success or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickBall
    /// @see #getNumJoystickAxes
    /// @see #getNumJoystickButtons
    /// @see #getNumJoystickHats
    public int getNumJoystickBalls(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumJoystickBalls);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of POV hats on a joystick.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @return the number of POV hats on success or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickHat
    /// @see #getNumJoystickAxes
    /// @see #getNumJoystickBalls
    /// @see #getNumJoystickButtons
    public int getNumJoystickHats(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumJoystickHats);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of buttons on a joystick.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @return the number of buttons on success or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getJoystickButton
    /// @see #getNumJoystickAxes
    /// @see #getNumJoystickBalls
    /// @see #getNumJoystickHats
    public int getNumJoystickButtons(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumJoystickButtons);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the state of joystick event processing.
    ///
    /// If joystick events are disabled, you must call SDL_UpdateJoysticks()
    /// yourself and check the state of the joystick when you want joystick
    /// information.
    ///
    /// @param enabled whether to process joystick events or not.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #joystickEventsEnabled
    /// @see #updateJoysticks
    public void setJoystickEventsEnabled(
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickEventsEnabled);
        try {
            hFunction.invokeExact(
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the state of joystick event processing.
    ///
    /// If joystick events are disabled, you must call SDL_UpdateJoysticks()
    /// yourself and check the state of the joystick when you want joystick
    /// information.
    ///
    /// @return true if joystick events are being processed, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setJoystickEventsEnabled
    public @NativeType("boolean") boolean joystickEventsEnabled() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_JoystickEventsEnabled);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update the current state of the open joysticks.
    ///
    /// This is called automatically by the event loop if any joystick events are
    /// enabled.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void updateJoysticks() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateJoysticks);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of an axis control on a joystick.
    ///
    /// SDL makes no promises about what part of the joystick any given axis refers
    /// to. Your game should have some sort of configuration UI to let users
    /// specify what each axis should be bound to. Alternately, SDL's higher-level
    /// Game Controller API makes a great effort to apply order to this lower-level
    /// interface, so you know that a specific axis is the "left thumb stick," etc.
    ///
    /// The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to
    /// 32767) representing the current position of the axis. It may be necessary
    /// to impose certain tolerances on these values to account for jitter.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @param axis the axis to query; the axis indices start at index 0.
    /// @return a 16-bit signed integer representing the current position of the
    /// axis or 0 on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumJoystickAxes
    public @NativeType("Sint16") short getJoystickAxis(
        @Nullable SDL_Joystick joystick,
        int axis
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickAxis);
        try {
            return (short) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                axis
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the initial state of an axis control on a joystick.
    ///
    /// The state is a value ranging from -32768 to 32767.
    ///
    /// The axis indices start at index 0.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @param axis the axis to query; the axis indices start at index 0.
    /// @param state upon return, the initial value is supplied here.
    /// @return true if this axis has any initial value, or false if not.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getJoystickAxisInitialState(
        @Nullable SDL_Joystick joystick,
        int axis,
        @Nullable @Pointer(comment="Sint16") ShortPtr state
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickAxisInitialState);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                axis,
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the ball axis change since the last poll.
    ///
    /// Trackballs can only return relative motion since the last call to
    /// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.
    ///
    /// Most joysticks do not have trackballs.
    ///
    /// @param joystick the SDL_Joystick to query.
    /// @param ball the ball index to query; ball indices start at index 0.
    /// @param dx stores the difference in the x axis position since the last poll.
    /// @param dy stores the difference in the y axis position since the last poll.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumJoystickBalls
    public @NativeType("boolean") boolean getJoystickBall(
        @Nullable SDL_Joystick joystick,
        int ball,
        @Nullable IntPtr dx,
        @Nullable IntPtr dy
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickBall);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                ball,
                (MemorySegment) (dx != null ? dx.segment() : MemorySegment.NULL),
                (MemorySegment) (dy != null ? dy.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of a POV hat on a joystick.
    ///
    /// The returned value will be one of the `SDL_HAT_*` values.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @param hat the hat index to get the state from; indices start at index 0.
    /// @return the current hat position.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumJoystickHats
    public @NativeType("Uint8") @Unsigned byte getJoystickHat(
        @Nullable SDL_Joystick joystick,
        int hat
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickHat);
        try {
            return (byte) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                hat
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of a button on a joystick.
    ///
    /// @param joystick an SDL_Joystick structure containing joystick information.
    /// @param button the button index to get the state from; indices start at
    /// index 0.
    /// @return true if the button is pressed, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumJoystickButtons
    public @NativeType("boolean") boolean getJoystickButton(
        @Nullable SDL_Joystick joystick,
        int button
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickButton);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                button
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start a rumble effect.
    ///
    /// Each call to this function cancels any previous rumble effect, and calling
    /// it with 0 intensity stops any rumbling.
    ///
    /// This function requires you to process SDL events or call
    /// SDL_UpdateJoysticks() to update rumble state.
    ///
    /// @param joystick the joystick to vibrate.
    /// @param low_frequency_rumble the intensity of the low frequency (left)
    /// rumble motor, from 0 to 0xFFFF.
    /// @param high_frequency_rumble the intensity of the high frequency (right)
    /// rumble motor, from 0 to 0xFFFF.
    /// @param duration_ms the duration of the rumble effect, in milliseconds.
    /// @return true, or false if rumble isn't supported on this joystick.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean rumbleJoystick(
        @Nullable SDL_Joystick joystick,
        @NativeType("Uint16") @Unsigned short low_frequency_rumble,
        @NativeType("Uint16") @Unsigned short high_frequency_rumble,
        @NativeType("Uint32") @Unsigned int duration_ms
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RumbleJoystick);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                low_frequency_rumble,
                high_frequency_rumble,
                duration_ms
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start a rumble effect in the joystick's triggers.
    ///
    /// Each call to this function cancels any previous trigger rumble effect, and
    /// calling it with 0 intensity stops any rumbling.
    ///
    /// Note that this is rumbling of the _triggers_ and not the game controller as
    /// a whole. This is currently only supported on Xbox One controllers. If you
    /// want the (more common) whole-controller rumble, use SDL_RumbleJoystick()
    /// instead.
    ///
    /// This function requires you to process SDL events or call
    /// SDL_UpdateJoysticks() to update rumble state.
    ///
    /// @param joystick the joystick to vibrate.
    /// @param left_rumble the intensity of the left trigger rumble motor, from 0
    /// to 0xFFFF.
    /// @param right_rumble the intensity of the right trigger rumble motor, from 0
    /// to 0xFFFF.
    /// @param duration_ms the duration of the rumble effect, in milliseconds.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #rumbleJoystick
    public @NativeType("boolean") boolean rumbleJoystickTriggers(
        @Nullable SDL_Joystick joystick,
        @NativeType("Uint16") @Unsigned short left_rumble,
        @NativeType("Uint16") @Unsigned short right_rumble,
        @NativeType("Uint32") @Unsigned int duration_ms
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RumbleJoystickTriggers);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                left_rumble,
                right_rumble,
                duration_ms
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update a joystick's LED color.
    ///
    /// An example of a joystick LED is the light on the back of a PlayStation 4's
    /// DualShock 4 controller.
    ///
    /// For joysticks with a single color LED, the maximum of the RGB values will
    /// be used as the LED brightness.
    ///
    /// @param joystick the joystick to update.
    /// @param red the intensity of the red LED.
    /// @param green the intensity of the green LED.
    /// @param blue the intensity of the blue LED.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setJoystickLED(
        @Nullable SDL_Joystick joystick,
        @NativeType("Uint8") @Unsigned byte red,
        @NativeType("Uint8") @Unsigned byte green,
        @NativeType("Uint8") @Unsigned byte blue
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetJoystickLED);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                red,
                green,
                blue
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Send a joystick specific effect packet.
    ///
    /// @param joystick the joystick to affect.
    /// @param data the data to send to the joystick.
    /// @param size the size of the data to send to the joystick.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean sendJoystickEffect(
        @Nullable SDL_Joystick joystick,
        @Pointer(comment="void*") MemorySegment data,
        int size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SendJoystickEffect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                data,
                size
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close a joystick previously opened with SDL_OpenJoystick().
    ///
    /// @param joystick the joystick device to close.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openJoystick
    public void closeJoystick(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseJoystick);
        try {
            hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the connection state of a joystick.
    ///
    /// @param joystick the joystick to query.
    /// @return the connection state on success or
    /// `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_JoystickConnectionState.class) int getJoystickConnectionState(
        @Nullable SDL_Joystick joystick
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickConnectionState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the battery state of a joystick.
    ///
    /// You should never take a battery status as absolute truth. Batteries
    /// (especially failing batteries) are delicate hardware, and the values
    /// reported here are best estimates based on what that hardware reports. It's
    /// not uncommon for older batteries to lose stored power much faster than it
    /// reports, or completely drain when reporting it has 20 percent left, etc.
    ///
    /// @param joystick the joystick to query.
    /// @param percent a pointer filled in with the percentage of battery life
    /// left, between 0 and 100, or NULL to ignore. This will be
    /// filled in with -1 we can't determine a value or there is no
    /// battery.
    /// @return the current battery state or `SDL_POWERSTATE_ERROR` on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_PowerState.class) int getJoystickPowerInfo(
        @Nullable SDL_Joystick joystick,
        @Nullable IntPtr percent
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetJoystickPowerInfo);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (joystick != null ? joystick.segment() : MemorySegment.NULL),
                (MemorySegment) (percent != null ? percent.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a keyboard is currently connected.
    ///
    /// @return true if a keyboard is connected, false otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyboards
    public @NativeType("boolean") boolean hasKeyboard() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasKeyboard);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected keyboards.
    ///
    /// Note that this will include any device or virtual driver that includes
    /// keyboard functionality, including some mice, KVM switches, motherboard
    /// power buttons, etc. You should wait for input from a device before you
    /// consider it actively in use.
    ///
    /// @param count a pointer filled in with the number of keyboards returned, may
    /// be NULL.
    /// @return a 0 terminated array of keyboards instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyboardNameForID
    /// @see #hasKeyboard
    public @Pointer(comment="SDL_KeyboardID") @Unsigned IntPtr getKeyboards(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyboards);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of a keyboard.
    ///
    /// This function returns "" if the keyboard doesn't have a name.
    ///
    /// @param instance_id the keyboard instance ID.
    /// @return the name of the selected keyboard or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyboards
    public BytePtr getKeyboardNameForID(
        @NativeType("SDL_KeyboardID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyboardNameForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the window which currently has keyboard focus.
    ///
    /// @return the window with keyboard focus.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Window getKeyboardFocus() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyboardFocus);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a snapshot of the current state of the keyboard.
    ///
    /// The pointer returned is a pointer to an internal SDL array. It will be
    /// valid for the whole lifetime of the application and should not be freed by
    /// the caller.
    ///
    /// A array element with a value of true means that the key is pressed and a
    /// value of false means that it is not. Indexes into this array are obtained
    /// by using SDL_Scancode values.
    ///
    /// Use SDL_PumpEvents() to update the state array.
    ///
    /// This function gives you the current state after all events have been
    /// processed, so if a key or button has been pressed and released before you
    /// process events, then the pressed state will never show up in the
    /// SDL_GetKeyboardState() calls.
    ///
    /// Note: This function doesn't take into account whether shift has been
    /// pressed or not.
    ///
    /// @param numkeys if non-NULL, receives the length of the returned array.
    /// @return a pointer to an array of key states.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #pumpEvents
    /// @see #resetKeyboard
    public @Pointer(comment="boolean") BytePtr getKeyboardState(
        @Nullable IntPtr numkeys
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyboardState);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (numkeys != null ? numkeys.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear the state of the keyboard.
    ///
    /// This function will generate key up events for all pressed keys.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyboardState
    public void resetKeyboard() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResetKeyboard);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current key modifier state for the keyboard.
    ///
    /// @return an OR'd combination of the modifier keys for the keyboard. See
    /// SDL_Keymod for details.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyboardState
    /// @see #setModState
    public @EnumType(SDL_Keymod.class) int getModState() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetModState);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the current key modifier state for the keyboard.
    ///
    /// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
    /// modifier key states on your application. Simply pass your desired modifier
    /// states into `modstate`. This value may be a bitwise, OR'd combination of
    /// SDL_Keymod values.
    ///
    /// This does not change the keyboard state, only the key modifier flags that
    /// SDL reports.
    ///
    /// @param modstate the desired SDL_Keymod for the keyboard.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getModState
    public void setModState(
        @EnumType(SDL_Keymod.class) int modstate
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetModState);
        try {
            hFunction.invokeExact(
                modstate
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the key code corresponding to the given scancode according to the
    /// current keyboard layout.
    ///
    /// If you want to get the keycode as it would be delivered in key events,
    /// including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should
    /// pass `key_event` as true. Otherwise this function simply translates the
    /// scancode based on the given modifier state.
    ///
    /// @param scancode the desired SDL_Scancode to query.
    /// @param modstate the modifier state to use when translating the scancode to
    /// a keycode.
    /// @param key_event true if the keycode will be used in key events.
    /// @return the SDL_Keycode that corresponds to the given SDL_Scancode.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyName
    /// @see #getScancodeFromKey
    public @EnumType(SDL_Keycode.class) int getKeyFromScancode(
        @EnumType(SDL_Scancode.class) int scancode,
        @EnumType(SDL_Keymod.class) int modstate,
        @NativeType("boolean") boolean key_event
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyFromScancode);
        try {
            return (int) hFunction.invokeExact(
                scancode,
                modstate,
                key_event
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the scancode corresponding to the given key code according to the
    /// current keyboard layout.
    ///
    /// Note that there may be multiple scancode+modifier states that can generate
    /// this keycode, this will just return the first one found.
    ///
    /// @param key the desired SDL_Keycode to query.
    /// @param modstate a pointer to the modifier state that would be used when the
    /// scancode generates this key, may be NULL.
    /// @return the SDL_Scancode that corresponds to the given SDL_Keycode.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyFromScancode
    /// @see #getScancodeName
    public @EnumType(SDL_Scancode.class) int getScancodeFromKey(
        @EnumType(SDL_Keycode.class) int key,
        @Nullable @EnumType(SDL_Keymod.class) IntPtr modstate
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetScancodeFromKey);
        try {
            return (int) hFunction.invokeExact(
                key,
                (MemorySegment) (modstate != null ? modstate.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a human-readable name for a scancode.
    ///
    /// @param scancode the desired SDL_Scancode.
    /// @param name the name to use for the scancode, encoded as UTF-8. The string
    /// is not copied, so the pointer given to this function must stay
    /// valid while SDL is being used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getScancodeName
    public @NativeType("boolean") boolean setScancodeName(
        @EnumType(SDL_Scancode.class) int scancode,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetScancodeName);
        try {
            return (boolean) hFunction.invokeExact(
                scancode,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a human-readable name for a scancode.
    ///
    /// **Warning**: The returned name is by design not stable across platforms,
    /// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
    /// Windows" under Microsoft Windows, and some scancodes like
    /// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
    /// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
    /// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
    /// unsuitable for creating a stable cross-platform two-way mapping between
    /// strings and scancodes.
    ///
    /// @param scancode the desired SDL_Scancode to query.
    /// @return a pointer to the name for the scancode. If the scancode doesn't
    /// have a name this function returns an empty string ("").
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getScancodeFromKey
    /// @see #getScancodeFromName
    /// @see #setScancodeName
    public BytePtr getScancodeName(
        @EnumType(SDL_Scancode.class) int scancode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetScancodeName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                scancode
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a scancode from a human-readable name.
    ///
    /// @param name the human-readable scancode name.
    /// @return the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
    /// recognized; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyFromName
    /// @see #getScancodeFromKey
    /// @see #getScancodeName
    public @EnumType(SDL_Scancode.class) int getScancodeFromName(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetScancodeFromName);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a human-readable name for a key.
    ///
    /// If the key doesn't have a name, this function returns an empty string ("").
    ///
    /// Letters will be presented in their uppercase form, if applicable.
    ///
    /// @param key the desired SDL_Keycode to query.
    /// @return a UTF-8 encoded string of the key name.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyFromName
    /// @see #getKeyFromScancode
    /// @see #getScancodeFromKey
    public BytePtr getKeyName(
        @EnumType(SDL_Keycode.class) int key
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                key
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a key code from a human-readable name.
    ///
    /// @param name the human-readable key name.
    /// @return key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getKeyFromScancode
    /// @see #getKeyName
    /// @see #getScancodeFromName
    public @EnumType(SDL_Keycode.class) int getKeyFromName(
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetKeyFromName);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start accepting Unicode text input events in a window.
    ///
    /// This function will enable text input (SDL_EVENT_TEXT_INPUT and
    /// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this
    /// function paired with SDL_StopTextInput().
    ///
    /// Text input events are not received by default.
    ///
    /// On some platforms using this function shows the screen keyboard and/or
    /// activates an IME, which can prevent some key press events from being passed
    /// through.
    ///
    /// @param window the window to enable text input.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setTextInputArea
    /// @see #startTextInputWithProperties
    /// @see #stopTextInput
    /// @see #textInputActive
    public @NativeType("boolean") boolean startTextInput(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StartTextInput);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Start accepting Unicode text input events in a window, with properties
    /// describing the input.
    ///
    /// This function will enable text input (SDL_EVENT_TEXT_INPUT and
    /// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this
    /// function paired with SDL_StopTextInput().
    ///
    /// Text input events are not received by default.
    ///
    /// On some platforms using this function shows the screen keyboard and/or
    /// activates an IME, which can prevent some key press events from being passed
    /// through.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that
    /// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.
    /// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value
    /// that describes how text should be capitalized, defaults to
    /// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for
    /// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail
    /// addresses, usernames, and passwords.
    /// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion
    /// and auto correction, defaults to true.
    /// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text
    /// are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is
    /// "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME
    /// is "1".
    ///
    /// On Android you can directly specify the input type:
    ///
    /// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to
    /// use, overriding other properties. This is documented at
    /// https://developer.android.com/reference/android/text/InputType
    ///
    /// @param window the window to enable text input.
    /// @param props the properties to use.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setTextInputArea
    /// @see #startTextInput
    /// @see #stopTextInput
    /// @see #textInputActive
    public @NativeType("boolean") boolean startTextInputWithProperties(
        @Nullable SDL_Window window,
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StartTextInputWithProperties);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                props
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check whether or not Unicode text input events are enabled for a window.
    ///
    /// @param window the window to check.
    /// @return true if text input events are enabled else false.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #startTextInput
    public @NativeType("boolean") boolean textInputActive(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TextInputActive);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Stop receiving any text input events in a window.
    ///
    /// If SDL_StartTextInput() showed the screen keyboard, this function will hide
    /// it.
    ///
    /// @param window the window to disable text input.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #startTextInput
    public @NativeType("boolean") boolean stopTextInput(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StopTextInput);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Dismiss the composition window/IME without disabling the subsystem.
    ///
    /// @param window the window to affect.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #startTextInput
    /// @see #stopTextInput
    public @NativeType("boolean") boolean clearComposition(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClearComposition);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the area used to type Unicode text input.
    ///
    /// Native input methods may place a window with word suggestions near the
    /// cursor, without covering the text being entered.
    ///
    /// @param window the window for which to set the text input area.
    /// @param rect the SDL_Rect representing the text input area, in window
    /// coordinates, or NULL to clear it.
    /// @param cursor the offset of the current cursor location relative to
    /// `rect-&amp;gt;x`, in window coordinates.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextInputArea
    /// @see #startTextInput
    public @NativeType("boolean") boolean setTextInputArea(
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_Rect rect,
        int cursor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextInputArea);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                cursor
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the area used to type Unicode text input.
    ///
    /// This returns the values previously set by SDL_SetTextInputArea().
    ///
    /// @param window the window for which to query the text input area.
    /// @param rect a pointer to an SDL_Rect filled in with the text input area,
    /// may be NULL.
    /// @param cursor a pointer to the offset of the current cursor location
    /// relative to `rect-&amp;gt;x`, may be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setTextInputArea
    public @NativeType("boolean") boolean getTextInputArea(
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_Rect rect,
        @Nullable IntPtr cursor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextInputArea);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (cursor != null ? cursor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check whether the platform has screen keyboard support.
    ///
    /// @return true if the platform has some screen keyboard support or false if
    /// not.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #startTextInput
    /// @see #screenKeyboardShown
    public @NativeType("boolean") boolean hasScreenKeyboardSupport() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasScreenKeyboardSupport);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check whether the screen keyboard is shown for given window.
    ///
    /// @param window the window for which screen keyboard should be queried.
    /// @return true if screen keyboard is shown or false if not.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasScreenKeyboardSupport
    public @NativeType("boolean") boolean screenKeyboardShown(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ScreenKeyboardShown);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Dynamically load a shared object.
    ///
    /// @param sofile a system-dependent name of the object file.
    /// @return an opaque pointer to the object handle or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadFunction
    /// @see #unloadObject
    public SDL_SharedObject loadObject(
        @Nullable BytePtr sofile
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadObject);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (sofile != null ? sofile.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_SharedObject(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Look up the address of the named function in a shared object.
    ///
    /// This function pointer is no longer valid after calling SDL_UnloadObject().
    ///
    /// This function can only look up C function names. Other languages may have
    /// name mangling and intrinsic language support that varies from compiler to
    /// compiler.
    ///
    /// Make sure you declare your function pointers with the same calling
    /// convention as the actual library function. Your code will crash
    /// mysteriously if you do not do this.
    ///
    /// If the requested function doesn't exist, NULL is returned.
    ///
    /// @param handle a valid shared object handle returned by SDL_LoadObject().
    /// @param name the name of the function to look up.
    /// @return a pointer to the function or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadObject
    public @Pointer(comment="SDL_FunctionPointer") MemorySegment loadFunction(
        @Nullable SDL_SharedObject handle,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadFunction);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (handle != null ? handle.segment() : MemorySegment.NULL),
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unload a shared object from memory.
    ///
    /// Note that any pointers from this object looked up through
    /// SDL_LoadFunction() will no longer be valid.
    ///
    /// @param handle a valid shared object handle returned by SDL_LoadObject().
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadObject
    public void unloadObject(
        @Nullable SDL_SharedObject handle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnloadObject);
        try {
            hFunction.invokeExact(
                (MemorySegment) (handle != null ? handle.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Report the user's preferred locale.
    ///
    /// Returned language strings are in the format xx, where 'xx' is an ISO-639
    /// language specifier (such as "en" for English, "de" for German, etc).
    /// Country strings are in the format YY, where "YY" is an ISO-3166 country
    /// code (such as "US" for the United States, "CA" for Canada, etc). Country
    /// might be NULL if there's no specific guidance on them (so you might get {
    /// "en", "US" } for American English, but { "en", NULL } means "English
    /// language, generically"). Language strings are never NULL, except to
    /// terminate the array.
    ///
    /// Please note that not all of these strings are 2 characters; some are three
    /// or more.
    ///
    /// The returned list of locales are in the order of the user's preference. For
    /// example, a German citizen that is fluent in US English and knows enough
    /// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",
    /// "jp", NULL }. Someone from England might prefer British English (where
    /// "color" is spelled "colour", etc), but will settle for anything like it: {
    /// "en_GB", "en", NULL }.
    ///
    /// This function returns NULL on error, including when the platform does not
    /// supply this information at all.
    ///
    /// This might be a "slow" call that has to query the operating system. It's
    /// best to ask for this once and save the results. However, this list can
    /// change, usually because the user has changed a system preference outside of
    /// your program; SDL will send an SDL_EVENT_LOCALE_CHANGED event in this case,
    /// if possible, and you can call this function again to get an updated copy of
    /// preferred locales.
    ///
    /// @param count a pointer filled in with the number of locales returned, may
    /// be NULL.
    /// @return a NULL terminated array of locale pointers, or NULL on failure;
    /// call SDL_GetError() for more information. This is a single
    /// allocation that should be freed with SDL_free() when it is no
    /// longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public PointerPtr getPreferredLocales(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPreferredLocales);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the priority of all log categories.
    ///
    /// @param priority the SDL_LogPriority to assign.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #resetLogPriorities
    /// @see #setLogPriority
    public void setLogPriorities(
        @EnumType(SDL_LogPriority.class) int priority
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetLogPriorities);
        try {
            hFunction.invokeExact(
                priority
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the priority of a particular log category.
    ///
    /// @param category the category to assign a priority to.
    /// @param priority the SDL_LogPriority to assign.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getLogPriority
    /// @see #resetLogPriorities
    /// @see #setLogPriorities
    public void setLogPriority(
        int category,
        @EnumType(SDL_LogPriority.class) int priority
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetLogPriority);
        try {
            hFunction.invokeExact(
                category,
                priority
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the priority of a particular log category.
    ///
    /// @param category the category to query.
    /// @return the SDL_LogPriority for the requested category.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setLogPriority
    public @EnumType(SDL_LogPriority.class) int getLogPriority(
        int category
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetLogPriority);
        try {
            return (int) hFunction.invokeExact(
                category
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Reset all priorities to default.
    ///
    /// This is called by SDL_Quit().
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setLogPriorities
    /// @see #setLogPriority
    public void resetLogPriorities() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ResetLogPriorities);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the text prepended to log messages of a given priority.
    ///
    /// By default SDL_LOG_PRIORITY_INFO and below have no prefix, and
    /// SDL_LOG_PRIORITY_WARN and higher have a prefix showing their priority, e.g.
    /// "WARNING: ".
    ///
    /// @param priority the SDL_LogPriority to modify.
    /// @param prefix the prefix to use for that log priority, or NULL to use no
    /// prefix.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setLogPriorities
    /// @see #setLogPriority
    public @NativeType("boolean") boolean setLogPriorityPrefix(
        @EnumType(SDL_LogPriority.class) int priority,
        @Nullable BytePtr prefix
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetLogPriorityPrefix);
        try {
            return (boolean) hFunction.invokeExact(
                priority,
                (MemorySegment) (prefix != null ? prefix.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the default log output function.
    ///
    /// @return the default log output callback.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setLogOutputFunction
    /// @see #getLogOutputFunction
    public @Pointer(comment="SDL_LogOutputFunction") MemorySegment getDefaultLogOutputFunction() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDefaultLogOutputFunction);
        try {
            return (MemorySegment) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current log output function.
    ///
    /// @param callback an SDL_LogOutputFunction filled in with the current log
    /// callback.
    /// @param userdata a pointer filled in with the pointer that is passed to
    /// `callback`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDefaultLogOutputFunction
    /// @see #setLogOutputFunction
    public void getLogOutputFunction(
        @Nullable PointerPtr callback,
        @Nullable PointerPtr userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetLogOutputFunction);
        try {
            hFunction.invokeExact(
                (MemorySegment) (callback != null ? callback.segment() : MemorySegment.NULL),
                (MemorySegment) (userdata != null ? userdata.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Replace the default log output function with one of your own.
    ///
    /// @param callback an SDL_LogOutputFunction to call instead of the default.
    /// @param userdata a pointer that is passed to `callback`.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDefaultLogOutputFunction
    /// @see #getLogOutputFunction
    public void setLogOutputFunction(
        @Pointer(comment="SDL_LogOutputFunction") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetLogOutputFunction);
        try {
            hFunction.invokeExact(
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a modal message box.
    ///
    /// If your needs aren't complex, it might be easier to use
    /// SDL_ShowSimpleMessageBox.
    ///
    /// This function should be called on the thread that created the parent
    /// window, or on the main thread if the messagebox has no parent. It will
    /// block execution of that thread until the user clicks a button or closes the
    /// messagebox.
    ///
    /// This function may be called at any time, even before SDL_Init(). This makes
    /// it useful for reporting errors like a failure to create a renderer or
    /// OpenGL context.
    ///
    /// On X11, SDL rolls its own dialog box with X11 primitives instead of a
    /// formal toolkit like GTK+ or Qt.
    ///
    /// Note that if SDL_Init() would fail because there isn't any available video
    /// target, this function is likely to fail for the same reasons. If this is a
    /// concern, check the return value from this function and fall back to writing
    /// to stderr if you can.
    ///
    /// @param messageboxdata the SDL_MessageBoxData structure with title, text and
    /// other options.
    /// @param buttonid the pointer to which user id of hit button should be
    /// copied.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #showSimpleMessageBox
    public @NativeType("boolean") boolean showMessageBox(
        @Nullable @Pointer ISDL_MessageBoxData messageboxdata,
        @Nullable IntPtr buttonid
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowMessageBox);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (messageboxdata != null ? messageboxdata.segment() : MemorySegment.NULL),
                (MemorySegment) (buttonid != null ? buttonid.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Display a simple modal message box.
    ///
    /// If your needs aren't complex, this function is preferred over
    /// SDL_ShowMessageBox.
    ///
    /// `flags` may be any of the following:
    ///
    /// - `SDL_MESSAGEBOX_ERROR`: error dialog
    /// - `SDL_MESSAGEBOX_WARNING`: warning dialog
    /// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog
    ///
    /// This function should be called on the thread that created the parent
    /// window, or on the main thread if the messagebox has no parent. It will
    /// block execution of that thread until the user clicks a button or closes the
    /// messagebox.
    ///
    /// This function may be called at any time, even before SDL_Init(). This makes
    /// it useful for reporting errors like a failure to create a renderer or
    /// OpenGL context.
    ///
    /// On X11, SDL rolls its own dialog box with X11 primitives instead of a
    /// formal toolkit like GTK+ or Qt.
    ///
    /// Note that if SDL_Init() would fail because there isn't any available video
    /// target, this function is likely to fail for the same reasons. If this is a
    /// concern, check the return value from this function and fall back to writing
    /// to stderr if you can.
    ///
    /// @param flags an SDL_MessageBoxFlags value.
    /// @param title UTF-8 title text.
    /// @param message UTF-8 message text.
    /// @param window the parent window, or NULL for no parent.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #showMessageBox
    public @NativeType("boolean") boolean showSimpleMessageBox(
        @EnumType(SDL_MessageBoxFlags.class) int flags,
        @Nullable BytePtr title,
        @Nullable BytePtr message,
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowSimpleMessageBox);
        try {
            return (boolean) hFunction.invokeExact(
                flags,
                (MemorySegment) (title != null ? title.segment() : MemorySegment.NULL),
                (MemorySegment) (message != null ? message.segment() : MemorySegment.NULL),
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified
    /// window.
    ///
    /// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on
    /// its own. It is up to user code to do that.
    ///
    /// The returned handle can be casted directly to a NSView or UIView. To access
    /// the backing CAMetalLayer, call SDL_Metal_GetLayer().
    ///
    /// @param window the window.
    /// @return handle NSView or UIView.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #metal_DestroyView
    /// @see #metal_GetLayer
    public @Pointer(comment="SDL_MetalView") MemorySegment metal_CreateView(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_Metal_CreateView);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy an existing SDL_MetalView object.
    ///
    /// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was
    /// called after SDL_CreateWindow.
    ///
    /// @param view the SDL_MetalView object.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #metal_CreateView
    public void metal_DestroyView(
        @Pointer(comment="SDL_MetalView") MemorySegment view
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_Metal_DestroyView);
        try {
            hFunction.invokeExact(
                view
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a pointer to the backing CAMetalLayer for the given view.
    ///
    /// @param view the SDL_MetalView object.
    /// @return a pointer.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="void*") MemorySegment metal_GetLayer(
        @Pointer(comment="SDL_MetalView") MemorySegment view
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_Metal_GetLayer);
        try {
            return (MemorySegment) hFunction.invokeExact(
                view
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a URL/URI in the browser or other appropriate external application.
    ///
    /// Open a URL in a separate, system-provided application. How this works will
    /// vary wildly depending on the platform. This will likely launch what makes
    /// sense to handle a specific URL's protocol (a web browser for `http://`,
    /// etc), but it might also be able to launch file managers for directories and
    /// other things.
    ///
    /// What happens when you open a URL varies wildly as well: your game window
    /// may lose focus (and may or may not lose focus if your game was fullscreen
    /// or grabbing input at the time). On mobile devices, your app will likely
    /// move to the background or your process might be paused. Any given platform
    /// may or may not handle a given URL.
    ///
    /// If this is unimplemented (or simply unavailable) for a platform, this will
    /// fail with an error. A successful result does not mean the URL loaded, just
    /// that we launched _something_ to handle it (or at least believe we did).
    ///
    /// All this to say: this function can be useful, but you should definitely
    /// test it on every platform you target.
    ///
    /// @param url a valid URL/URI to open. Use `file:///full/path/to/file` for
    /// local files, if supported.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean openURL(
        @Nullable BytePtr url
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenURL);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (url != null ? url.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a mouse is currently connected.
    ///
    /// @return true if a mouse is connected, false otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMice
    public @NativeType("boolean") boolean hasMouse() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasMouse);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected mice.
    ///
    /// Note that this will include any device or virtual driver that includes
    /// mouse functionality, including some game controllers, KVM switches, etc.
    /// You should wait for input from a device before you consider it actively in
    /// use.
    ///
    /// @param count a pointer filled in with the number of mice returned, may be
    /// NULL.
    /// @return a 0 terminated array of mouse instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMouseNameForID
    /// @see #hasMouse
    public @Pointer(comment="SDL_MouseID") @Unsigned IntPtr getMice(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMice);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of a mouse.
    ///
    /// This function returns "" if the mouse doesn't have a name.
    ///
    /// @param instance_id the mouse instance ID.
    /// @return the name of the selected mouse, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMice
    public BytePtr getMouseNameForID(
        @NativeType("SDL_MouseID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMouseNameForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the window which currently has mouse focus.
    ///
    /// @return the window with mouse focus.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Window getMouseFocus() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMouseFocus);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query SDL's cache for the synchronous mouse button state and the
    /// window-relative SDL-cursor position.
    ///
    /// This function returns the cached synchronous state as SDL understands it
    /// from the last pump of the event queue.
    ///
    /// To query the platform for immediate asynchronous state, use
    /// SDL_GetGlobalMouseState.
    ///
    /// Passing non-NULL pointers to `x` or `y` will write the destination with
    /// respective x or y coordinates relative to the focused window.
    ///
    /// In Relative Mode, the SDL-cursor's position usually contradicts the
    /// platform-cursor's position as manually calculated from
    /// SDL_GetGlobalMouseState() and SDL_GetWindowPosition.
    ///
    /// @param x a pointer to receive the SDL-cursor's x-position from the focused
    /// window's top left corner, can be NULL if unused.
    /// @param y a pointer to receive the SDL-cursor's y-position from the focused
    /// window's top left corner, can be NULL if unused.
    /// @return a 32-bit bitmask of the button state that can be bitwise-compared
    /// against the SDL_BUTTON_MASK(X) macro.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGlobalMouseState
    /// @see #getRelativeMouseState
    public @EnumType(SDL_MouseButtonFlags.class) int getMouseState(
        @Nullable FloatPtr x,
        @Nullable FloatPtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMouseState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (x != null ? x.segment() : MemorySegment.NULL),
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the platform for the asynchronous mouse button state and the
    /// desktop-relative platform-cursor position.
    ///
    /// This function immediately queries the platform for the most recent
    /// asynchronous state, more costly than retrieving SDL's cached state in
    /// SDL_GetMouseState().
    ///
    /// Passing non-NULL pointers to `x` or `y` will write the destination with
    /// respective x or y coordinates relative to the desktop.
    ///
    /// In Relative Mode, the platform-cursor's position usually contradicts the
    /// SDL-cursor's position as manually calculated from SDL_GetMouseState() and
    /// SDL_GetWindowPosition.
    ///
    /// This function can be useful if you need to track the mouse outside of a
    /// specific window and SDL_CaptureMouse() doesn't fit your needs. For example,
    /// it could be useful if you need to track the mouse while dragging a window,
    /// where coordinates relative to a window might not be in sync at all times.
    ///
    /// @param x a pointer to receive the platform-cursor's x-position from the
    /// desktop's top left corner, can be NULL if unused.
    /// @param y a pointer to receive the platform-cursor's y-position from the
    /// desktop's top left corner, can be NULL if unused.
    /// @return a 32-bit bitmask of the button state that can be bitwise-compared
    /// against the SDL_BUTTON_MASK(X) macro.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #captureMouse
    /// @see #getMouseState
    /// @see #getGlobalMouseState
    public @EnumType(SDL_MouseButtonFlags.class) int getGlobalMouseState(
        @Nullable FloatPtr x,
        @Nullable FloatPtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGlobalMouseState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (x != null ? x.segment() : MemorySegment.NULL),
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query SDL's cache for the synchronous mouse button state and accumulated
    /// mouse delta since last call.
    ///
    /// This function returns the cached synchronous state as SDL understands it
    /// from the last pump of the event queue.
    ///
    /// To query the platform for immediate asynchronous state, use
    /// SDL_GetGlobalMouseState.
    ///
    /// Passing non-NULL pointers to `x` or `y` will write the destination with
    /// respective x or y deltas accumulated since the last call to this function
    /// (or since event initialization).
    ///
    /// This function is useful for reducing overhead by processing relative mouse
    /// inputs in one go per-frame instead of individually per-event, at the
    /// expense of losing the order between events within the frame (e.g. quickly
    /// pressing and releasing a button within the same frame).
    ///
    /// @param x a pointer to receive the x mouse delta accumulated since last
    /// call, can be NULL if unused.
    /// @param y a pointer to receive the y mouse delta accumulated since last
    /// call, can be NULL if unused.
    /// @return a 32-bit bitmask of the button state that can be bitwise-compared
    /// against the SDL_BUTTON_MASK(X) macro.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMouseState
    /// @see #getGlobalMouseState
    public @EnumType(SDL_MouseButtonFlags.class) int getRelativeMouseState(
        @Nullable FloatPtr x,
        @Nullable FloatPtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRelativeMouseState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (x != null ? x.segment() : MemorySegment.NULL),
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Move the mouse cursor to the given position within the window.
    ///
    /// This function generates a mouse motion event if relative mode is not
    /// enabled. If relative mode is enabled, you can force mouse events for the
    /// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.
    ///
    /// Note that this function will appear to succeed, but not actually move the
    /// mouse when used over Microsoft Remote Desktop.
    ///
    /// @param window the window to move the mouse into, or NULL for the current
    /// mouse focus.
    /// @param x the x coordinate within the window.
    /// @param y the y coordinate within the window.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #warpMouseGlobal
    public void warpMouseInWindow(
        @Nullable SDL_Window window,
        float x,
        float y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WarpMouseInWindow);
        try {
            hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Move the mouse to the given position in global screen space.
    ///
    /// This function generates a mouse motion event.
    ///
    /// A failure of this function usually means that it is unsupported by a
    /// platform.
    ///
    /// Note that this function will appear to succeed, but not actually move the
    /// mouse when used over Microsoft Remote Desktop.
    ///
    /// @param x the x coordinate.
    /// @param y the y coordinate.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #warpMouseInWindow
    public @NativeType("boolean") boolean warpMouseGlobal(
        float x,
        float y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WarpMouseGlobal);
        try {
            return (boolean) hFunction.invokeExact(
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set relative mouse mode for a window.
    ///
    /// While the window has focus and relative mouse mode is enabled, the cursor
    /// is hidden, the mouse position is constrained to the window, and SDL will
    /// report continuous relative mouse motion even if the mouse is at the edge of
    /// the window.
    ///
    /// If you'd like to keep the mouse position fixed while in relative mode you
    /// can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a
    /// specific location when relative mode ends, you should use
    /// SDL_WarpMouseInWindow() before disabling relative mode.
    ///
    /// This function will flush any pending mouse motion for this window.
    ///
    /// @param window the window to change.
    /// @param enabled true to enable relative mode, false to disable.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowRelativeMouseMode
    public @NativeType("boolean") boolean setWindowRelativeMouseMode(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowRelativeMouseMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query whether relative mouse mode is enabled for a window.
    ///
    /// @param window the window to query.
    /// @return true if relative mode is enabled for a window or false otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowRelativeMouseMode
    public @NativeType("boolean") boolean getWindowRelativeMouseMode(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowRelativeMouseMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Capture the mouse and to track input outside an SDL window.
    ///
    /// Capturing enables your app to obtain mouse events globally, instead of just
    /// within your window. Not all video targets support this function. When
    /// capturing is enabled, the current window will get all mouse events, but
    /// unlike relative mode, no change is made to the cursor and it is not
    /// restrained to your window.
    ///
    /// This function may also deny mouse input to other windows--both those in
    /// your application and others on the system--so you should use this function
    /// sparingly, and in small bursts. For example, you might want to track the
    /// mouse while the user is dragging something, until the user releases a mouse
    /// button. It is not recommended that you capture the mouse for long periods
    /// of time, such as the entire time your app is running. For that, you should
    /// probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),
    /// depending on your goals.
    ///
    /// While captured, mouse events still report coordinates relative to the
    /// current (foreground) window, but those coordinates may be outside the
    /// bounds of the window (including negative values). Capturing is only allowed
    /// for the foreground window. If the window loses focus while capturing, the
    /// capture will be disabled automatically.
    ///
    /// While capturing is enabled, the current window will have the
    /// `SDL_WINDOW_MOUSE_CAPTURE` flag set.
    ///
    /// Please note that SDL will attempt to "auto capture" the mouse while the
    /// user is pressing a button; this is to try and make mouse behavior more
    /// consistent between platforms, and deal with the common case of a user
    /// dragging the mouse outside of the window. This means that if you are
    /// calling SDL_CaptureMouse() only to deal with this situation, you do not
    /// have to (although it is safe to do so). If this causes problems for your
    /// app, you can disable auto capture by setting the
    /// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.
    ///
    /// @param enabled true to enable capturing, false to disable.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getGlobalMouseState
    public @NativeType("boolean") boolean captureMouse(
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CaptureMouse);
        try {
            return (boolean) hFunction.invokeExact(
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a cursor using the specified bitmap data and mask (in MSB format).
    ///
    /// `mask` has to be in MSB (Most Significant Bit) format.
    ///
    /// The cursor width (`w`) must be a multiple of 8 bits.
    ///
    /// The cursor is created in black and white according to the following:
    ///
    /// - data=0, mask=1: white
    /// - data=1, mask=1: black
    /// - data=0, mask=0: transparent
    /// - data=1, mask=0: inverted color if possible, black if not.
    ///
    /// Cursors created with this function must be freed with SDL_DestroyCursor().
    ///
    /// If you want to have a color cursor, or create your cursor from an
    /// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
    /// hide the cursor and draw your own as part of your game's rendering, but it
    /// will be bound to the framerate.
    ///
    /// Also, SDL_CreateSystemCursor() is available, which provides several
    /// readily-available system cursors to pick from.
    ///
    /// @param data the color value for each pixel of the cursor.
    /// @param mask the mask value for each pixel of the cursor.
    /// @param w the width of the cursor.
    /// @param h the height of the cursor.
    /// @param hot_x the x-axis offset from the left of the cursor image to the
    /// mouse x position, in the range of 0 to `w` - 1.
    /// @param hot_y the y-axis offset from the top of the cursor image to the
    /// mouse y position, in the range of 0 to `h` - 1.
    /// @return a new cursor with the specified parameters on success or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createColorCursor
    /// @see #createSystemCursor
    /// @see #destroyCursor
    /// @see #setCursor
    public SDL_Cursor createCursor(
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr data,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr mask,
        int w,
        int h,
        int hot_x,
        int hot_y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateCursor);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                (MemorySegment) (mask != null ? mask.segment() : MemorySegment.NULL),
                w,
                h,
                hot_x,
                hot_y
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Cursor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a color cursor.
    ///
    /// If this function is passed a surface with alternate representations, the
    /// surface will be interpreted as the content to be used for 100% display
    /// scale, and the alternate representations will be used for high DPI
    /// situations. For example, if the original surface is 32x32, then on a 2x
    /// macOS display or 200% display scale on Windows, a 64x64 version of the
    /// image will be used, if available. If a matching version of the image isn't
    /// available, the closest larger size image will be downscaled to the
    /// appropriate size and be used instead, if available. Otherwise, the closest
    /// smaller image will be upscaled and be used instead.
    ///
    /// @param surface an SDL_Surface structure representing the cursor image.
    /// @param hot_x the x position of the cursor hot spot.
    /// @param hot_y the y position of the cursor hot spot.
    /// @return the new cursor on success or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createCursor
    /// @see #createSystemCursor
    /// @see #destroyCursor
    /// @see #setCursor
    public SDL_Cursor createColorCursor(
        @Nullable SDL_Surface surface,
        int hot_x,
        int hot_y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateColorCursor);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                hot_x,
                hot_y
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Cursor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a system cursor.
    ///
    /// @param id an SDL_SystemCursor enum value.
    /// @return a cursor on success or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyCursor
    public SDL_Cursor createSystemCursor(
        @EnumType(SDL_SystemCursor.class) int id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateSystemCursor);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Cursor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the active cursor.
    ///
    /// This function sets the currently active cursor to the specified one. If the
    /// cursor is currently visible, the change will be immediately represented on
    /// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
    /// this is desired for any reason.
    ///
    /// @param cursor a cursor to make active.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCursor
    public @NativeType("boolean") boolean setCursor(
        @Nullable SDL_Cursor cursor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetCursor);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (cursor != null ? cursor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the active cursor.
    ///
    /// This function returns a pointer to the current cursor which is owned by the
    /// library. It is not necessary to free the cursor with SDL_DestroyCursor().
    ///
    /// @return the active cursor or NULL if there is no mouse.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setCursor
    public SDL_Cursor getCursor() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCursor);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Cursor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the default cursor.
    ///
    /// You do not have to call SDL_DestroyCursor() on the return value, but it is
    /// safe to do so.
    ///
    /// @return the default cursor on success or NULL on failuree; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Cursor getDefaultCursor() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDefaultCursor);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Cursor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free a previously-created cursor.
    ///
    /// Use this function to free cursor resources created with SDL_CreateCursor(),
    /// SDL_CreateColorCursor() or SDL_CreateSystemCursor().
    ///
    /// @param cursor the cursor to free.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createColorCursor
    /// @see #createCursor
    /// @see #createSystemCursor
    public void destroyCursor(
        @Nullable SDL_Cursor cursor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyCursor);
        try {
            hFunction.invokeExact(
                (MemorySegment) (cursor != null ? cursor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Show the cursor.
    ///
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #cursorVisible
    /// @see #hideCursor
    public @NativeType("boolean") boolean showCursor() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowCursor);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Hide the cursor.
    ///
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #cursorVisible
    /// @see #showCursor
    public @NativeType("boolean") boolean hideCursor() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HideCursor);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether the cursor is currently being shown.
    ///
    /// @return `true` if the cursor is being shown, or `false` if the cursor is
    /// hidden.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hideCursor
    /// @see #showCursor
    public @NativeType("boolean") boolean cursorVisible() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CursorVisible);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new mutex.
    ///
    /// All newly-created mutexes begin in the _unlocked_ state.
    ///
    /// Calls to SDL_LockMutex() will not return while the mutex is locked by
    /// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
    ///
    /// SDL mutexes are reentrant.
    ///
    /// @return the initialized and unlocked mutex or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyMutex
    /// @see #lockMutex
    /// @see #tryLockMutex
    /// @see #unlockMutex
    public SDL_Mutex createMutex() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateMutex);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Mutex(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock the mutex.
    ///
    /// This will block until the mutex is available, which is to say it is in the
    /// unlocked state and the OS has chosen the caller as the next thread to lock
    /// it. Of all threads waiting to lock the mutex, only one may do so at a time.
    ///
    /// It is legal for the owning thread to lock an already-locked mutex. It must
    /// unlock it the same number of times before it is actually made available for
    /// other threads in the system (this is known as a "recursive mutex").
    ///
    /// This function does not fail; if mutex is NULL, it will return immediately
    /// having locked nothing. If the mutex is valid, this function will always
    /// block until it can lock the mutex, and return with it locked.
    ///
    /// @param mutex the mutex to lock.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #tryLockMutex
    /// @see #unlockMutex
    public void lockMutex(
        @Nullable SDL_Mutex mutex
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockMutex);
        try {
            hFunction.invokeExact(
                (MemorySegment) (mutex != null ? mutex.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Try to lock a mutex without blocking.
    ///
    /// This works just like SDL_LockMutex(), but if the mutex is not available,
    /// this function returns false immediately.
    ///
    /// This technique is useful if you need exclusive access to a resource but
    /// don't want to wait for it, and will return to it to try again later.
    ///
    /// This function returns true if passed a NULL mutex.
    ///
    /// @param mutex the mutex to try to lock.
    /// @return true on success, false if the mutex would block.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockMutex
    /// @see #unlockMutex
    public @NativeType("boolean") boolean tryLockMutex(
        @Nullable SDL_Mutex mutex
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TryLockMutex);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (mutex != null ? mutex.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlock the mutex.
    ///
    /// It is legal for the owning thread to lock an already-locked mutex. It must
    /// unlock it the same number of times before it is actually made available for
    /// other threads in the system (this is known as a "recursive mutex").
    ///
    /// It is illegal to unlock a mutex that has not been locked by the current
    /// thread, and doing so results in undefined behavior.
    ///
    /// @param mutex the mutex to unlock.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockMutex
    /// @see #tryLockMutex
    public void unlockMutex(
        @Nullable SDL_Mutex mutex
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockMutex);
        try {
            hFunction.invokeExact(
                (MemorySegment) (mutex != null ? mutex.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a mutex created with SDL_CreateMutex().
    ///
    /// This function must be called on any mutex that is no longer needed. Failure
    /// to destroy a mutex will result in a system memory or resource leak. While
    /// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
    /// to destroy a locked mutex, and may result in undefined behavior depending
    /// on the platform.
    ///
    /// @param mutex the mutex to destroy.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createMutex
    public void destroyMutex(
        @Nullable SDL_Mutex mutex
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyMutex);
        try {
            hFunction.invokeExact(
                (MemorySegment) (mutex != null ? mutex.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new read/write lock.
    ///
    /// A read/write lock is useful for situations where you have multiple threads
    /// trying to access a resource that is rarely updated. All threads requesting
    /// a read-only lock will be allowed to run in parallel; if a thread requests a
    /// write lock, it will be provided exclusive access. This makes it safe for
    /// multiple threads to use a resource at the same time if they promise not to
    /// change it, and when it has to be changed, the rwlock will serve as a
    /// gateway to make sure those changes can be made safely.
    ///
    /// In the right situation, a rwlock can be more efficient than a mutex, which
    /// only lets a single thread proceed at a time, even if it won't be modifying
    /// the data.
    ///
    /// All newly-created read/write locks begin in the _unlocked_ state.
    ///
    /// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not
    /// return while the rwlock is locked _for writing_ by another thread. See
    /// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt
    /// to lock without blocking.
    ///
    /// SDL read/write locks are only recursive for read-only locks! They are not
    /// guaranteed to be fair, or provide access in a FIFO manner! They are not
    /// guaranteed to favor writers. You may not lock a rwlock for both read-only
    /// and write access at the same time from the same thread (so you can't
    /// promote your read-only lock to a write lock without unlocking first).
    ///
    /// @return the initialized and unlocked read/write lock or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyRWLock
    /// @see #lockRWLockForReading
    /// @see #lockRWLockForWriting
    /// @see #tryLockRWLockForReading
    /// @see #tryLockRWLockForWriting
    /// @see #unlockRWLock
    public SDL_RWLock createRWLock() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateRWLock);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_RWLock(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock the read/write lock for _read only_ operations.
    ///
    /// This will block until the rwlock is available, which is to say it is not
    /// locked for writing by any other thread. Of all threads waiting to lock the
    /// rwlock, all may do so at the same time as long as they are requesting
    /// read-only access; if a thread wants to lock for writing, only one may do so
    /// at a time, and no other threads, read-only or not, may hold the lock at the
    /// same time.
    ///
    /// It is legal for the owning thread to lock an already-locked rwlock for
    /// reading. It must unlock it the same number of times before it is actually
    /// made available for other threads in the system (this is known as a
    /// "recursive rwlock").
    ///
    /// Note that locking for writing is not recursive (this is only available to
    /// read-only locks).
    ///
    /// It is illegal to request a read-only lock from a thread that already holds
    /// the write lock. Doing so results in undefined behavior. Unlock the write
    /// lock before requesting a read-only lock. (But, of course, if you have the
    /// write lock, you don't need further locks to read in any case.)
    ///
    /// This function does not fail; if rwlock is NULL, it will return immediately
    /// having locked nothing. If the rwlock is valid, this function will always
    /// block until it can lock the mutex, and return with it locked.
    ///
    /// @param rwlock the read/write lock to lock.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockRWLockForWriting
    /// @see #tryLockRWLockForReading
    /// @see #unlockRWLock
    public void lockRWLockForReading(
        @Nullable SDL_RWLock rwlock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockRWLockForReading);
        try {
            hFunction.invokeExact(
                (MemorySegment) (rwlock != null ? rwlock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock the read/write lock for _write_ operations.
    ///
    /// This will block until the rwlock is available, which is to say it is not
    /// locked for reading or writing by any other thread. Only one thread may hold
    /// the lock when it requests write access; all other threads, whether they
    /// also want to write or only want read-only access, must wait until the
    /// writer thread has released the lock.
    ///
    /// It is illegal for the owning thread to lock an already-locked rwlock for
    /// writing (read-only may be locked recursively, writing can not). Doing so
    /// results in undefined behavior.
    ///
    /// It is illegal to request a write lock from a thread that already holds a
    /// read-only lock. Doing so results in undefined behavior. Unlock the
    /// read-only lock before requesting a write lock.
    ///
    /// This function does not fail; if rwlock is NULL, it will return immediately
    /// having locked nothing. If the rwlock is valid, this function will always
    /// block until it can lock the mutex, and return with it locked.
    ///
    /// @param rwlock the read/write lock to lock.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockRWLockForReading
    /// @see #tryLockRWLockForWriting
    /// @see #unlockRWLock
    public void lockRWLockForWriting(
        @Nullable SDL_RWLock rwlock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockRWLockForWriting);
        try {
            hFunction.invokeExact(
                (MemorySegment) (rwlock != null ? rwlock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Try to lock a read/write lock _for reading_ without blocking.
    ///
    /// This works just like SDL_LockRWLockForReading(), but if the rwlock is not
    /// available, then this function returns false immediately.
    ///
    /// This technique is useful if you need access to a resource but don't want to
    /// wait for it, and will return to it to try again later.
    ///
    /// Trying to lock for read-only access can succeed if other threads are
    /// holding read-only locks, as this won't prevent access.
    ///
    /// This function returns true if passed a NULL rwlock.
    ///
    /// @param rwlock the rwlock to try to lock.
    /// @return true on success, false if the lock would block.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockRWLockForReading
    /// @see #tryLockRWLockForWriting
    /// @see #unlockRWLock
    public @NativeType("boolean") boolean tryLockRWLockForReading(
        @Nullable SDL_RWLock rwlock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TryLockRWLockForReading);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (rwlock != null ? rwlock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Try to lock a read/write lock _for writing_ without blocking.
    ///
    /// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not
    /// available, then this function returns false immediately.
    ///
    /// This technique is useful if you need exclusive access to a resource but
    /// don't want to wait for it, and will return to it to try again later.
    ///
    /// It is illegal for the owning thread to lock an already-locked rwlock for
    /// writing (read-only may be locked recursively, writing can not). Doing so
    /// results in undefined behavior.
    ///
    /// It is illegal to request a write lock from a thread that already holds a
    /// read-only lock. Doing so results in undefined behavior. Unlock the
    /// read-only lock before requesting a write lock.
    ///
    /// This function returns true if passed a NULL rwlock.
    ///
    /// @param rwlock the rwlock to try to lock.
    /// @return true on success, false if the lock would block.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockRWLockForWriting
    /// @see #tryLockRWLockForReading
    /// @see #unlockRWLock
    public @NativeType("boolean") boolean tryLockRWLockForWriting(
        @Nullable SDL_RWLock rwlock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TryLockRWLockForWriting);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (rwlock != null ? rwlock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlock the read/write lock.
    ///
    /// Use this function to unlock the rwlock, whether it was locked for read-only
    /// or write operations.
    ///
    /// It is legal for the owning thread to lock an already-locked read-only lock.
    /// It must unlock it the same number of times before it is actually made
    /// available for other threads in the system (this is known as a "recursive
    /// rwlock").
    ///
    /// It is illegal to unlock a rwlock that has not been locked by the current
    /// thread, and doing so results in undefined behavior.
    ///
    /// @param rwlock the rwlock to unlock.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockRWLockForReading
    /// @see #lockRWLockForWriting
    /// @see #tryLockRWLockForReading
    /// @see #tryLockRWLockForWriting
    public void unlockRWLock(
        @Nullable SDL_RWLock rwlock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockRWLock);
        try {
            hFunction.invokeExact(
                (MemorySegment) (rwlock != null ? rwlock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a read/write lock created with SDL_CreateRWLock().
    ///
    /// This function must be called on any read/write lock that is no longer
    /// needed. Failure to destroy a rwlock will result in a system memory or
    /// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it
    /// is not safe to attempt to destroy a locked rwlock, and may result in
    /// undefined behavior depending on the platform.
    ///
    /// @param rwlock the rwlock to destroy.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRWLock
    public void destroyRWLock(
        @Nullable SDL_RWLock rwlock
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyRWLock);
        try {
            hFunction.invokeExact(
                (MemorySegment) (rwlock != null ? rwlock.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a semaphore.
    ///
    /// This function creates a new semaphore and initializes it with the value
    /// `initial_value`. Each wait operation on the semaphore will atomically
    /// decrement the semaphore value and potentially block if the semaphore value
    /// is 0. Each post operation will atomically increment the semaphore value and
    /// wake waiting threads and allow them to retry the wait operation.
    ///
    /// @param initial_value the starting value of the semaphore.
    /// @return a new semaphore or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroySemaphore
    /// @see #signalSemaphore
    /// @see #tryWaitSemaphore
    /// @see #getSemaphoreValue
    /// @see #waitSemaphore
    /// @see #waitSemaphoreTimeout
    public SDL_Semaphore createSemaphore(
        @NativeType("Uint32") @Unsigned int initial_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateSemaphore);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                initial_value
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Semaphore(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a semaphore.
    ///
    /// It is not safe to destroy a semaphore if there are threads currently
    /// waiting on it.
    ///
    /// @param sem the semaphore to destroy.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createSemaphore
    public void destroySemaphore(
        @Nullable SDL_Semaphore sem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroySemaphore);
        try {
            hFunction.invokeExact(
                (MemorySegment) (sem != null ? sem.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait until a semaphore has a positive value and then decrements it.
    ///
    /// This function suspends the calling thread until the semaphore pointed to by
    /// `sem` has a positive value, and then atomically decrement the semaphore
    /// value.
    ///
    /// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with
    /// a time length of -1.
    ///
    /// @param sem the semaphore wait on.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #signalSemaphore
    /// @see #tryWaitSemaphore
    /// @see #waitSemaphoreTimeout
    public void waitSemaphore(
        @Nullable SDL_Semaphore sem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitSemaphore);
        try {
            hFunction.invokeExact(
                (MemorySegment) (sem != null ? sem.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// See if a semaphore has a positive value and decrement it if it does.
    ///
    /// This function checks to see if the semaphore pointed to by `sem` has a
    /// positive value and atomically decrements the semaphore value if it does. If
    /// the semaphore doesn't have a positive value, the function immediately
    /// returns false.
    ///
    /// @param sem the semaphore to wait on.
    /// @return true if the wait succeeds, false if the wait would block.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #signalSemaphore
    /// @see #waitSemaphore
    /// @see #waitSemaphoreTimeout
    public @NativeType("boolean") boolean tryWaitSemaphore(
        @Nullable SDL_Semaphore sem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TryWaitSemaphore);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (sem != null ? sem.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait until a semaphore has a positive value and then decrements it.
    ///
    /// This function suspends the calling thread until either the semaphore
    /// pointed to by `sem` has a positive value or the specified time has elapsed.
    /// If the call is successful it will atomically decrement the semaphore value.
    ///
    /// @param sem the semaphore to wait on.
    /// @param timeoutMS the length of the timeout, in milliseconds, or -1 to wait
    /// indefinitely.
    /// @return true if the wait succeeds or false if the wait times out.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #signalSemaphore
    /// @see #tryWaitSemaphore
    /// @see #waitSemaphore
    public @NativeType("boolean") boolean waitSemaphoreTimeout(
        @Nullable SDL_Semaphore sem,
        @NativeType("Sint32") int timeoutMS
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitSemaphoreTimeout);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (sem != null ? sem.segment() : MemorySegment.NULL),
                timeoutMS
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Atomically increment a semaphore's value and wake waiting threads.
    ///
    /// @param sem the semaphore to increment.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #tryWaitSemaphore
    /// @see #waitSemaphore
    /// @see #waitSemaphoreTimeout
    public void signalSemaphore(
        @Nullable SDL_Semaphore sem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SignalSemaphore);
        try {
            hFunction.invokeExact(
                (MemorySegment) (sem != null ? sem.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current value of a semaphore.
    ///
    /// @param sem the semaphore to query.
    /// @return the current value of the semaphore.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint32") @Unsigned int getSemaphoreValue(
        @Nullable SDL_Semaphore sem
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSemaphoreValue);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (sem != null ? sem.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a condition variable.
    ///
    /// @return a new condition variable or NULL on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #broadcastCondition
    /// @see #signalCondition
    /// @see #waitCondition
    /// @see #waitConditionTimeout
    /// @see #destroyCondition
    public SDL_Condition createCondition() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateCondition);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Condition(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a condition variable.
    ///
    /// @param cond the condition variable to destroy.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createCondition
    public void destroyCondition(
        @Nullable SDL_Condition cond
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyCondition);
        try {
            hFunction.invokeExact(
                (MemorySegment) (cond != null ? cond.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Restart one of the threads that are waiting on the condition variable.
    ///
    /// @param cond the condition variable to signal.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #broadcastCondition
    /// @see #waitCondition
    /// @see #waitConditionTimeout
    public void signalCondition(
        @Nullable SDL_Condition cond
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SignalCondition);
        try {
            hFunction.invokeExact(
                (MemorySegment) (cond != null ? cond.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Restart all threads that are waiting on the condition variable.
    ///
    /// @param cond the condition variable to signal.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #signalCondition
    /// @see #waitCondition
    /// @see #waitConditionTimeout
    public void broadcastCondition(
        @Nullable SDL_Condition cond
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BroadcastCondition);
        try {
            hFunction.invokeExact(
                (MemorySegment) (cond != null ? cond.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait until a condition variable is signaled.
    ///
    /// This function unlocks the specified `mutex` and waits for another thread to
    /// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition
    /// variable `cond`. Once the condition variable is signaled, the mutex is
    /// re-locked and the function returns.
    ///
    /// The mutex must be locked before calling this function. Locking the mutex
    /// recursively (more than once) is not supported and leads to undefined
    /// behavior.
    ///
    /// This function is the equivalent of calling SDL_WaitConditionTimeout() with
    /// a time length of -1.
    ///
    /// @param cond the condition variable to wait on.
    /// @param mutex the mutex used to coordinate thread access.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #broadcastCondition
    /// @see #signalCondition
    /// @see #waitConditionTimeout
    public void waitCondition(
        @Nullable SDL_Condition cond,
        @Nullable SDL_Mutex mutex
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitCondition);
        try {
            hFunction.invokeExact(
                (MemorySegment) (cond != null ? cond.segment() : MemorySegment.NULL),
                (MemorySegment) (mutex != null ? mutex.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait until a condition variable is signaled or a certain time has passed.
    ///
    /// This function unlocks the specified `mutex` and waits for another thread to
    /// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition
    /// variable `cond`, or for the specified time to elapse. Once the condition
    /// variable is signaled or the time elapsed, the mutex is re-locked and the
    /// function returns.
    ///
    /// The mutex must be locked before calling this function. Locking the mutex
    /// recursively (more than once) is not supported and leads to undefined
    /// behavior.
    ///
    /// @param cond the condition variable to wait on.
    /// @param mutex the mutex used to coordinate thread access.
    /// @param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait
    /// indefinitely.
    /// @return true if the condition variable is signaled, false if the condition
    /// is not signaled in the allotted time.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #broadcastCondition
    /// @see #signalCondition
    /// @see #waitCondition
    public @NativeType("boolean") boolean waitConditionTimeout(
        @Nullable SDL_Condition cond,
        @Nullable SDL_Mutex mutex,
        @NativeType("Sint32") int timeoutMS
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitConditionTimeout);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (cond != null ? cond.segment() : MemorySegment.NULL),
                (MemorySegment) (mutex != null ? mutex.segment() : MemorySegment.NULL),
                timeoutMS
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether initialization should be done.
    ///
    /// This function checks the passed in state and if initialization should be
    /// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.
    /// If another thread is already modifying this state, it will wait until
    /// that's done before returning.
    ///
    /// If this function returns true, the calling code must call
    /// SDL_SetInitialized() to complete the initialization.
    ///
    /// @param state the initialization state to check.
    /// @return true if initialization needs to be done, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setInitialized
    /// @see #shouldQuit
    public @NativeType("boolean") boolean shouldInit(
        @Nullable @Pointer ISDL_InitState state
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShouldInit);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether cleanup should be done.
    ///
    /// This function checks the passed in state and if cleanup should be done,
    /// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.
    ///
    /// If this function returns true, the calling code must call
    /// SDL_SetInitialized() to complete the cleanup.
    ///
    /// @param state the initialization state to check.
    /// @return true if cleanup needs to be done, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setInitialized
    /// @see #shouldInit
    public @NativeType("boolean") boolean shouldQuit(
        @Nullable @Pointer ISDL_InitState state
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShouldQuit);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Finish an initialization state transition.
    ///
    /// This function sets the status of the passed in state to
    /// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows
    /// any threads waiting for the status to proceed.
    ///
    /// @param state the initialization state to check.
    /// @param initialized the new initialization state.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #shouldInit
    /// @see #shouldQuit
    public void setInitialized(
        @Nullable @Pointer ISDL_InitState state,
        @NativeType("boolean") boolean initialized
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetInitialized);
        try {
            hFunction.invokeExact(
                (MemorySegment) (state != null ? state.segment() : MemorySegment.NULL),
                initialized
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the human readable name of a pixel format.
    ///
    /// @param format the pixel format to query.
    /// @return the human readable name of the specified pixel format or
    /// "SDL_PIXELFORMAT_UNKNOWN" if the format isn't recognized.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getPixelFormatName(
        @EnumType(SDL_PixelFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPixelFormatName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                format
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
    ///
    /// @param format one of the SDL_PixelFormat values.
    /// @param bpp a bits per pixel value; usually 15, 16, or 32.
    /// @param Rmask a pointer filled in with the red mask for the format.
    /// @param Gmask a pointer filled in with the green mask for the format.
    /// @param Bmask a pointer filled in with the blue mask for the format.
    /// @param Amask a pointer filled in with the alpha mask for the format.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPixelFormatForMasks
    public @NativeType("boolean") boolean getMasksForPixelFormat(
        @EnumType(SDL_PixelFormat.class) int format,
        @Nullable IntPtr bpp,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr Rmask,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr Gmask,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr Bmask,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr Amask
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetMasksForPixelFormat);
        try {
            return (boolean) hFunction.invokeExact(
                format,
                (MemorySegment) (bpp != null ? bpp.segment() : MemorySegment.NULL),
                (MemorySegment) (Rmask != null ? Rmask.segment() : MemorySegment.NULL),
                (MemorySegment) (Gmask != null ? Gmask.segment() : MemorySegment.NULL),
                (MemorySegment) (Bmask != null ? Bmask.segment() : MemorySegment.NULL),
                (MemorySegment) (Amask != null ? Amask.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert a bpp value and RGBA masks to an enumerated pixel format.
    ///
    /// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
    /// possible.
    ///
    /// @param bpp a bits per pixel value; usually 15, 16, or 32.
    /// @param Rmask the red mask for the format.
    /// @param Gmask the green mask for the format.
    /// @param Bmask the blue mask for the format.
    /// @param Amask the alpha mask for the format.
    /// @return the SDL_PixelFormat value corresponding to the format masks, or
    /// SDL_PIXELFORMAT_UNKNOWN if there isn't a match.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getMasksForPixelFormat
    public @EnumType(SDL_PixelFormat.class) int getPixelFormatForMasks(
        int bpp,
        @NativeType("Uint32") @Unsigned int Rmask,
        @NativeType("Uint32") @Unsigned int Gmask,
        @NativeType("Uint32") @Unsigned int Bmask,
        @NativeType("Uint32") @Unsigned int Amask
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPixelFormatForMasks);
        try {
            return (int) hFunction.invokeExact(
                bpp,
                Rmask,
                Gmask,
                Bmask,
                Amask
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create an SDL_PixelFormatDetails structure corresponding to a pixel format.
    ///
    /// Returned structure may come from a shared global cache (i.e. not newly
    /// allocated), and hence should not be modified, especially the palette. Weird
    /// errors such as `Blit combination not supported` may occur.
    ///
    /// @param format one of the SDL_PixelFormat values.
    /// @return a pointer to a SDL_PixelFormatDetails structure or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer ISDL_PixelFormatDetails getPixelFormatDetails(
        @EnumType(SDL_PixelFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPixelFormatDetails);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                format
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_PixelFormatDetails(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a palette structure with the specified number of color entries.
    ///
    /// The palette entries are initialized to white.
    ///
    /// @param ncolors represents the number of color entries in the color palette.
    /// @return a new SDL_Palette structure on success or NULL on failure (e.g. if
    /// there wasn't enough memory); call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyPalette
    /// @see #setPaletteColors
    /// @see #setSurfacePalette
    public @Pointer ISDL_Palette createPalette(
        int ncolors
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreatePalette);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                ncolors
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Palette(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a range of colors in a palette.
    ///
    /// @param palette the SDL_Palette structure to modify.
    /// @param colors an array of SDL_Color structures to copy into the palette.
    /// @param firstcolor the index of the first palette entry to modify.
    /// @param ncolors the number of entries to modify.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the palette is not modified or destroyed in another thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setPaletteColors(
        @Nullable @Pointer ISDL_Palette palette,
        @Nullable @Pointer ISDL_Color colors,
        int firstcolor,
        int ncolors
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetPaletteColors);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL),
                (MemorySegment) (colors != null ? colors.segment() : MemorySegment.NULL),
                firstcolor,
                ncolors
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free a palette created with SDL_CreatePalette().
    ///
    /// @param palette the SDL_Palette structure to be freed.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the palette is not modified or destroyed in another thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createPalette
    public void destroyPalette(
        @Nullable @Pointer ISDL_Palette palette
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyPalette);
        try {
            hFunction.invokeExact(
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Map an RGB triple to an opaque pixel value for a given pixel format.
    ///
    /// This function maps the RGB color value to the specified pixel format and
    /// returns the pixel value best approximating the given RGB color value for
    /// the given pixel format.
    ///
    /// If the format has a palette (8-bit) the index of the closest matching color
    /// in the palette will be returned.
    ///
    /// If the specified pixel format has an alpha component it will be returned as
    /// all 1 bits (fully opaque).
    ///
    /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
    /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
    /// format the return value can be assigned to a Uint16, and similarly a Uint8
    /// for an 8-bpp format).
    ///
    /// @param format a pointer to SDL_PixelFormatDetails describing the pixel
    /// format.
    /// @param palette an optional palette for indexed formats, may be NULL.
    /// @param r the red component of the pixel in the range 0-255.
    /// @param g the green component of the pixel in the range 0-255.
    /// @param b the blue component of the pixel in the range 0-255.
    /// @return a pixel value.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the palette is not modified.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPixelFormatDetails
    /// @see #getRGB
    /// @see #mapRGBA
    /// @see #mapSurfaceRGB
    public @NativeType("Uint32") @Unsigned int mapRGB(
        @Nullable @Pointer ISDL_PixelFormatDetails format,
        @Nullable @Pointer ISDL_Palette palette,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MapRGB);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (format != null ? format.segment() : MemorySegment.NULL),
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL),
                r,
                g,
                b
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Map an RGBA quadruple to a pixel value for a given pixel format.
    ///
    /// This function maps the RGBA color value to the specified pixel format and
    /// returns the pixel value best approximating the given RGBA color value for
    /// the given pixel format.
    ///
    /// If the specified pixel format has no alpha component the alpha value will
    /// be ignored (as it will be in formats with a palette).
    ///
    /// If the format has a palette (8-bit) the index of the closest matching color
    /// in the palette will be returned.
    ///
    /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
    /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
    /// format the return value can be assigned to a Uint16, and similarly a Uint8
    /// for an 8-bpp format).
    ///
    /// @param format a pointer to SDL_PixelFormatDetails describing the pixel
    /// format.
    /// @param palette an optional palette for indexed formats, may be NULL.
    /// @param r the red component of the pixel in the range 0-255.
    /// @param g the green component of the pixel in the range 0-255.
    /// @param b the blue component of the pixel in the range 0-255.
    /// @param a the alpha component of the pixel in the range 0-255.
    /// @return a pixel value.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the palette is not modified.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPixelFormatDetails
    /// @see #getRGBA
    /// @see #mapRGB
    /// @see #mapSurfaceRGBA
    public @NativeType("Uint32") @Unsigned int mapRGBA(
        @Nullable @Pointer ISDL_PixelFormatDetails format,
        @Nullable @Pointer ISDL_Palette palette,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b,
        @NativeType("Uint8") @Unsigned byte a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MapRGBA);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (format != null ? format.segment() : MemorySegment.NULL),
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL),
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get RGB values from a pixel in the specified format.
    ///
    /// This function uses the entire 8-bit [0..255] range when converting color
    /// components from pixel formats with less than 8-bits per RGB component
    /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
    /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
    ///
    /// @param pixel a pixel value.
    /// @param format a pointer to SDL_PixelFormatDetails describing the pixel
    /// format.
    /// @param palette an optional palette for indexed formats, may be NULL.
    /// @param r a pointer filled in with the red component, may be NULL.
    /// @param g a pointer filled in with the green component, may be NULL.
    /// @param b a pointer filled in with the blue component, may be NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the palette is not modified.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPixelFormatDetails
    /// @see #getRGBA
    /// @see #mapRGB
    /// @see #mapRGBA
    public void getRGB(
        @NativeType("Uint32") @Unsigned int pixel,
        @Nullable @Pointer ISDL_PixelFormatDetails format,
        @Nullable @Pointer ISDL_Palette palette,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr r,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr g,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRGB);
        try {
            hFunction.invokeExact(
                pixel,
                (MemorySegment) (format != null ? format.segment() : MemorySegment.NULL),
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get RGBA values from a pixel in the specified format.
    ///
    /// This function uses the entire 8-bit [0..255] range when converting color
    /// components from pixel formats with less than 8-bits per RGB component
    /// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
    /// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
    ///
    /// If the surface has no alpha component, the alpha will be returned as 0xff
    /// (100% opaque).
    ///
    /// @param pixel a pixel value.
    /// @param format a pointer to SDL_PixelFormatDetails describing the pixel
    /// format.
    /// @param palette an optional palette for indexed formats, may be NULL.
    /// @param r a pointer filled in with the red component, may be NULL.
    /// @param g a pointer filled in with the green component, may be NULL.
    /// @param b a pointer filled in with the blue component, may be NULL.
    /// @param a a pointer filled in with the alpha component, may be NULL.
    ///
    /// @threadsafety It is safe to call this function from any thread, as long as
    /// the palette is not modified.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPixelFormatDetails
    /// @see #getRGB
    /// @see #mapRGB
    /// @see #mapRGBA
    public void getRGBA(
        @NativeType("Uint32") @Unsigned int pixel,
        @Nullable @Pointer ISDL_PixelFormatDetails format,
        @Nullable @Pointer ISDL_Palette palette,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr r,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr g,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr b,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRGBA);
        try {
            hFunction.invokeExact(
                pixel,
                (MemorySegment) (format != null ? format.segment() : MemorySegment.NULL),
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL),
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of the platform.
    ///
    /// Here are the names returned for some (but not all) supported platforms:
    ///
    /// - "Windows"
    /// - "macOS"
    /// - "Linux"
    /// - "iOS"
    /// - "Android"
    ///
    /// @return the name of the platform. If the correct platform name is not
    /// available, returns a string beginning with the text "Unknown".
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getPlatform() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPlatform);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current power supply details.
    ///
    /// You should never take a battery status as absolute truth. Batteries
    /// (especially failing batteries) are delicate hardware, and the values
    /// reported here are best estimates based on what that hardware reports. It's
    /// not uncommon for older batteries to lose stored power much faster than it
    /// reports, or completely drain when reporting it has 20 percent left, etc.
    ///
    /// Battery status can change at any time; if you are concerned with power
    /// state, you should call this function frequently, and perhaps ignore changes
    /// until they seem to be stable for a few seconds.
    ///
    /// It's possible a platform can only report battery percentage or time left
    /// but not both.
    ///
    /// On some platforms, retrieving power supply details might be expensive. If
    /// you want to display continuous status you could call this function every
    /// minute or so.
    ///
    /// @param seconds a pointer filled in with the seconds of battery life left,
    /// or NULL to ignore. This will be filled in with -1 if we
    /// can't determine a value or there is no battery.
    /// @param percent a pointer filled in with the percentage of battery life
    /// left, between 0 and 100, or NULL to ignore. This will be
    /// filled in with -1 we can't determine a value or there is no
    /// battery.
    /// @return the current battery state or `SDL_POWERSTATE_ERROR` on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_PowerState.class) int getPowerInfo(
        @Nullable IntPtr seconds,
        @Nullable IntPtr percent
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPowerInfo);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (seconds != null ? seconds.segment() : MemorySegment.NULL),
                (MemorySegment) (percent != null ? percent.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new process.
    ///
    /// The path to the executable is supplied in args[0]. args[1..N] are
    /// additional arguments passed on the command line of the new process, and the
    /// argument list should be terminated with a NULL, e.g.:
    ///
    /// ```c
    /// const char *args[] = { "myprogram", "argument", NULL };
    /// ```
    ///
    /// Setting pipe_stdio to true is equivalent to setting
    /// `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` and
    /// `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` to `SDL_PROCESS_STDIO_APP`, and
    /// will allow the use of SDL_ReadProcess() or SDL_GetProcessInput() and
    /// SDL_GetProcessOutput().
    ///
    /// See SDL_CreateProcessWithProperties() for more details.
    ///
    /// @param args the path and arguments for the new process.
    /// @param pipe_stdio true to create pipes to the process's standard input and
    /// from the process's standard output, false for the process
    /// to have no input and inherit the application's standard
    /// output.
    /// @return the newly created and running process, or NULL if the process
    /// couldn't be created.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcessWithProperties
    /// @see #getProcessProperties
    /// @see #readProcess
    /// @see #getProcessInput
    /// @see #getProcessOutput
    /// @see #killProcess
    /// @see #waitProcess
    /// @see #destroyProcess
    public SDL_Process createProcess(
        @Nullable PointerPtr args,
        @NativeType("boolean") boolean pipe_stdio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateProcess);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (args != null ? args.segment() : MemorySegment.NULL),
                pipe_stdio
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Process(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new process with the specified properties.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_PROCESS_CREATE_ARGS_POINTER`: an array of strings containing
    /// the program to run, any arguments, and a NULL pointer, e.g. const char
    /// *args[] = { "myprogram", "argument", NULL }. This is a required property.
    /// - `SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER`: an SDL_Environment
    /// pointer. If this property is set, it will be the entire environment for
    /// the process, otherwise the current environment is used.
    /// - `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER`: an SDL_ProcessIO value describing
    /// where standard input for the process comes from, defaults to
    /// `SDL_PROCESS_STDIO_NULL`.
    /// - `SDL_PROP_PROCESS_CREATE_STDIN_POINTER`: an SDL_IOStream pointer used for
    /// standard input when `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` is set to
    /// `SDL_PROCESS_STDIO_REDIRECT`.
    /// - `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER`: an SDL_ProcessIO value
    /// describing where standard output for the process goes to, defaults to
    /// `SDL_PROCESS_STDIO_INHERITED`.
    /// - `SDL_PROP_PROCESS_CREATE_STDOUT_POINTER`: an SDL_IOStream pointer used
    /// for standard output when `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` is set
    /// to `SDL_PROCESS_STDIO_REDIRECT`.
    /// - `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER`: an SDL_ProcessIO value
    /// describing where standard error for the process goes to, defaults to
    /// `SDL_PROCESS_STDIO_INHERITED`.
    /// - `SDL_PROP_PROCESS_CREATE_STDERR_POINTER`: an SDL_IOStream pointer used
    /// for standard error when `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set to
    /// `SDL_PROCESS_STDIO_REDIRECT`.
    /// - `SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN`: true if the error
    /// output of the process should be redirected into the standard output of
    /// the process. This property has no effect if
    /// `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set.
    /// - `SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN`: true if the process should
    /// run in the background. In this case the default input and output is
    /// `SDL_PROCESS_STDIO_NULL` and the exitcode of the process is not
    /// available, and will always be 0.
    ///
    /// On POSIX platforms, wait() and waitpid(-1, ...) should not be called, and
    /// SIGCHLD should not be ignored or handled because those would prevent SDL
    /// from properly tracking the lifetime of the underlying process. You should
    /// use SDL_WaitProcess() instead.
    ///
    /// @param props the properties to use.
    /// @return the newly created and running process, or NULL if the process
    /// couldn't be created.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #getProcessProperties
    /// @see #readProcess
    /// @see #getProcessInput
    /// @see #getProcessOutput
    /// @see #killProcess
    /// @see #waitProcess
    /// @see #destroyProcess
    public SDL_Process createProcessWithProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateProcessWithProperties);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Process(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a process.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_PROCESS_PID_NUMBER`: the process ID of the process.
    /// - `SDL_PROP_PROCESS_STDIN_POINTER`: an SDL_IOStream that can be used to
    /// write input to the process, if it was created with
    /// `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
    /// - `SDL_PROP_PROCESS_STDOUT_POINTER`: a non-blocking SDL_IOStream that can
    /// be used to read output from the process, if it was created with
    /// `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
    /// - `SDL_PROP_PROCESS_STDERR_POINTER`: a non-blocking SDL_IOStream that can
    /// be used to read error output from the process, if it was created with
    /// `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
    /// - `SDL_PROP_PROCESS_BACKGROUND_BOOLEAN`: true if the process is running in
    /// the background.
    ///
    /// @param process the process to query.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    public @NativeType("SDL_PropertiesID") @Unsigned int getProcessProperties(
        @Nullable SDL_Process process
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetProcessProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Read all the output from a process.
    ///
    /// If a process was created with I/O enabled, you can use this function to
    /// read the output. This function blocks until the process is complete,
    /// capturing all output, and providing the process exit code.
    ///
    /// The data is allocated with a zero byte at the end (null terminated) for
    /// convenience. This extra byte is not included in the value reported via
    /// `datasize`.
    ///
    /// The data should be freed with SDL_free().
    ///
    /// @param process The process to read.
    /// @param datasize a pointer filled in with the number of bytes read, may be
    /// NULL.
    /// @param exitcode a pointer filled in with the process exit code if the
    /// process has exited, may be NULL.
    /// @return the data or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    /// @see #destroyProcess
    public @Pointer(comment="void*") MemorySegment readProcess(
        @Nullable SDL_Process process,
        @Nullable PointerPtr datasize,
        @Nullable IntPtr exitcode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadProcess);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL),
                (MemorySegment) (datasize != null ? datasize.segment() : MemorySegment.NULL),
                (MemorySegment) (exitcode != null ? exitcode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_IOStream associated with process standard input.
    ///
    /// The process must have been created with SDL_CreateProcess() and pipe_stdio
    /// set to true, or with SDL_CreateProcessWithProperties() and
    /// `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
    ///
    /// Writing to this stream can return less data than expected if the process
    /// hasn't read its input. It may be blocked waiting for its output to be read,
    /// if so you may need to call SDL_GetProcessOutput() and read the output in
    /// parallel with writing input.
    ///
    /// @param process The process to get the input stream for.
    /// @return the input stream or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    /// @see #getProcessOutput
    public SDL_IOStream getProcessInput(
        @Nullable SDL_Process process
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetProcessInput);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL_IOStream associated with process standard output.
    ///
    /// The process must have been created with SDL_CreateProcess() and pipe_stdio
    /// set to true, or with SDL_CreateProcessWithProperties() and
    /// `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
    ///
    /// Reading from this stream can return 0 with SDL_GetIOStatus() returning
    /// SDL_IO_STATUS_NOT_READY if no output is available yet.
    ///
    /// @param process The process to get the output stream for.
    /// @return the output stream or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    /// @see #getProcessInput
    public SDL_IOStream getProcessOutput(
        @Nullable SDL_Process process
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetProcessOutput);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_IOStream(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Stop a process.
    ///
    /// @param process The process to stop.
    /// @param force true to terminate the process immediately, false to try to
    /// stop the process gracefully. In general you should try to stop
    /// the process gracefully first as terminating a process may
    /// leave it with half-written data or in some other unstable
    /// state.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    /// @see #waitProcess
    /// @see #destroyProcess
    public @NativeType("boolean") boolean killProcess(
        @Nullable SDL_Process process,
        @NativeType("boolean") boolean force
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_KillProcess);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL),
                force
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait for a process to finish.
    ///
    /// This can be called multiple times to get the status of a process.
    ///
    /// The exit code will be the exit code of the process if it terminates
    /// normally, a negative signal if it terminated due to a signal, or -255
    /// otherwise. It will not be changed if the process is still running.
    ///
    /// If you create a process with standard output piped to the application
    /// (`pipe_stdio` being true) then you should read all of the process output
    /// before calling SDL_WaitProcess(). If you don't do this the process might be
    /// blocked indefinitely waiting for output to be read and SDL_WaitProcess()
    /// will never return true;
    ///
    /// @param process The process to wait for.
    /// @param block If true, block until the process finishes; otherwise, report
    /// on the process' status.
    /// @param exitcode a pointer filled in with the process exit code if the
    /// process has exited, may be NULL.
    /// @return true if the process exited, false otherwise.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    /// @see #killProcess
    /// @see #destroyProcess
    public @NativeType("boolean") boolean waitProcess(
        @Nullable SDL_Process process,
        @NativeType("boolean") boolean block,
        @Nullable IntPtr exitcode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitProcess);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL),
                block,
                (MemorySegment) (exitcode != null ? exitcode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a previously created process object.
    ///
    /// Note that this does not stop the process, just destroys the SDL object used
    /// to track it. If you want to stop the process you should use
    /// SDL_KillProcess().
    ///
    /// @param process The process object to destroy.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProcess
    /// @see #createProcessWithProperties
    /// @see #killProcess
    public void destroyProcess(
        @Nullable SDL_Process process
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyProcess);
        try {
            hFunction.invokeExact(
                (MemorySegment) (process != null ? process.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the global SDL properties.
    ///
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getGlobalProperties() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGlobalProperties);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a group of properties.
    ///
    /// All properties are automatically destroyed when SDL_Quit() is called.
    ///
    /// @return an ID for a new group of properties, or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyProperties
    public @NativeType("SDL_PropertiesID") @Unsigned int createProperties() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateProperties);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a group of properties.
    ///
    /// Copy all the properties from one group of properties to another, with the
    /// exception of properties requiring cleanup (set using
    /// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any
    /// property that already exists on `dst` will be overwritten.
    ///
    /// @param src the properties to copy.
    /// @param dst the destination properties.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean copyProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int src,
        @NativeType("SDL_PropertiesID") @Unsigned int dst
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CopyProperties);
        try {
            return (boolean) hFunction.invokeExact(
                src,
                dst
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock a group of properties.
    ///
    /// Obtain a multi-threaded lock for these properties. Other threads will wait
    /// while trying to lock these properties until they are unlocked. Properties
    /// must be unlocked before they are destroyed.
    ///
    /// The lock is automatically taken when setting individual properties, this
    /// function is only needed when you want to set several properties atomically
    /// or want to guarantee that properties being queried aren't freed in another
    /// thread.
    ///
    /// @param props the properties to lock.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #unlockProperties
    public @NativeType("boolean") boolean lockProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockProperties);
        try {
            return (boolean) hFunction.invokeExact(
                props
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlock a group of properties.
    ///
    /// @param props the properties to unlock.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockProperties
    public void unlockProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockProperties);
        try {
            hFunction.invokeExact(
                props
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a pointer property in a group of properties with a cleanup function
    /// that is called when the property is deleted.
    ///
    /// The cleanup function is also called if setting the property fails for any
    /// reason.
    ///
    /// For simply setting basic data types, like numbers, bools, or strings, use
    /// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty
    /// instead, as those functions will handle cleanup on your behalf. This
    /// function is only for more complex, custom data.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to modify.
    /// @param value the new value of the property, or NULL to delete the property.
    /// @param cleanup the function to call when this property is deleted, or NULL
    /// if no cleanup is necessary.
    /// @param userdata a pointer that is passed to the cleanup function.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPointerProperty
    /// @see #setPointerProperty
    /// @see `SDL_CleanupPropertyCallback`
    public @NativeType("boolean") boolean setPointerPropertyWithCleanup(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @Pointer(comment="void*") MemorySegment value,
        @Pointer(comment="SDL_CleanupPropertyCallback") MemorySegment cleanup,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetPointerPropertyWithCleanup);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                value,
                cleanup,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a pointer property in a group of properties.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to modify.
    /// @param value the new value of the property, or NULL to delete the property.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPointerProperty
    /// @see #hasProperty
    /// @see #setBooleanProperty
    /// @see #setFloatProperty
    /// @see #setNumberProperty
    /// @see #setPointerPropertyWithCleanup
    /// @see #setStringProperty
    public @NativeType("boolean") boolean setPointerProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @Pointer(comment="void*") MemorySegment value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetPointerProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a string property in a group of properties.
    ///
    /// This function makes a copy of the string; the caller does not have to
    /// preserve the data after this call completes.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to modify.
    /// @param value the new value of the property, or NULL to delete the property.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getStringProperty
    public @NativeType("boolean") boolean setStringProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @Nullable BytePtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetStringProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an integer property in a group of properties.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to modify.
    /// @param value the new value of the property.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumberProperty
    public @NativeType("boolean") boolean setNumberProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @NativeType("Sint64") long value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetNumberProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a floating point property in a group of properties.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to modify.
    /// @param value the new value of the property.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getFloatProperty
    public @NativeType("boolean") boolean setFloatProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        float value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetFloatProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a boolean property in a group of properties.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to modify.
    /// @param value the new value of the property.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getBooleanProperty
    public @NativeType("boolean") boolean setBooleanProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @NativeType("boolean") boolean value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetBooleanProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a property exists in a group of properties.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @return true if the property exists, or false if it doesn't.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPropertyType
    public @NativeType("boolean") boolean hasProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of a property in a group of properties.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @return the type of the property, or SDL_PROPERTY_TYPE_INVALID if it is
    /// not set.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasProperty
    public @EnumType(SDL_PropertyType.class) int getPropertyType(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPropertyType);
        try {
            return (int) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a pointer property from a group of properties.
    ///
    /// By convention, the names of properties that SDL exposes on objects will
    /// start with "SDL.", and properties that SDL uses internally will start with
    /// "SDL.internal.". These should be considered read-only and should not be
    /// modified by applications.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @param default_value the default value of the property.
    /// @return the value of the property, or `default_value` if it is not set or
    /// not a pointer property.
    ///
    /// @threadsafety It is safe to call this function from any thread, although
    /// the data returned is not protected and could potentially be
    /// freed if you call SDL_SetPointerProperty() or
    /// SDL_ClearProperty() on these properties from another thread.
    /// If you need to avoid this, use SDL_LockProperties() and
    /// SDL_UnlockProperties().
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getBooleanProperty
    /// @see #getFloatProperty
    /// @see #getNumberProperty
    /// @see #getPropertyType
    /// @see #getStringProperty
    /// @see #hasProperty
    /// @see #setPointerProperty
    public @Pointer(comment="void*") MemorySegment getPointerProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @Pointer(comment="void*") MemorySegment default_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPointerProperty);
        try {
            return (MemorySegment) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                default_value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a string property from a group of properties.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @param default_value the default value of the property.
    /// @return the value of the property, or `default_value` if it is not set or
    /// not a string property.
    ///
    /// @threadsafety It is safe to call this function from any thread, although
    /// the data returned is not protected and could potentially be
    /// freed if you call SDL_SetStringProperty() or
    /// SDL_ClearProperty() on these properties from another thread.
    /// If you need to avoid this, use SDL_LockProperties() and
    /// SDL_UnlockProperties().
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPropertyType
    /// @see #hasProperty
    /// @see #setStringProperty
    public BytePtr getStringProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @Nullable BytePtr default_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetStringProperty);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                (MemorySegment) (default_value != null ? default_value.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a number property from a group of properties.
    ///
    /// You can use SDL_GetPropertyType() to query whether the property exists and
    /// is a number property.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @param default_value the default value of the property.
    /// @return the value of the property, or `default_value` if it is not set or
    /// not a number property.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPropertyType
    /// @see #hasProperty
    /// @see #setNumberProperty
    public @NativeType("Sint64") long getNumberProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @NativeType("Sint64") long default_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumberProperty);
        try {
            return (long) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                default_value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a floating point property from a group of properties.
    ///
    /// You can use SDL_GetPropertyType() to query whether the property exists and
    /// is a floating point property.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @param default_value the default value of the property.
    /// @return the value of the property, or `default_value` if it is not set or
    /// not a float property.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPropertyType
    /// @see #hasProperty
    /// @see #setFloatProperty
    public float getFloatProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        float default_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetFloatProperty);
        try {
            return (float) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                default_value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a boolean property from a group of properties.
    ///
    /// You can use SDL_GetPropertyType() to query whether the property exists and
    /// is a boolean property.
    ///
    /// @param props the properties to query.
    /// @param name the name of the property to query.
    /// @param default_value the default value of the property.
    /// @return the value of the property, or `default_value` if it is not set or
    /// not a boolean property.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPropertyType
    /// @see #hasProperty
    /// @see #setBooleanProperty
    public @NativeType("boolean") boolean getBooleanProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name,
        @NativeType("boolean") boolean default_value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetBooleanProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                default_value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear a property from a group of properties.
    ///
    /// @param props the properties to modify.
    /// @param name the name of the property to clear.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean clearProperty(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClearProperty);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Enumerate the properties contained in a group of properties.
    ///
    /// The callback function is called for each property in the group of
    /// properties. The properties are locked during enumeration.
    ///
    /// @param props the properties to query.
    /// @param callback the function to call for each property.
    /// @param userdata a pointer that is passed to `callback`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean enumerateProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Pointer(comment="SDL_EnumeratePropertiesCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EnumerateProperties);
        try {
            return (boolean) hFunction.invokeExact(
                props,
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a group of properties.
    ///
    /// All properties are deleted and their cleanup functions will be called, if
    /// any.
    ///
    /// @param props the properties to destroy.
    ///
    /// @threadsafety This function should not be called while these properties are
    /// locked or other threads might be setting or getting values
    /// from these properties.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProperties
    public void destroyProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyProperties);
        try {
            hFunction.invokeExact(
                props
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether two rectangles intersect.
    ///
    /// If either pointer is NULL the function will return false.
    ///
    /// @param A an SDL_Rect structure representing the first rectangle.
    /// @param B an SDL_Rect structure representing the second rectangle.
    /// @return true if there is an intersection, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRectIntersection
    public @NativeType("boolean") boolean hasRectIntersection(
        @Nullable @Pointer ISDL_Rect A,
        @Nullable @Pointer ISDL_Rect B
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasRectIntersection);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (A != null ? A.segment() : MemorySegment.NULL),
                (MemorySegment) (B != null ? B.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the intersection of two rectangles.
    ///
    /// If `result` is NULL then this function will return false.
    ///
    /// @param A an SDL_Rect structure representing the first rectangle.
    /// @param B an SDL_Rect structure representing the second rectangle.
    /// @param result an SDL_Rect structure filled in with the intersection of
    /// rectangles `A` and `B`.
    /// @return true if there is an intersection, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasRectIntersection
    public @NativeType("boolean") boolean getRectIntersection(
        @Nullable @Pointer ISDL_Rect A,
        @Nullable @Pointer ISDL_Rect B,
        @Nullable @Pointer ISDL_Rect result
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectIntersection);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (A != null ? A.segment() : MemorySegment.NULL),
                (MemorySegment) (B != null ? B.segment() : MemorySegment.NULL),
                (MemorySegment) (result != null ? result.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the union of two rectangles.
    ///
    /// @param A an SDL_Rect structure representing the first rectangle.
    /// @param B an SDL_Rect structure representing the second rectangle.
    /// @param result an SDL_Rect structure filled in with the union of rectangles
    /// `A` and `B`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRectUnion(
        @Nullable @Pointer ISDL_Rect A,
        @Nullable @Pointer ISDL_Rect B,
        @Nullable @Pointer ISDL_Rect result
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectUnion);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (A != null ? A.segment() : MemorySegment.NULL),
                (MemorySegment) (B != null ? B.segment() : MemorySegment.NULL),
                (MemorySegment) (result != null ? result.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate a minimal rectangle enclosing a set of points.
    ///
    /// If `clip` is not NULL then only points inside of the clipping rectangle are
    /// considered.
    ///
    /// @param points an array of SDL_Point structures representing points to be
    /// enclosed.
    /// @param count the number of structures in the `points` array.
    /// @param clip an SDL_Rect used for clipping or NULL to enclose all points.
    /// @param result an SDL_Rect structure filled in with the minimal enclosing
    /// rectangle.
    /// @return true if any points were enclosed or false if all the points were
    /// outside of the clipping rectangle.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRectEnclosingPoints(
        @Nullable @Pointer ISDL_Point points,
        int count,
        @Nullable @Pointer ISDL_Rect clip,
        @Nullable @Pointer ISDL_Rect result
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectEnclosingPoints);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (points != null ? points.segment() : MemorySegment.NULL),
                count,
                (MemorySegment) (clip != null ? clip.segment() : MemorySegment.NULL),
                (MemorySegment) (result != null ? result.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the intersection of a rectangle and line segment.
    ///
    /// This function is used to clip a line segment to a rectangle. A line segment
    /// contained entirely within the rectangle or that does not intersect will
    /// remain unchanged. A line segment that crosses the rectangle at either or
    /// both ends will be clipped to the boundary of the rectangle and the new
    /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
    ///
    /// @param rect an SDL_Rect structure representing the rectangle to intersect.
    /// @param X1 a pointer to the starting X-coordinate of the line.
    /// @param Y1 a pointer to the starting Y-coordinate of the line.
    /// @param X2 a pointer to the ending X-coordinate of the line.
    /// @param Y2 a pointer to the ending Y-coordinate of the line.
    /// @return true if there is an intersection, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRectAndLineIntersection(
        @Nullable @Pointer ISDL_Rect rect,
        @Nullable IntPtr X1,
        @Nullable IntPtr Y1,
        @Nullable IntPtr X2,
        @Nullable IntPtr Y2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectAndLineIntersection);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (X1 != null ? X1.segment() : MemorySegment.NULL),
                (MemorySegment) (Y1 != null ? Y1.segment() : MemorySegment.NULL),
                (MemorySegment) (X2 != null ? X2.segment() : MemorySegment.NULL),
                (MemorySegment) (Y2 != null ? Y2.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Determine whether two rectangles intersect with float precision.
    ///
    /// If either pointer is NULL the function will return false.
    ///
    /// @param A an SDL_FRect structure representing the first rectangle.
    /// @param B an SDL_FRect structure representing the second rectangle.
    /// @return true if there is an intersection, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRectIntersection
    public @NativeType("boolean") boolean hasRectIntersectionFloat(
        @Nullable @Pointer ISDL_FRect A,
        @Nullable @Pointer ISDL_FRect B
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HasRectIntersectionFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (A != null ? A.segment() : MemorySegment.NULL),
                (MemorySegment) (B != null ? B.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the intersection of two rectangles with float precision.
    ///
    /// If `result` is NULL then this function will return false.
    ///
    /// @param A an SDL_FRect structure representing the first rectangle.
    /// @param B an SDL_FRect structure representing the second rectangle.
    /// @param result an SDL_FRect structure filled in with the intersection of
    /// rectangles `A` and `B`.
    /// @return true if there is an intersection, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hasRectIntersectionFloat
    public @NativeType("boolean") boolean getRectIntersectionFloat(
        @Nullable @Pointer ISDL_FRect A,
        @Nullable @Pointer ISDL_FRect B,
        @Nullable @Pointer ISDL_FRect result
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectIntersectionFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (A != null ? A.segment() : MemorySegment.NULL),
                (MemorySegment) (B != null ? B.segment() : MemorySegment.NULL),
                (MemorySegment) (result != null ? result.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the union of two rectangles with float precision.
    ///
    /// @param A an SDL_FRect structure representing the first rectangle.
    /// @param B an SDL_FRect structure representing the second rectangle.
    /// @param result an SDL_FRect structure filled in with the union of rectangles
    /// `A` and `B`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRectUnionFloat(
        @Nullable @Pointer ISDL_FRect A,
        @Nullable @Pointer ISDL_FRect B,
        @Nullable @Pointer ISDL_FRect result
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectUnionFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (A != null ? A.segment() : MemorySegment.NULL),
                (MemorySegment) (B != null ? B.segment() : MemorySegment.NULL),
                (MemorySegment) (result != null ? result.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate a minimal rectangle enclosing a set of points with float
    /// precision.
    ///
    /// If `clip` is not NULL then only points inside of the clipping rectangle are
    /// considered.
    ///
    /// @param points an array of SDL_FPoint structures representing points to be
    /// enclosed.
    /// @param count the number of structures in the `points` array.
    /// @param clip an SDL_FRect used for clipping or NULL to enclose all points.
    /// @param result an SDL_FRect structure filled in with the minimal enclosing
    /// rectangle.
    /// @return true if any points were enclosed or false if all the points were
    /// outside of the clipping rectangle.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRectEnclosingPointsFloat(
        @Nullable @Pointer ISDL_FPoint points,
        int count,
        @Nullable @Pointer ISDL_FRect clip,
        @Nullable @Pointer ISDL_FRect result
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectEnclosingPointsFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (points != null ? points.segment() : MemorySegment.NULL),
                count,
                (MemorySegment) (clip != null ? clip.segment() : MemorySegment.NULL),
                (MemorySegment) (result != null ? result.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Calculate the intersection of a rectangle and line segment with float
    /// precision.
    ///
    /// This function is used to clip a line segment to a rectangle. A line segment
    /// contained entirely within the rectangle or that does not intersect will
    /// remain unchanged. A line segment that crosses the rectangle at either or
    /// both ends will be clipped to the boundary of the rectangle and the new
    /// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
    ///
    /// @param rect an SDL_FRect structure representing the rectangle to intersect.
    /// @param X1 a pointer to the starting X-coordinate of the line.
    /// @param Y1 a pointer to the starting Y-coordinate of the line.
    /// @param X2 a pointer to the ending X-coordinate of the line.
    /// @param Y2 a pointer to the ending Y-coordinate of the line.
    /// @return true if there is an intersection, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRectAndLineIntersectionFloat(
        @Nullable @Pointer ISDL_FRect rect,
        @Nullable FloatPtr X1,
        @Nullable FloatPtr Y1,
        @Nullable FloatPtr X2,
        @Nullable FloatPtr Y2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRectAndLineIntersectionFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (X1 != null ? X1.segment() : MemorySegment.NULL),
                (MemorySegment) (Y1 != null ? Y1.segment() : MemorySegment.NULL),
                (MemorySegment) (X2 != null ? X2.segment() : MemorySegment.NULL),
                (MemorySegment) (Y2 != null ? Y2.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of 2D rendering drivers available for the current display.
    ///
    /// A render driver is a set of code that handles rendering and texture
    /// management on a particular display. Normally there is only one, but some
    /// drivers may have several available with different capabilities.
    ///
    /// There may be none if SDL was compiled without render support.
    ///
    /// @return the number of built in render drivers.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRenderer
    /// @see #getRenderDriver
    public int getNumRenderDrivers() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumRenderDrivers);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to get the name of a built in 2D rendering driver.
    ///
    /// The list of rendering drivers is given in the order that they are normally
    /// initialized by default; the drivers that seem more reasonable to choose
    /// first (as far as the SDL developers believe) are earlier in the list.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "opengl",
    /// "direct3d12" or "metal". These never have Unicode characters, and are not
    /// meant to be proper names.
    ///
    /// @param index the index of the rendering driver; the value ranges from 0 to
    /// SDL_GetNumRenderDrivers() - 1.
    /// @return the name of the rendering driver at the requested index, or NULL
    /// if an invalid index was specified.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumRenderDrivers
    public BytePtr getRenderDriver(
        int index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                index
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a window and default renderer.
    ///
    /// @param title the title of the window, in UTF-8 encoding.
    /// @param width the width of the window.
    /// @param height the height of the window.
    /// @param window_flags the flags used to create the window (see
    /// SDL_CreateWindow()).
    /// @param window a pointer filled with the window, or NULL on error.
    /// @param renderer a pointer filled with the renderer, or NULL on error.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRenderer
    /// @see #createWindow
    public @NativeType("boolean") boolean createWindowAndRenderer(
        @Nullable BytePtr title,
        int width,
        int height,
        @EnumType(SDL_WindowFlags.class) long window_flags,
        @Nullable @Pointer SDL_Window.Ptr window,
        @Nullable @Pointer SDL_Renderer.Ptr renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateWindowAndRenderer);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (title != null ? title.segment() : MemorySegment.NULL),
                width,
                height,
                window_flags,
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a 2D rendering context for a window.
    ///
    /// If you want a specific renderer, you can specify its name here. A list of
    /// available renderers can be obtained by calling SDL_GetRenderDriver()
    /// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you
    /// don't need a specific renderer, specify NULL and SDL will attempt to choose
    /// the best option for you, based on what is available on the user's system.
    ///
    /// If `name` is a comma-separated list, SDL will try each name, in the order
    /// listed, until one succeeds or all of them fail.
    ///
    /// By default the rendering size matches the window size in pixels, but you
    /// can call SDL_SetRenderLogicalPresentation() to change the content size and
    /// scaling options.
    ///
    /// @param window the window where rendering is displayed.
    /// @param name the name of the rendering driver to initialize, or NULL to let
    /// SDL choose one.
    /// @return a valid rendering context or NULL if there was an error; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRendererWithProperties
    /// @see #createSoftwareRenderer
    /// @see #destroyRenderer
    /// @see #getNumRenderDrivers
    /// @see #getRenderDriver
    /// @see #getRendererName
    public SDL_Renderer createRenderer(
        @Nullable SDL_Window window,
        @Nullable BytePtr name
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateRenderer);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Renderer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a 2D rendering context for a window, with the specified properties.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver
    /// to use, if a specific one is desired
    /// - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is
    /// displayed, required if this isn't a software renderer using a surface
    /// - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering
    /// is displayed, if you want a software renderer without a window
    /// - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace
    /// value describing the colorspace for output to the display, defaults to
    /// SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers
    /// support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and
    /// supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing
    /// still uses the sRGB colorspace, but values can go beyond 1.0 and float
    /// (linear) format textures can be used for HDR content.
    /// - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want
    /// present synchronized with the refresh rate. This property can take any
    /// value that is supported by SDL_SetRenderVSync() for the renderer.
    ///
    /// With the vulkan renderer:
    ///
    /// - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use
    /// with the renderer, optional.
    /// - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use
    /// with the renderer, optional.
    /// - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the
    /// VkPhysicalDevice to use with the renderer, optional.
    /// - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use
    /// with the renderer, optional.
    /// - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the
    /// queue family index used for rendering.
    /// - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the
    /// queue family index used for presentation.
    ///
    /// @param props the properties to use.
    /// @return a valid rendering context or NULL if there was an error; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProperties
    /// @see #createRenderer
    /// @see #createSoftwareRenderer
    /// @see #destroyRenderer
    /// @see #getRendererName
    public SDL_Renderer createRendererWithProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateRendererWithProperties);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Renderer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a 2D software rendering context for a surface.
    ///
    /// Two other API which can be used to create SDL_Renderer:
    /// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
    /// create a software renderer, but they are intended to be used with an
    /// SDL_Window as the final destination and not an SDL_Surface.
    ///
    /// @param surface the SDL_Surface structure representing the surface where
    /// rendering is done.
    /// @return a valid rendering context or NULL if there was an error; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyRenderer
    public SDL_Renderer createSoftwareRenderer(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateSoftwareRenderer);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Renderer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the renderer associated with a window.
    ///
    /// @param window the window to query.
    /// @return the rendering context on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Renderer getRenderer(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderer);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Renderer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the window associated with a renderer.
    ///
    /// @param renderer the renderer to query.
    /// @return the window on success or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Window getRenderWindow(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderWindow);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of a renderer.
    ///
    /// @param renderer the rendering context.
    /// @return the name of the selected renderer, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRenderer
    /// @see #createRendererWithProperties
    public BytePtr getRendererName(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRendererName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a renderer.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver
    /// - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is
    /// displayed, if any
    /// - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is
    /// displayed, if this is a software renderer without a window
    /// - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting
    /// - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width
    /// and height
    /// - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)
    /// array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,
    /// representing the available texture formats for this renderer.
    /// - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value
    /// describing the colorspace for output to the display, defaults to
    /// SDL_COLORSPACE_SRGB.
    /// - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is
    /// SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with
    /// HDR enabled. This property can change dynamically when
    /// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
    /// - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the
    /// SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is
    /// automatically multiplied into the color scale. This property can change
    /// dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
    /// - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range
    /// that can be displayed, in terms of the SDR white point. When HDR is not
    /// enabled, this will be 1.0. This property can change dynamically when
    /// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
    ///
    /// With the direct3d renderer:
    ///
    /// - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated
    /// with the renderer
    ///
    /// With the direct3d11 renderer:
    ///
    /// - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated
    /// with the renderer
    /// - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1
    /// associated with the renderer. This may change when the window is resized.
    ///
    /// With the direct3d12 renderer:
    ///
    /// - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated
    /// with the renderer
    /// - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4
    /// associated with the renderer.
    /// - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue
    /// associated with the renderer
    ///
    /// With the vulkan renderer:
    ///
    /// - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated
    /// with the renderer
    /// - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated
    /// with the renderer
    /// - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice
    /// associated with the renderer
    /// - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with
    /// the renderer
    /// - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue
    /// family index used for rendering
    /// - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue
    /// family index used for presentation
    /// - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of
    /// swapchain images, or potential frames in flight, used by the Vulkan
    /// renderer
    ///
    /// With the gpu renderer:
    ///
    /// - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with
    /// the renderer
    ///
    /// @param renderer the rendering context.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getRendererProperties(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRendererProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the output size in pixels of a rendering context.
    ///
    /// This returns the true output size in pixels, ignoring any render targets or
    /// logical size and presentation.
    ///
    /// For the output size of the current rendering target, with logical size
    /// adjustments, use SDL_GetCurrentRenderOutputSize() instead.
    ///
    /// @param renderer the rendering context.
    /// @param w a pointer filled in with the width in pixels.
    /// @param h a pointer filled in with the height in pixels.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCurrentRenderOutputSize
    public @NativeType("boolean") boolean getRenderOutputSize(
        @Nullable SDL_Renderer renderer,
        @Nullable IntPtr w,
        @Nullable IntPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderOutputSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current output size in pixels of a rendering context.
    ///
    /// If a rendering target is active, this will return the size of the rendering
    /// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().
    ///
    /// Rendering target or not, the output will be adjusted by the current logical
    /// presentation state, dictated by SDL_SetRenderLogicalPresentation().
    ///
    /// @param renderer the rendering context.
    /// @param w a pointer filled in with the current width.
    /// @param h a pointer filled in with the current height.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderOutputSize
    public @NativeType("boolean") boolean getCurrentRenderOutputSize(
        @Nullable SDL_Renderer renderer,
        @Nullable IntPtr w,
        @Nullable IntPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentRenderOutputSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a texture for a rendering context.
    ///
    /// The contents of a texture when first created are not defined.
    ///
    /// @param renderer the rendering context.
    /// @param format one of the enumerated values in SDL_PixelFormat.
    /// @param access one of the enumerated values in SDL_TextureAccess.
    /// @param w the width of the texture in pixels.
    /// @param h the height of the texture in pixels.
    /// @return the created texture or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTextureFromSurface
    /// @see #createTextureWithProperties
    /// @see #destroyTexture
    /// @see #getTextureSize
    /// @see #updateTexture
    public SDL_Texture createTexture(
        @Nullable SDL_Renderer renderer,
        @EnumType(SDL_PixelFormat.class) int format,
        @EnumType(SDL_TextureAccess.class) int access,
        int w,
        int h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateTexture);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                format,
                access,
                w,
                h
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Texture(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a texture from an existing surface.
    ///
    /// The surface is not modified or freed by this function.
    ///
    /// The SDL_TextureAccess hint for the created texture is
    /// `SDL_TEXTUREACCESS_STATIC`.
    ///
    /// The pixel format of the created texture may be different from the pixel
    /// format of the surface, and can be queried using the
    /// SDL_PROP_TEXTURE_FORMAT_NUMBER property.
    ///
    /// @param renderer the rendering context.
    /// @param surface the SDL_Surface structure containing pixel data used to fill
    /// the texture.
    /// @return the created texture or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTexture
    /// @see #createTextureWithProperties
    /// @see #destroyTexture
    public SDL_Texture createTextureFromSurface(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateTextureFromSurface);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Texture(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a texture for a rendering context with the specified properties.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value
    /// describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR
    /// for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,
    /// SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for
    /// YUV textures.
    /// - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in
    /// SDL_PixelFormat, defaults to the best RGBA format for the renderer
    /// - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in
    /// SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC
    /// - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in
    /// pixels, required
    /// - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in
    /// pixels, required
    /// - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
    /// point textures, this defines the value of 100% diffuse white, with higher
    /// values being displayed in the High Dynamic Range headroom. This defaults
    /// to 100 for HDR10 textures and 1.0 for floating point textures.
    /// - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
    /// point textures, this defines the maximum dynamic range used by the
    /// content, in terms of the SDR white point. This would be equivalent to
    /// maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
    /// If this is defined, any values outside the range supported by the display
    /// will be scaled into the available HDR headroom, otherwise they are
    /// clipped.
    ///
    /// With the direct3d11 renderer:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
    /// associated with the texture, if you want to wrap an existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
    /// associated with the U plane of a YUV texture, if you want to wrap an
    /// existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
    /// associated with the V plane of a YUV texture, if you want to wrap an
    /// existing texture.
    ///
    /// With the direct3d12 renderer:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
    /// associated with the texture, if you want to wrap an existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
    /// associated with the U plane of a YUV texture, if you want to wrap an
    /// existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
    /// associated with the V plane of a YUV texture, if you want to wrap an
    /// existing texture.
    ///
    /// With the metal renderer:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
    /// associated with the texture, if you want to create a texture from an
    /// existing pixel buffer.
    ///
    /// With the opengl renderer:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
    /// associated with the texture, if you want to wrap an existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
    /// associated with the UV plane of an NV12 texture, if you want to wrap an
    /// existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
    /// associated with the U plane of a YUV texture, if you want to wrap an
    /// existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
    /// associated with the V plane of a YUV texture, if you want to wrap an
    /// existing texture.
    ///
    /// With the opengles2 renderer:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
    /// associated with the texture, if you want to wrap an existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
    /// associated with the texture, if you want to wrap an existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
    /// associated with the UV plane of an NV12 texture, if you want to wrap an
    /// existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
    /// associated with the U plane of a YUV texture, if you want to wrap an
    /// existing texture.
    /// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
    /// associated with the V plane of a YUV texture, if you want to wrap an
    /// existing texture.
    ///
    /// With the vulkan renderer:
    ///
    /// - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
    /// VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
    /// you want to wrap an existing texture.
    ///
    /// @param renderer the rendering context.
    /// @param props the properties to use.
    /// @return the created texture or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProperties
    /// @see #createTexture
    /// @see #createTextureFromSurface
    /// @see #destroyTexture
    /// @see #getTextureSize
    /// @see #updateTexture
    public SDL_Texture createTextureWithProperties(
        @Nullable SDL_Renderer renderer,
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateTextureWithProperties);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Texture(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a texture.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing
    /// the texture colorspace.
    /// - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in
    /// SDL_PixelFormat.
    /// - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in
    /// SDL_TextureAccess.
    /// - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.
    /// - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.
    /// - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
    /// textures, this defines the value of 100% diffuse white, with higher
    /// values being displayed in the High Dynamic Range headroom. This defaults
    /// to 100 for HDR10 textures and 1.0 for other textures.
    /// - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
    /// textures, this defines the maximum dynamic range used by the content, in
    /// terms of the SDR white point. If this is defined, any values outside the
    /// range supported by the display will be scaled into the available HDR
    /// headroom, otherwise they are clipped. This defaults to 1.0 for SDR
    /// textures, 4.0 for HDR10 textures, and no default for floating point
    /// textures.
    ///
    /// With the direct3d11 renderer:
    ///
    /// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated
    /// with the texture
    /// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
    /// associated with the U plane of a YUV texture
    /// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
    /// associated with the V plane of a YUV texture
    ///
    /// With the direct3d12 renderer:
    ///
    /// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated
    /// with the texture
    /// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated
    /// with the U plane of a YUV texture
    /// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated
    /// with the V plane of a YUV texture
    ///
    /// With the vulkan renderer:
    ///
    /// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the
    /// texture
    ///
    /// With the opengl renderer:
    ///
    /// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated
    /// with the texture
    /// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
    /// associated with the UV plane of an NV12 texture
    /// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated
    /// with the U plane of a YUV texture
    /// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated
    /// with the V plane of a YUV texture
    /// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the
    /// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)
    /// - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of
    /// the texture (0.0 - 1.0)
    /// - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of
    /// the texture (0.0 - 1.0)
    ///
    /// With the opengles2 renderer:
    ///
    /// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
    /// associated with the texture
    /// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
    /// associated with the UV plane of an NV12 texture
    /// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
    /// associated with the U plane of a YUV texture
    /// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
    /// associated with the V plane of a YUV texture
    /// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the
    /// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)
    ///
    /// @param texture the texture to query.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getTextureProperties(
        @Nullable SDL_Texture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the renderer that created an SDL_Texture.
    ///
    /// @param texture the texture to query.
    /// @return a pointer to the SDL_Renderer that created the texture, or NULL on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Renderer getRendererFromTexture(
        @Nullable SDL_Texture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRendererFromTexture);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Renderer(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the size of a texture, as floating point values.
    ///
    /// @param texture the texture to query.
    /// @param w a pointer filled in with the width of the texture in pixels. This
    /// argument can be NULL if you don't need this information.
    /// @param h a pointer filled in with the height of the texture in pixels. This
    /// argument can be NULL if you don't need this information.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getTextureSize(
        @Nullable SDL_Texture texture,
        @Nullable FloatPtr w,
        @Nullable FloatPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an additional color value multiplied into render copy operations.
    ///
    /// When this texture is rendered, during the copy operation each source color
    /// channel is modulated by the appropriate color value according to the
    /// following formula:
    ///
    /// `srcC = srcC * (color / 255)`
    ///
    /// Color modulation is not always supported by the renderer; it will return
    /// false if color modulation is not supported.
    ///
    /// @param texture the texture to update.
    /// @param r the red color value multiplied into copy operations.
    /// @param g the green color value multiplied into copy operations.
    /// @param b the blue color value multiplied into copy operations.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureColorMod
    /// @see #setTextureAlphaMod
    /// @see #setTextureColorModFloat
    public @NativeType("boolean") boolean setTextureColorMod(
        @Nullable SDL_Texture texture,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextureColorMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                r,
                g,
                b
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an additional color value multiplied into render copy operations.
    ///
    /// When this texture is rendered, during the copy operation each source color
    /// channel is modulated by the appropriate color value according to the
    /// following formula:
    ///
    /// `srcC = srcC * color`
    ///
    /// Color modulation is not always supported by the renderer; it will return
    /// false if color modulation is not supported.
    ///
    /// @param texture the texture to update.
    /// @param r the red color value multiplied into copy operations.
    /// @param g the green color value multiplied into copy operations.
    /// @param b the blue color value multiplied into copy operations.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureColorModFloat
    /// @see #setTextureAlphaModFloat
    /// @see #setTextureColorMod
    public @NativeType("boolean") boolean setTextureColorModFloat(
        @Nullable SDL_Texture texture,
        float r,
        float g,
        float b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextureColorModFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                r,
                g,
                b
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the additional color value multiplied into render copy operations.
    ///
    /// @param texture the texture to query.
    /// @param r a pointer filled in with the current red color value.
    /// @param g a pointer filled in with the current green color value.
    /// @param b a pointer filled in with the current blue color value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureAlphaMod
    /// @see #getTextureColorModFloat
    /// @see #setTextureColorMod
    public @NativeType("boolean") boolean getTextureColorMod(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr r,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr g,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureColorMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the additional color value multiplied into render copy operations.
    ///
    /// @param texture the texture to query.
    /// @param r a pointer filled in with the current red color value.
    /// @param g a pointer filled in with the current green color value.
    /// @param b a pointer filled in with the current blue color value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureAlphaModFloat
    /// @see #getTextureColorMod
    /// @see #setTextureColorModFloat
    public @NativeType("boolean") boolean getTextureColorModFloat(
        @Nullable SDL_Texture texture,
        @Nullable FloatPtr r,
        @Nullable FloatPtr g,
        @Nullable FloatPtr b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureColorModFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an additional alpha value multiplied into render copy operations.
    ///
    /// When this texture is rendered, during the copy operation the source alpha
    /// value is modulated by this alpha value according to the following formula:
    ///
    /// `srcA = srcA * (alpha / 255)`
    ///
    /// Alpha modulation is not always supported by the renderer; it will return
    /// false if alpha modulation is not supported.
    ///
    /// @param texture the texture to update.
    /// @param alpha the source alpha value multiplied into copy operations.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureAlphaMod
    /// @see #setTextureAlphaModFloat
    /// @see #setTextureColorMod
    public @NativeType("boolean") boolean setTextureAlphaMod(
        @Nullable SDL_Texture texture,
        @NativeType("Uint8") @Unsigned byte alpha
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextureAlphaMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                alpha
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an additional alpha value multiplied into render copy operations.
    ///
    /// When this texture is rendered, during the copy operation the source alpha
    /// value is modulated by this alpha value according to the following formula:
    ///
    /// `srcA = srcA * alpha`
    ///
    /// Alpha modulation is not always supported by the renderer; it will return
    /// false if alpha modulation is not supported.
    ///
    /// @param texture the texture to update.
    /// @param alpha the source alpha value multiplied into copy operations.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureAlphaModFloat
    /// @see #setTextureAlphaMod
    /// @see #setTextureColorModFloat
    public @NativeType("boolean") boolean setTextureAlphaModFloat(
        @Nullable SDL_Texture texture,
        float alpha
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextureAlphaModFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                alpha
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the additional alpha value multiplied into render copy operations.
    ///
    /// @param texture the texture to query.
    /// @param alpha a pointer filled in with the current alpha value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureAlphaModFloat
    /// @see #getTextureColorMod
    /// @see #setTextureAlphaMod
    public @NativeType("boolean") boolean getTextureAlphaMod(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr alpha
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureAlphaMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (alpha != null ? alpha.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the additional alpha value multiplied into render copy operations.
    ///
    /// @param texture the texture to query.
    /// @param alpha a pointer filled in with the current alpha value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureAlphaMod
    /// @see #getTextureColorModFloat
    /// @see #setTextureAlphaModFloat
    public @NativeType("boolean") boolean getTextureAlphaModFloat(
        @Nullable SDL_Texture texture,
        @Nullable FloatPtr alpha
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureAlphaModFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (alpha != null ? alpha.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the blend mode for a texture, used by SDL_RenderTexture().
    ///
    /// If the blend mode is not supported, the closest supported mode is chosen
    /// and this function returns false.
    ///
    /// @param texture the texture to update.
    /// @param blendMode the SDL_BlendMode to use for texture blending.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureBlendMode
    public @NativeType("boolean") boolean setTextureBlendMode(
        @Nullable SDL_Texture texture,
        @EnumType(SDL_BlendMode.class) int blendMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextureBlendMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                blendMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the blend mode used for texture copy operations.
    ///
    /// @param texture the texture to query.
    /// @param blendMode a pointer filled in with the current SDL_BlendMode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setTextureBlendMode
    public @NativeType("boolean") boolean getTextureBlendMode(
        @Nullable SDL_Texture texture,
        @Nullable @EnumType(SDL_BlendMode.class) IntPtr blendMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureBlendMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (blendMode != null ? blendMode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the scale mode used for texture scale operations.
    ///
    /// The default texture scale mode is SDL_SCALEMODE_LINEAR.
    ///
    /// If the scale mode is not supported, the closest supported mode is chosen.
    ///
    /// @param texture the texture to update.
    /// @param scaleMode the SDL_ScaleMode to use for texture scaling.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTextureScaleMode
    public @NativeType("boolean") boolean setTextureScaleMode(
        @Nullable SDL_Texture texture,
        @EnumType(SDL_ScaleMode.class) int scaleMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTextureScaleMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                scaleMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the scale mode used for texture scale operations.
    ///
    /// @param texture the texture to query.
    /// @param scaleMode a pointer filled in with the current scale mode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setTextureScaleMode
    public @NativeType("boolean") boolean getTextureScaleMode(
        @Nullable SDL_Texture texture,
        @Nullable @EnumType(SDL_ScaleMode.class) IntPtr scaleMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTextureScaleMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (scaleMode != null ? scaleMode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update the given texture rectangle with new pixel data.
    ///
    /// The pixel data must be in the pixel format of the texture, which can be
    /// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.
    ///
    /// This is a fairly slow function, intended for use with static textures that
    /// do not change often.
    ///
    /// If the texture is intended to be updated often, it is preferred to create
    /// the texture as streaming and use the locking functions referenced below.
    /// While this function will work with streaming textures, for optimization
    /// reasons you may not get the pixels back if you lock the texture afterward.
    ///
    /// @param texture the texture to update.
    /// @param rect an SDL_Rect structure representing the area to update, or NULL
    /// to update the entire texture.
    /// @param pixels the raw pixel data in the format of the texture.
    /// @param pitch the number of bytes in a row of pixel data, including padding
    /// between lines.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockTexture
    /// @see #unlockTexture
    /// @see #updateNVTexture
    /// @see #updateYUVTexture
    public @NativeType("boolean") boolean updateTexture(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_Rect rect,
        @Pointer(comment="void*") MemorySegment pixels,
        int pitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                pixels,
                pitch
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update a rectangle within a planar YV12 or IYUV texture with new pixel
    /// data.
    ///
    /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
    /// block of Y and U/V planes in the proper order, but this function is
    /// available if your pixel data is not contiguous.
    ///
    /// @param texture the texture to update.
    /// @param rect a pointer to the rectangle of pixels to update, or NULL to
    /// update the entire texture.
    /// @param Yplane the raw pixel data for the Y plane.
    /// @param Ypitch the number of bytes between rows of pixel data for the Y
    /// plane.
    /// @param Uplane the raw pixel data for the U plane.
    /// @param Upitch the number of bytes between rows of pixel data for the U
    /// plane.
    /// @param Vplane the raw pixel data for the V plane.
    /// @param Vpitch the number of bytes between rows of pixel data for the V
    /// plane.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #updateNVTexture
    /// @see #updateTexture
    public @NativeType("boolean") boolean updateYUVTexture(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_Rect rect,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr Yplane,
        int Ypitch,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr Uplane,
        int Upitch,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr Vplane,
        int Vpitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateYUVTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (Yplane != null ? Yplane.segment() : MemorySegment.NULL),
                Ypitch,
                (MemorySegment) (Uplane != null ? Uplane.segment() : MemorySegment.NULL),
                Upitch,
                (MemorySegment) (Vplane != null ? Vplane.segment() : MemorySegment.NULL),
                Vpitch
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update a rectangle within a planar NV12 or NV21 texture with new pixels.
    ///
    /// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
    /// block of NV12/21 planes in the proper order, but this function is available
    /// if your pixel data is not contiguous.
    ///
    /// @param texture the texture to update.
    /// @param rect a pointer to the rectangle of pixels to update, or NULL to
    /// update the entire texture.
    /// @param Yplane the raw pixel data for the Y plane.
    /// @param Ypitch the number of bytes between rows of pixel data for the Y
    /// plane.
    /// @param UVplane the raw pixel data for the UV plane.
    /// @param UVpitch the number of bytes between rows of pixel data for the UV
    /// plane.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #updateTexture
    /// @see #updateYUVTexture
    public @NativeType("boolean") boolean updateNVTexture(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_Rect rect,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr Yplane,
        int Ypitch,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr UVplane,
        int UVpitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateNVTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (Yplane != null ? Yplane.segment() : MemorySegment.NULL),
                Ypitch,
                (MemorySegment) (UVplane != null ? UVplane.segment() : MemorySegment.NULL),
                UVpitch
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock a portion of the texture for **write-only** pixel access.
    ///
    /// As an optimization, the pixels made available for editing don't necessarily
    /// contain the old texture data. This is a write-only operation, and if you
    /// need to keep a copy of the texture data you should do that at the
    /// application level.
    ///
    /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
    /// changes.
    ///
    /// @param texture the texture to lock for access, which was created with
    /// `SDL_TEXTUREACCESS_STREAMING`.
    /// @param rect an SDL_Rect structure representing the area to lock for access;
    /// NULL to lock the entire texture.
    /// @param pixels this is filled in with a pointer to the locked pixels,
    /// appropriately offset by the locked area.
    /// @param pitch this is filled in with the pitch of the locked pixels; the
    /// pitch is the length of one row in bytes.
    /// @return true on success or false if the texture is not valid or was not
    /// created with `SDL_TEXTUREACCESS_STREAMING`; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockTextureToSurface
    /// @see #unlockTexture
    public @NativeType("boolean") boolean lockTexture(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_Rect rect,
        @Nullable PointerPtr pixels,
        @Nullable IntPtr pitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (pixels != null ? pixels.segment() : MemorySegment.NULL),
                (MemorySegment) (pitch != null ? pitch.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Lock a portion of the texture for **write-only** pixel access, and expose
    /// it as a SDL surface.
    ///
    /// Besides providing an SDL_Surface instead of raw pixel data, this function
    /// operates like SDL_LockTexture.
    ///
    /// As an optimization, the pixels made available for editing don't necessarily
    /// contain the old texture data. This is a write-only operation, and if you
    /// need to keep a copy of the texture data you should do that at the
    /// application level.
    ///
    /// You must use SDL_UnlockTexture() to unlock the pixels and apply any
    /// changes.
    ///
    /// The returned surface is freed internally after calling SDL_UnlockTexture()
    /// or SDL_DestroyTexture(). The caller should not free it.
    ///
    /// @param texture the texture to lock for access, which must be created with
    /// `SDL_TEXTUREACCESS_STREAMING`.
    /// @param rect a pointer to the rectangle to lock for access. If the rect is
    /// NULL, the entire texture will be locked.
    /// @param surface a pointer to an SDL surface of size **rect**. Don't assume
    /// any specific pixel content.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockTexture
    /// @see #unlockTexture
    public @NativeType("boolean") boolean lockTextureToSurface(
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_Rect rect,
        @Nullable @Pointer SDL_Surface.Ptr surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockTextureToSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unlock a texture, uploading the changes to video memory, if needed.
    ///
    /// **Warning**: Please note that SDL_LockTexture() is intended to be
    /// write-only; it will not guarantee the previous contents of the texture will
    /// be provided. You must fully initialize any area of a texture that you lock
    /// before unlocking it, as the pixels might otherwise be uninitialized memory.
    ///
    /// Which is to say: locking and immediately unlocking a texture can result in
    /// corrupted textures, depending on the renderer in use.
    ///
    /// @param texture a texture locked by SDL_LockTexture().
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockTexture
    public void unlockTexture(
        @Nullable SDL_Texture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a texture as the current rendering target.
    ///
    /// The default render target is the window for which the renderer was created.
    /// To stop rendering to a texture and render to the window again, call this
    /// function with a NULL `texture`.
    ///
    /// Viewport, cliprect, scale, and logical presentation are unique to each
    /// render target. Get and set functions for these states apply to the current
    /// render target set by this function, and those states persist on each target
    /// when the current render target changes.
    ///
    /// @param renderer the rendering context.
    /// @param texture the targeted texture, which must be created with the
    /// `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
    /// window instead of a texture.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderTarget
    public @NativeType("boolean") boolean setRenderTarget(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderTarget);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current render target.
    ///
    /// The default render target is the window for which the renderer was created,
    /// and is reported a NULL here.
    ///
    /// @param renderer the rendering context.
    /// @return the current render target or NULL for the default render target.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderTarget
    public SDL_Texture getRenderTarget(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderTarget);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Texture(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a device-independent resolution and presentation mode for rendering.
    ///
    /// This function sets the width and height of the logical rendering output.
    /// The renderer will act as if the current render target is always the
    /// requested dimensions, scaling to the actual resolution as necessary.
    ///
    /// This can be useful for games that expect a fixed size, but would like to
    /// scale the output to whatever is available, regardless of how a user resizes
    /// a window, or if the display is high DPI.
    ///
    /// Logical presentation can be used with both render target textures and the
    /// renderer's window; the state is unique to each render target, and this
    /// function sets the state for the current render target. It might be useful
    /// to draw to a texture that matches the window dimensions with logical
    /// presentation enabled, and then draw that texture across the entire window
    /// with logical presentation disabled. Be careful not to render both with
    /// logical presentation enabled, however, as this could produce
    /// double-letterboxing, etc.
    ///
    /// You can disable logical coordinates by setting the mode to
    /// SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel
    /// resolution of the render target; it is safe to toggle logical presentation
    /// during the rendering of a frame: perhaps most of the rendering is done to
    /// specific dimensions but to make fonts look sharp, the app turns off logical
    /// presentation while drawing text, for example.
    ///
    /// For the renderer's window, letterboxing is drawn into the framebuffer if
    /// logical presentation is enabled during SDL_RenderPresent; be sure to
    /// reenable it before presenting if you were toggling it, otherwise the
    /// letterbox areas might have artifacts from previous frames (or artifacts
    /// from external overlays, etc). Letterboxing is never drawn into texture
    /// render targets; be sure to call SDL_RenderClear() before drawing into the
    /// texture so the letterboxing areas are cleared, if appropriate.
    ///
    /// You can convert coordinates in an event into rendering coordinates using
    /// SDL_ConvertEventToRenderCoordinates().
    ///
    /// @param renderer the rendering context.
    /// @param w the width of the logical resolution.
    /// @param h the height of the logical resolution.
    /// @param mode the presentation mode used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #convertEventToRenderCoordinates
    /// @see #getRenderLogicalPresentation
    /// @see #getRenderLogicalPresentationRect
    public @NativeType("boolean") boolean setRenderLogicalPresentation(
        @Nullable SDL_Renderer renderer,
        int w,
        int h,
        @EnumType(SDL_RendererLogicalPresentation.class) int mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderLogicalPresentation);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                w,
                h,
                mode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get device independent resolution and presentation mode for rendering.
    ///
    /// This function gets the width and height of the logical rendering output, or
    /// the output size in pixels if a logical resolution is not enabled.
    ///
    /// Each render target has its own logical presentation state. This function
    /// gets the state for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @param w an int to be filled with the width.
    /// @param h an int to be filled with the height.
    /// @param mode the presentation mode used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderLogicalPresentation
    public @NativeType("boolean") boolean getRenderLogicalPresentation(
        @Nullable SDL_Renderer renderer,
        @Nullable IntPtr w,
        @Nullable IntPtr h,
        @Nullable @EnumType(SDL_RendererLogicalPresentation.class) IntPtr mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderLogicalPresentation);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL),
                (MemorySegment) (mode != null ? mode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the final presentation rectangle for rendering.
    ///
    /// This function returns the calculated rectangle used for logical
    /// presentation, based on the presentation mode and output size. If logical
    /// presentation is disabled, it will fill the rectangle with the output size,
    /// in pixels.
    ///
    /// Each render target has its own logical presentation state. This function
    /// gets the rectangle for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @param rect a pointer filled in with the final presentation rectangle, may
    /// be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderLogicalPresentation
    public @NativeType("boolean") boolean getRenderLogicalPresentationRect(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FRect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderLogicalPresentationRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a point in render coordinates when given a point in window coordinates.
    ///
    /// This takes into account several states:
    ///
    /// - The window dimensions.
    /// - The logical presentation settings (SDL_SetRenderLogicalPresentation)
    /// - The scale (SDL_SetRenderScale)
    /// - The viewport (SDL_SetRenderViewport)
    ///
    /// @param renderer the rendering context.
    /// @param window_x the x coordinate in window coordinates.
    /// @param window_y the y coordinate in window coordinates.
    /// @param x a pointer filled with the x coordinate in render coordinates.
    /// @param y a pointer filled with the y coordinate in render coordinates.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderLogicalPresentation
    /// @see #setRenderScale
    public @NativeType("boolean") boolean renderCoordinatesFromWindow(
        @Nullable SDL_Renderer renderer,
        float window_x,
        float window_y,
        @Nullable FloatPtr x,
        @Nullable FloatPtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderCoordinatesFromWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                window_x,
                window_y,
                (MemorySegment) (x != null ? x.segment() : MemorySegment.NULL),
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a point in window coordinates when given a point in render coordinates.
    ///
    /// This takes into account several states:
    ///
    /// - The window dimensions.
    /// - The logical presentation settings (SDL_SetRenderLogicalPresentation)
    /// - The scale (SDL_SetRenderScale)
    /// - The viewport (SDL_SetRenderViewport)
    ///
    /// @param renderer the rendering context.
    /// @param x the x coordinate in render coordinates.
    /// @param y the y coordinate in render coordinates.
    /// @param window_x a pointer filled with the x coordinate in window
    /// coordinates.
    /// @param window_y a pointer filled with the y coordinate in window
    /// coordinates.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderLogicalPresentation
    /// @see #setRenderScale
    /// @see #setRenderViewport
    public @NativeType("boolean") boolean renderCoordinatesToWindow(
        @Nullable SDL_Renderer renderer,
        float x,
        float y,
        @Nullable FloatPtr window_x,
        @Nullable FloatPtr window_y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderCoordinatesToWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                x,
                y,
                (MemorySegment) (window_x != null ? window_x.segment() : MemorySegment.NULL),
                (MemorySegment) (window_y != null ? window_y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Convert the coordinates in an event to render coordinates.
    ///
    /// This takes into account several states:
    ///
    /// - The window dimensions.
    /// - The logical presentation settings (SDL_SetRenderLogicalPresentation)
    /// - The scale (SDL_SetRenderScale)
    /// - The viewport (SDL_SetRenderViewport)
    ///
    /// Various event types are converted with this function: mouse, touch, pen,
    /// etc.
    ///
    /// Touch coordinates are converted from normalized coordinates in the window
    /// to non-normalized rendering coordinates.
    ///
    /// Relative mouse coordinates (xrel and yrel event fields) are _also_
    /// converted. Applications that do not want these fields converted should use
    /// SDL_RenderCoordinatesFromWindow() on the specific event fields instead of
    /// converting the entire event structure.
    ///
    /// Once converted, coordinates may be outside the rendering area.
    ///
    /// @param renderer the rendering context.
    /// @param event the event to modify.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderCoordinatesFromWindow
    public @NativeType("boolean") boolean convertEventToRenderCoordinates(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Event event
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ConvertEventToRenderCoordinates);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (event != null ? event.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the drawing area for rendering on the current target.
    ///
    /// Drawing will clip to this area (separately from any clipping done with
    /// SDL_SetRenderClipRect), and the top left of the area will become coordinate
    /// (0, 0) for future drawing commands.
    ///
    /// The area's width and height must be &amp;gt;= 0.
    ///
    /// Each render target has its own viewport. This function sets the viewport
    /// for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @param rect the SDL_Rect structure representing the drawing area, or NULL
    /// to set the viewport to the entire target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderViewport
    /// @see #renderViewportSet
    public @NativeType("boolean") boolean setRenderViewport(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderViewport);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the drawing area for the current target.
    ///
    /// Each render target has its own viewport. This function gets the viewport
    /// for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @param rect an SDL_Rect structure filled in with the current drawing area.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderViewportSet
    /// @see #setRenderViewport
    public @NativeType("boolean") boolean getRenderViewport(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderViewport);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether an explicit rectangle was set as the viewport.
    ///
    /// This is useful if you're saving and restoring the viewport and want to know
    /// whether you should restore a specific rectangle or NULL.
    ///
    /// Each render target has its own viewport. This function checks the viewport
    /// for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @return true if the viewport was set to a specific rectangle, or false if
    /// it was set to NULL (the entire target).
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderViewport
    /// @see #setRenderViewport
    public @NativeType("boolean") boolean renderViewportSet(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderViewportSet);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the safe area for rendering within the current viewport.
    ///
    /// Some devices have portions of the screen which are partially obscured or
    /// not interactive, possibly due to on-screen controls, curved edges, camera
    /// notches, TV overscan, etc. This function provides the area of the current
    /// viewport which is safe to have interactible content. You should continue
    /// rendering into the rest of the render target, but it should not contain
    /// visually important or interactible content.
    ///
    /// @param renderer the rendering context.
    /// @param rect a pointer filled in with the area that is safe for interactive
    /// content.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getRenderSafeArea(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderSafeArea);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the clip rectangle for rendering on the specified target.
    ///
    /// Each render target has its own clip rectangle. This function sets the
    /// cliprect for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @param rect an SDL_Rect structure representing the clip area, relative to
    /// the viewport, or NULL to disable clipping.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderClipRect
    /// @see #renderClipEnabled
    public @NativeType("boolean") boolean setRenderClipRect(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderClipRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the clip rectangle for the current target.
    ///
    /// Each render target has its own clip rectangle. This function gets the
    /// cliprect for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @param rect an SDL_Rect structure filled in with the current clipping area
    /// or an empty rectangle if clipping is disabled.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderClipEnabled
    /// @see #setRenderClipRect
    public @NativeType("boolean") boolean getRenderClipRect(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderClipRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get whether clipping is enabled on the given render target.
    ///
    /// Each render target has its own clip rectangle. This function checks the
    /// cliprect for the current render target.
    ///
    /// @param renderer the rendering context.
    /// @return true if clipping is enabled or false if not; call SDL_GetError()
    /// for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderClipRect
    /// @see #setRenderClipRect
    public @NativeType("boolean") boolean renderClipEnabled(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderClipEnabled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the drawing scale for rendering on the current target.
    ///
    /// The drawing coordinates are scaled by the x/y scaling factors before they
    /// are used by the renderer. This allows resolution independent drawing with a
    /// single coordinate system.
    ///
    /// If this results in scaling or subpixel drawing by the rendering backend, it
    /// will be handled using the appropriate quality hints. For best results use
    /// integer scaling factors.
    ///
    /// Each render target has its own scale. This function sets the scale for the
    /// current render target.
    ///
    /// @param renderer the rendering context.
    /// @param scaleX the horizontal scaling factor.
    /// @param scaleY the vertical scaling factor.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderScale
    public @NativeType("boolean") boolean setRenderScale(
        @Nullable SDL_Renderer renderer,
        float scaleX,
        float scaleY
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderScale);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                scaleX,
                scaleY
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the drawing scale for the current target.
    ///
    /// Each render target has its own scale. This function gets the scale for the
    /// current render target.
    ///
    /// @param renderer the rendering context.
    /// @param scaleX a pointer filled in with the horizontal scaling factor.
    /// @param scaleY a pointer filled in with the vertical scaling factor.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderScale
    public @NativeType("boolean") boolean getRenderScale(
        @Nullable SDL_Renderer renderer,
        @Nullable FloatPtr scaleX,
        @Nullable FloatPtr scaleY
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderScale);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (scaleX != null ? scaleX.segment() : MemorySegment.NULL),
                (MemorySegment) (scaleY != null ? scaleY.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the color used for drawing operations.
    ///
    /// Set the color for drawing or filling rectangles, lines, and points, and for
    /// SDL_RenderClear().
    ///
    /// @param renderer the rendering context.
    /// @param r the red value used to draw on the rendering target.
    /// @param g the green value used to draw on the rendering target.
    /// @param b the blue value used to draw on the rendering target.
    /// @param a the alpha value used to draw on the rendering target; usually
    /// `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
    /// specify how the alpha channel is used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderDrawColor
    /// @see #setRenderDrawColorFloat
    public @NativeType("boolean") boolean setRenderDrawColor(
        @Nullable SDL_Renderer renderer,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b,
        @NativeType("Uint8") @Unsigned byte a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderDrawColor);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the color used for drawing operations (Rect, Line and Clear).
    ///
    /// Set the color for drawing or filling rectangles, lines, and points, and for
    /// SDL_RenderClear().
    ///
    /// @param renderer the rendering context.
    /// @param r the red value used to draw on the rendering target.
    /// @param g the green value used to draw on the rendering target.
    /// @param b the blue value used to draw on the rendering target.
    /// @param a the alpha value used to draw on the rendering target. Use
    /// SDL_SetRenderDrawBlendMode to specify how the alpha channel is
    /// used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderDrawColorFloat
    /// @see #setRenderDrawColor
    public @NativeType("boolean") boolean setRenderDrawColorFloat(
        @Nullable SDL_Renderer renderer,
        float r,
        float g,
        float b,
        float a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderDrawColorFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the color used for drawing operations (Rect, Line and Clear).
    ///
    /// @param renderer the rendering context.
    /// @param r a pointer filled in with the red value used to draw on the
    /// rendering target.
    /// @param g a pointer filled in with the green value used to draw on the
    /// rendering target.
    /// @param b a pointer filled in with the blue value used to draw on the
    /// rendering target.
    /// @param a a pointer filled in with the alpha value used to draw on the
    /// rendering target; usually `SDL_ALPHA_OPAQUE` (255).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderDrawColorFloat
    /// @see #setRenderDrawColor
    public @NativeType("boolean") boolean getRenderDrawColor(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr r,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr g,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr b,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderDrawColor);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL),
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the color used for drawing operations (Rect, Line and Clear).
    ///
    /// @param renderer the rendering context.
    /// @param r a pointer filled in with the red value used to draw on the
    /// rendering target.
    /// @param g a pointer filled in with the green value used to draw on the
    /// rendering target.
    /// @param b a pointer filled in with the blue value used to draw on the
    /// rendering target.
    /// @param a a pointer filled in with the alpha value used to draw on the
    /// rendering target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderDrawColorFloat
    /// @see #getRenderDrawColor
    public @NativeType("boolean") boolean getRenderDrawColorFloat(
        @Nullable SDL_Renderer renderer,
        @Nullable FloatPtr r,
        @Nullable FloatPtr g,
        @Nullable FloatPtr b,
        @Nullable FloatPtr a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderDrawColorFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL),
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the color scale used for render operations.
    ///
    /// The color scale is an additional scale multiplied into the pixel color
    /// value while rendering. This can be used to adjust the brightness of colors
    /// during HDR rendering, or changing HDR video brightness when playing on an
    /// SDR display.
    ///
    /// The color scale does not affect the alpha channel, only the color
    /// brightness.
    ///
    /// @param renderer the rendering context.
    /// @param scale the color scale value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderColorScale
    public @NativeType("boolean") boolean setRenderColorScale(
        @Nullable SDL_Renderer renderer,
        float scale
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderColorScale);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                scale
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the color scale used for render operations.
    ///
    /// @param renderer the rendering context.
    /// @param scale a pointer filled in with the current color scale value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderColorScale
    public @NativeType("boolean") boolean getRenderColorScale(
        @Nullable SDL_Renderer renderer,
        @Nullable FloatPtr scale
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderColorScale);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (scale != null ? scale.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the blend mode used for drawing operations (Fill and Line).
    ///
    /// If the blend mode is not supported, the closest supported mode is chosen.
    ///
    /// @param renderer the rendering context.
    /// @param blendMode the SDL_BlendMode to use for blending.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderDrawBlendMode
    public @NativeType("boolean") boolean setRenderDrawBlendMode(
        @Nullable SDL_Renderer renderer,
        @EnumType(SDL_BlendMode.class) int blendMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderDrawBlendMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                blendMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the blend mode used for drawing operations.
    ///
    /// @param renderer the rendering context.
    /// @param blendMode a pointer filled in with the current SDL_BlendMode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderDrawBlendMode
    public @NativeType("boolean") boolean getRenderDrawBlendMode(
        @Nullable SDL_Renderer renderer,
        @Nullable @EnumType(SDL_BlendMode.class) IntPtr blendMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderDrawBlendMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (blendMode != null ? blendMode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear the current rendering target with the drawing color.
    ///
    /// This function clears the entire rendering target, ignoring the viewport and
    /// the clip rectangle. Note, that clearing will also set/fill all pixels of
    /// the rendering target to current renderer draw color, so make sure to invoke
    /// SDL_SetRenderDrawColor() when needed.
    ///
    /// @param renderer the rendering context.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderDrawColor
    public @NativeType("boolean") boolean renderClear(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderClear);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw a point on the current rendering target at subpixel precision.
    ///
    /// @param renderer the renderer which should draw a point.
    /// @param x the x coordinate of the point.
    /// @param y the y coordinate of the point.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderPoints
    public @NativeType("boolean") boolean renderPoint(
        @Nullable SDL_Renderer renderer,
        float x,
        float y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderPoint);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw multiple points on the current rendering target at subpixel precision.
    ///
    /// @param renderer the renderer which should draw multiple points.
    /// @param points the points to draw.
    /// @param count the number of points to draw.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderPoint
    public @NativeType("boolean") boolean renderPoints(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FPoint points,
        int count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderPoints);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (points != null ? points.segment() : MemorySegment.NULL),
                count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw a line on the current rendering target at subpixel precision.
    ///
    /// @param renderer the renderer which should draw a line.
    /// @param x1 the x coordinate of the start point.
    /// @param y1 the y coordinate of the start point.
    /// @param x2 the x coordinate of the end point.
    /// @param y2 the y coordinate of the end point.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderLines
    public @NativeType("boolean") boolean renderLine(
        @Nullable SDL_Renderer renderer,
        float x1,
        float y1,
        float x2,
        float y2
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderLine);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                x1,
                y1,
                x2,
                y2
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw a series of connected lines on the current rendering target at
    /// subpixel precision.
    ///
    /// @param renderer the renderer which should draw multiple lines.
    /// @param points the points along the lines.
    /// @param count the number of points, drawing count-1 lines.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderLine
    public @NativeType("boolean") boolean renderLines(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FPoint points,
        int count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderLines);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (points != null ? points.segment() : MemorySegment.NULL),
                count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw a rectangle on the current rendering target at subpixel precision.
    ///
    /// @param renderer the renderer which should draw a rectangle.
    /// @param rect a pointer to the destination rectangle, or NULL to outline the
    /// entire rendering target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderRects
    public @NativeType("boolean") boolean renderRect(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FRect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw some number of rectangles on the current rendering target at subpixel
    /// precision.
    ///
    /// @param renderer the renderer which should draw multiple rectangles.
    /// @param rects a pointer to an array of destination rectangles.
    /// @param count the number of rectangles.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderRect
    public @NativeType("boolean") boolean renderRects(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FRect rects,
        int count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderRects);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rects != null ? rects.segment() : MemorySegment.NULL),
                count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Fill a rectangle on the current rendering target with the drawing color at
    /// subpixel precision.
    ///
    /// @param renderer the renderer which should fill a rectangle.
    /// @param rect a pointer to the destination rectangle, or NULL for the entire
    /// rendering target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderFillRects
    public @NativeType("boolean") boolean renderFillRect(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FRect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderFillRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Fill some number of rectangles on the current rendering target with the
    /// drawing color at subpixel precision.
    ///
    /// @param renderer the renderer which should fill multiple rectangles.
    /// @param rects a pointer to an array of destination rectangles.
    /// @param count the number of rectangles.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderFillRect
    public @NativeType("boolean") boolean renderFillRects(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_FRect rects,
        int count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderFillRects);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rects != null ? rects.segment() : MemorySegment.NULL),
                count
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a portion of the texture to the current rendering target at subpixel
    /// precision.
    ///
    /// @param renderer the renderer which should copy parts of a texture.
    /// @param texture the source texture.
    /// @param srcrect a pointer to the source rectangle, or NULL for the entire
    /// texture.
    /// @param dstrect a pointer to the destination rectangle, or NULL for the
    /// entire rendering target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderTextureRotated
    /// @see #renderTextureTiled
    public @NativeType("boolean") boolean renderTexture(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_FRect srcrect,
        @Nullable @Pointer ISDL_FRect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderTexture);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a portion of the source texture to the current rendering target, with
    /// rotation and flipping, at subpixel precision.
    ///
    /// @param renderer the renderer which should copy parts of a texture.
    /// @param texture the source texture.
    /// @param srcrect a pointer to the source rectangle, or NULL for the entire
    /// texture.
    /// @param dstrect a pointer to the destination rectangle, or NULL for the
    /// entire rendering target.
    /// @param angle an angle in degrees that indicates the rotation that will be
    /// applied to dstrect, rotating it in a clockwise direction.
    /// @param center a pointer to a point indicating the point around which
    /// dstrect will be rotated (if NULL, rotation will be done
    /// around dstrect.w/2, dstrect.h/2).
    /// @param flip an SDL_FlipMode value stating which flipping actions should be
    /// performed on the texture.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderTexture
    public @NativeType("boolean") boolean renderTextureRotated(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_FRect srcrect,
        @Nullable @Pointer ISDL_FRect dstrect,
        double angle,
        @Nullable @Pointer ISDL_FPoint center,
        @EnumType(SDL_FlipMode.class) int flip
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderTextureRotated);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL),
                angle,
                (MemorySegment) (center != null ? center.segment() : MemorySegment.NULL),
                flip
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a portion of the source texture to the current rendering target, with
    /// affine transform, at subpixel precision.
    ///
    /// @param renderer the renderer which should copy parts of a texture.
    /// @param texture the source texture.
    /// @param srcrect a pointer to the source rectangle, or NULL for the entire
    /// texture.
    /// @param origin a pointer to a point indicating where the top-left corner of
    /// srcrect should be mapped to, or NULL for the rendering
    /// target's origin.
    /// @param right a pointer to a point indicating where the top-right corner of
    /// srcrect should be mapped to, or NULL for the rendering
    /// target's top-right corner.
    /// @param down a pointer to a point indicating where the bottom-left corner of
    /// srcrect should be mapped to, or NULL for the rendering target's
    /// bottom-left corner.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety You may only call this function from the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderTexture
    public @NativeType("boolean") boolean renderTextureAffine(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_FRect srcrect,
        @Nullable @Pointer ISDL_FPoint origin,
        @Nullable @Pointer ISDL_FPoint right,
        @Nullable @Pointer ISDL_FPoint down
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderTextureAffine);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (origin != null ? origin.segment() : MemorySegment.NULL),
                (MemorySegment) (right != null ? right.segment() : MemorySegment.NULL),
                (MemorySegment) (down != null ? down.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Tile a portion of the texture to the current rendering target at subpixel
    /// precision.
    ///
    /// The pixels in `srcrect` will be repeated as many times as needed to
    /// completely fill `dstrect`.
    ///
    /// @param renderer the renderer which should copy parts of a texture.
    /// @param texture the source texture.
    /// @param srcrect a pointer to the source rectangle, or NULL for the entire
    /// texture.
    /// @param scale the scale used to transform srcrect into the destination
    /// rectangle, e.g. a 32x32 texture with a scale of 2 would fill
    /// 64x64 tiles.
    /// @param dstrect a pointer to the destination rectangle, or NULL for the
    /// entire rendering target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderTexture
    public @NativeType("boolean") boolean renderTextureTiled(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_FRect srcrect,
        float scale,
        @Nullable @Pointer ISDL_FRect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderTextureTiled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                scale,
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a scaled copy using the 9-grid algorithm to the current rendering
    /// target at subpixel precision.
    ///
    /// The pixels in the texture are split into a 3x3 grid, using the different
    /// corner sizes for each corner, and the sides and center making up the
    /// remaining pixels. The corners are then scaled using `scale` and fit into
    /// the corners of the destination rectangle. The sides and center are then
    /// stretched into place to cover the remaining destination rectangle.
    ///
    /// @param renderer the renderer which should copy parts of a texture.
    /// @param texture the source texture.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be used
    /// for the 9-grid, or NULL to use the entire texture.
    /// @param left_width the width, in pixels, of the left corners in `srcrect`.
    /// @param right_width the width, in pixels, of the right corners in `srcrect`.
    /// @param top_height the height, in pixels, of the top corners in `srcrect`.
    /// @param bottom_height the height, in pixels, of the bottom corners in
    /// `srcrect`.
    /// @param scale the scale used to transform the corner of `srcrect` into the
    /// corner of `dstrect`, or 0.0f for an unscaled copy.
    /// @param dstrect a pointer to the destination rectangle, or NULL for the
    /// entire rendering target.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderTexture
    public @NativeType("boolean") boolean renderTexture9Grid(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_FRect srcrect,
        float left_width,
        float right_width,
        float top_height,
        float bottom_height,
        float scale,
        @Nullable @Pointer ISDL_FRect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderTexture9Grid);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                left_width,
                right_width,
                top_height,
                bottom_height,
                scale,
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Render a list of triangles, optionally using a texture and indices into the
    /// vertex array Color and alpha modulation is done per vertex
    /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
    ///
    /// @param renderer the rendering context.
    /// @param texture (optional) The SDL texture to use.
    /// @param vertices vertices.
    /// @param num_vertices number of vertices.
    /// @param indices (optional) An array of integer indices into the 'vertices'
    /// array, if NULL all vertices will be rendered in sequential
    /// order.
    /// @param num_indices number of indices.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderGeometryRaw
    public @NativeType("boolean") boolean renderGeometry(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable @Pointer ISDL_Vertex vertices,
        int num_vertices,
        @Nullable IntPtr indices,
        int num_indices
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderGeometry);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (vertices != null ? vertices.segment() : MemorySegment.NULL),
                num_vertices,
                (MemorySegment) (indices != null ? indices.segment() : MemorySegment.NULL),
                num_indices
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Render a list of triangles, optionally using a texture and indices into the
    /// vertex arrays Color and alpha modulation is done per vertex
    /// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
    ///
    /// @param renderer the rendering context.
    /// @param texture (optional) The SDL texture to use.
    /// @param xy vertex positions.
    /// @param xy_stride byte size to move from one element to the next element.
    /// @param color vertex colors (as SDL_FColor).
    /// @param color_stride byte size to move from one element to the next element.
    /// @param uv vertex normalized texture coordinates.
    /// @param uv_stride byte size to move from one element to the next element.
    /// @param num_vertices number of vertices.
    /// @param indices (optional) An array of indices into the 'vertices' arrays,
    /// if NULL all vertices will be rendered in sequential order.
    /// @param num_indices number of indices.
    /// @param size_indices index size: 1 (byte), 2 (short), 4 (int).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderGeometry
    public @NativeType("boolean") boolean renderGeometryRaw(
        @Nullable SDL_Renderer renderer,
        @Nullable SDL_Texture texture,
        @Nullable FloatPtr xy,
        int xy_stride,
        @Nullable @Pointer ISDL_FColor color,
        int color_stride,
        @Nullable FloatPtr uv,
        int uv_stride,
        int num_vertices,
        @Pointer(comment="void*") MemorySegment indices,
        int num_indices,
        int size_indices
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderGeometryRaw);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL),
                (MemorySegment) (xy != null ? xy.segment() : MemorySegment.NULL),
                xy_stride,
                (MemorySegment) (color != null ? color.segment() : MemorySegment.NULL),
                color_stride,
                (MemorySegment) (uv != null ? uv.segment() : MemorySegment.NULL),
                uv_stride,
                num_vertices,
                indices,
                num_indices,
                size_indices
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Read pixels from the current rendering target.
    ///
    /// The returned surface contains pixels inside the desired area clipped to the
    /// current viewport, and should be freed with SDL_DestroySurface().
    ///
    /// Note that this returns the actual pixels on the screen, so if you are using
    /// logical presentation you should use SDL_GetRenderLogicalPresentationRect()
    /// to get the area containing your content.
    ///
    /// **WARNING**: This is a very slow operation, and should not be used
    /// frequently. If you're using this on the main rendering target, it should be
    /// called after rendering and before SDL_RenderPresent().
    ///
    /// @param renderer the rendering context.
    /// @param rect an SDL_Rect structure representing the area to read, which will
    /// be clipped to the current viewport, or NULL for the entire
    /// viewport.
    /// @return a new SDL_Surface on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Surface renderReadPixels(
        @Nullable SDL_Renderer renderer,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderReadPixels);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update the screen with any rendering performed since the previous call.
    ///
    /// SDL's rendering functions operate on a backbuffer; that is, calling a
    /// rendering function such as SDL_RenderLine() does not directly put a line on
    /// the screen, but rather updates the backbuffer. As such, you compose your
    /// entire scene and *present* the composed backbuffer to the screen as a
    /// complete picture.
    ///
    /// Therefore, when using SDL's rendering API, one does all drawing intended
    /// for the frame, and then calls this function once per frame to present the
    /// final drawing to the user.
    ///
    /// The backbuffer should be considered invalidated after each present; do not
    /// assume that previous contents will exist between frames. You are strongly
    /// encouraged to call SDL_RenderClear() to initialize the backbuffer before
    /// starting each new frame's drawing, even if you plan to overwrite every
    /// pixel.
    ///
    /// Please note, that in case of rendering to a texture - there is **no need**
    /// to call `SDL_RenderPresent` after drawing needed objects to a texture, and
    /// should not be done; you are only required to change back the rendering
    /// target to default via `SDL_SetRenderTarget(renderer, NULL)` afterwards, as
    /// textures by themselves do not have a concept of backbuffers. Calling
    /// SDL_RenderPresent while rendering to a texture will still update the screen
    /// with any current drawing that has been done _to the window itself_.
    ///
    /// @param renderer the rendering context.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRenderer
    /// @see #renderClear
    /// @see #renderFillRect
    /// @see #renderFillRects
    /// @see #renderLine
    /// @see #renderLines
    /// @see #renderPoint
    /// @see #renderPoints
    /// @see #renderRect
    /// @see #renderRects
    /// @see #setRenderDrawBlendMode
    /// @see #setRenderDrawColor
    public @NativeType("boolean") boolean renderPresent(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderPresent);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy the specified texture.
    ///
    /// Passing NULL or an otherwise invalid texture will set the SDL error message
    /// to "Invalid texture".
    ///
    /// @param texture the texture to destroy.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTexture
    /// @see #createTextureFromSurface
    public void destroyTexture(
        @Nullable SDL_Texture texture
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyTexture);
        try {
            hFunction.invokeExact(
                (MemorySegment) (texture != null ? texture.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy the rendering context for a window and free all associated
    /// textures.
    ///
    /// This should be called before destroying the associated window.
    ///
    /// @param renderer the rendering context.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createRenderer
    public void destroyRenderer(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyRenderer);
        try {
            hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Force the rendering context to flush any pending commands and state.
    ///
    /// You do not need to (and in fact, shouldn't) call this function unless you
    /// are planning to call into OpenGL/Direct3D/Metal/whatever directly, in
    /// addition to using an SDL_Renderer.
    ///
    /// This is for a very-specific case: if you are using SDL's render API, and
    /// you plan to make OpenGL/D3D/whatever calls in addition to SDL render API
    /// calls. If this applies, you should call this function between calls to
    /// SDL's render API and the low-level API you're using in cooperation.
    ///
    /// In all other cases, you can ignore this function.
    ///
    /// This call makes SDL flush any pending rendering work it was queueing up to
    /// do later in a single batch, and marks any internal cached state as invalid,
    /// so it'll prepare all its state again later, from scratch.
    ///
    /// This means you do not need to save state in your rendering code to protect
    /// the SDL renderer. However, there lots of arbitrary pieces of Direct3D and
    /// OpenGL state that can confuse things; you should use your best judgment and
    /// be prepared to make changes if specific state needs to be protected.
    ///
    /// @param renderer the rendering context.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean flushRenderer(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlushRenderer);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the CAMetalLayer associated with the given Metal renderer.
    ///
    /// This function returns `void *`, so SDL doesn't have to include Metal's
    /// headers, but it can be safely cast to a `CAMetalLayer *`.
    ///
    /// @param renderer the renderer to query.
    /// @return a `CAMetalLayer *` on success, or NULL if the renderer isn't a
    /// Metal renderer.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderMetalCommandEncoder
    public @Pointer(comment="void*") MemorySegment getRenderMetalLayer(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderMetalLayer);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the Metal command encoder for the current frame.
    ///
    /// This function returns `void *`, so SDL doesn't have to include Metal's
    /// headers, but it can be safely cast to an `id&amp;lt;MTLRenderCommandEncoder&amp;gt;`.
    ///
    /// This will return NULL if Metal refuses to give SDL a drawable to render to,
    /// which might happen if the window is hidden/minimized/offscreen. This
    /// doesn't apply to command encoders for render targets, just the window's
    /// backbuffer. Check your return values!
    ///
    /// @param renderer the renderer to query.
    /// @return an `id&amp;lt;MTLRenderCommandEncoder&amp;gt;` on success, or NULL if the
    /// renderer isn't a Metal renderer or there was an error.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderMetalLayer
    public @Pointer(comment="void*") MemorySegment getRenderMetalCommandEncoder(
        @Nullable SDL_Renderer renderer
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderMetalCommandEncoder);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add a set of synchronization semaphores for the current frame.
    ///
    /// The Vulkan renderer will wait for `wait_semaphore` before submitting
    /// rendering commands and signal `signal_semaphore` after rendering commands
    /// are complete for this frame.
    ///
    /// This should be called each frame that you want semaphore synchronization.
    /// The Vulkan renderer may have multiple frames in flight on the GPU, so you
    /// should have multiple semaphores that are used for synchronization. Querying
    /// SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the
    /// maximum number of semaphores you'll need.
    ///
    /// @param renderer the rendering context.
    /// @param wait_stage_mask the VkPipelineStageFlags for the wait.
    /// @param wait_semaphore a VkSempahore to wait on before rendering the current
    /// frame, or 0 if not needed.
    /// @param signal_semaphore a VkSempahore that SDL will signal when rendering
    /// for the current frame is complete, or 0 if not
    /// needed.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is **NOT** safe to call this function from two threads at
    /// once.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean addVulkanRenderSemaphores(
        @Nullable SDL_Renderer renderer,
        @NativeType("Uint32") @Unsigned int wait_stage_mask,
        @NativeType("Sint64") long wait_semaphore,
        @NativeType("Sint64") long signal_semaphore
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddVulkanRenderSemaphores);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                wait_stage_mask,
                wait_semaphore,
                signal_semaphore
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Toggle VSync of the given renderer.
    ///
    /// When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.
    ///
    /// The `vsync` parameter can be 1 to synchronize present with every vertical
    /// refresh, 2 to synchronize present with every second vertical refresh, etc.,
    /// SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or
    /// SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by
    /// every driver, so you should check the return value to see whether the
    /// requested setting is supported.
    ///
    /// @param renderer the renderer to toggle.
    /// @param vsync the vertical refresh sync interval.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderVSync
    public @NativeType("boolean") boolean setRenderVSync(
        @Nullable SDL_Renderer renderer,
        int vsync
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetRenderVSync);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                vsync
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get VSync of the given renderer.
    ///
    /// @param renderer the renderer to toggle.
    /// @param vsync an int filled with the current vertical refresh sync interval.
    /// See SDL_SetRenderVSync() for the meaning of the value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setRenderVSync
    public @NativeType("boolean") boolean getRenderVSync(
        @Nullable SDL_Renderer renderer,
        @Nullable IntPtr vsync
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRenderVSync);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                (MemorySegment) (vsync != null ? vsync.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Draw debug text to an SDL_Renderer.
    ///
    /// This function will render a string of text to an SDL_Renderer. Note that
    /// this is a convenience function for debugging, with severe limitations, and
    /// not intended to be used for production apps and games.
    ///
    /// Among these limitations:
    ///
    /// - It accepts UTF-8 strings, but will only renders ASCII characters.
    /// - It has a single, tiny size (8x8 pixels). One can use logical presentation
    /// or scaling to adjust it, but it will be blurry.
    /// - It uses a simple, hardcoded bitmap font. It does not allow different font
    /// selections and it does not support truetype, for proper scaling.
    /// - It does no word-wrapping and does not treat newline characters as a line
    /// break. If the text goes out of the window, it's gone.
    ///
    /// For serious text rendering, there are several good options, such as
    /// SDL_ttf, stb_truetype, or other external libraries.
    ///
    /// On first use, this will create an internal texture for rendering glyphs.
    /// This texture will live until the renderer is destroyed.
    ///
    /// The text is drawn in the color specified by SDL_SetRenderDrawColor().
    ///
    /// @param renderer the renderer which should draw a line of text.
    /// @param x the x coordinate where the top-left corner of the text will draw.
    /// @param y the y coordinate where the top-left corner of the text will draw.
    /// @param str the string to render.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #renderDebugTextFormat
    /// @see #DEBUG_TEXT_FONT_CHARACTER_SIZE
    public @NativeType("boolean") boolean renderDebugText(
        @Nullable SDL_Renderer renderer,
        float x,
        float y,
        @Nullable BytePtr str
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenderDebugText);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (renderer != null ? renderer.segment() : MemorySegment.NULL),
                x,
                y,
                (MemorySegment) (str != null ? str.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected sensors.
    ///
    /// @param count a pointer filled in with the number of sensors returned, may
    /// be NULL.
    /// @return a 0 terminated array of sensor instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="SDL_SensorID") @Unsigned IntPtr getSensors(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensors);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a sensor.
    ///
    /// This can be called before any sensors are opened.
    ///
    /// @param instance_id the sensor instance ID.
    /// @return the sensor name, or NULL if `instance_id` is not valid.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getSensorNameForID(
        @NativeType("SDL_SensorID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorNameForID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of a sensor.
    ///
    /// This can be called before any sensors are opened.
    ///
    /// @param instance_id the sensor instance ID.
    /// @return the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is
    /// not valid.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_SensorType.class) int getSensorTypeForID(
        @NativeType("SDL_SensorID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorTypeForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the platform dependent type of a sensor.
    ///
    /// This can be called before any sensors are opened.
    ///
    /// @param instance_id the sensor instance ID.
    /// @return the sensor platform dependent type, or -1 if `instance_id` is not
    /// valid.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getSensorNonPortableTypeForID(
        @NativeType("SDL_SensorID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorNonPortableTypeForID);
        try {
            return (int) hFunction.invokeExact(
                instance_id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Open a sensor for use.
    ///
    /// @param instance_id the sensor instance ID.
    /// @return an SDL_Sensor object or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Sensor openSensor(
        @NativeType("SDL_SensorID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenSensor);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Sensor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return the SDL_Sensor associated with an instance ID.
    ///
    /// @param instance_id the sensor instance ID.
    /// @return an SDL_Sensor object or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Sensor getSensorFromID(
        @NativeType("SDL_SensorID") @Unsigned int instance_id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorFromID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                instance_id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Sensor(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a sensor.
    ///
    /// @param sensor the SDL_Sensor object.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getSensorProperties(
        @Nullable SDL_Sensor sensor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the implementation dependent name of a sensor.
    ///
    /// @param sensor the SDL_Sensor object.
    /// @return the sensor name or NULL on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getSensorName(
        @Nullable SDL_Sensor sensor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of a sensor.
    ///
    /// @param sensor the SDL_Sensor object to inspect.
    /// @return the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
    /// NULL.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_SensorType.class) int getSensorType(
        @Nullable SDL_Sensor sensor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorType);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the platform dependent type of a sensor.
    ///
    /// @param sensor the SDL_Sensor object to inspect.
    /// @return the sensor platform dependent type, or -1 if `sensor` is NULL.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getSensorNonPortableType(
        @Nullable SDL_Sensor sensor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorNonPortableType);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the instance ID of a sensor.
    ///
    /// @param sensor the SDL_Sensor object to inspect.
    /// @return the sensor instance ID, or 0 on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_SensorID") @Unsigned int getSensorID(
        @Nullable SDL_Sensor sensor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorID);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of an opened sensor.
    ///
    /// The number of values and interpretation of the data is sensor dependent.
    ///
    /// @param sensor the SDL_Sensor object to query.
    /// @param data a pointer filled with the current sensor state.
    /// @param num_values the number of values to write to data.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getSensorData(
        @Nullable SDL_Sensor sensor,
        @Nullable FloatPtr data,
        int num_values
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSensorData);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL),
                (MemorySegment) (data != null ? data.segment() : MemorySegment.NULL),
                num_values
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Close a sensor previously opened with SDL_OpenSensor().
    ///
    /// @param sensor the SDL_Sensor object to close.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void closeSensor(
        @Nullable SDL_Sensor sensor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseSensor);
        try {
            hFunction.invokeExact(
                (MemorySegment) (sensor != null ? sensor.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update the current state of the open sensors.
    ///
    /// This is called automatically by the event loop if sensor events are
    /// enabled.
    ///
    /// This needs to be called from the thread that initialized the sensor
    /// subsystem.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void updateSensors() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateSensors);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Opens up a read-only container for the application's filesystem.
    ///
    /// @param override a path to override the backend's default title root.
    /// @param props a property list that may contain backend-specific information.
    /// @return a title storage container on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeStorage
    /// @see #getStorageFileSize
    /// @see #openUserStorage
    /// @see #readStorageFile
    public SDL_Storage openTitleStorage(
        @Nullable BytePtr override,
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenTitleStorage);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (override != null ? override.segment() : MemorySegment.NULL),
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Storage(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Opens up a container for a user's unique read/write filesystem.
    ///
    /// While title storage can generally be kept open throughout runtime, user
    /// storage should only be opened when the client is ready to read/write files.
    /// This allows the backend to properly batch file operations and flush them
    /// when the container has been closed; ensuring safe and optimal save I/O.
    ///
    /// @param org the name of your organization.
    /// @param app the name of your application.
    /// @param props a property list that may contain backend-specific information.
    /// @return a user storage container on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeStorage
    /// @see #getStorageFileSize
    /// @see #getStorageSpaceRemaining
    /// @see #openTitleStorage
    /// @see #readStorageFile
    /// @see #storageReady
    /// @see #writeStorageFile
    public SDL_Storage openUserStorage(
        @Nullable BytePtr org,
        @Nullable BytePtr app,
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenUserStorage);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (org != null ? org.segment() : MemorySegment.NULL),
                (MemorySegment) (app != null ? app.segment() : MemorySegment.NULL),
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Storage(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Opens up a container for local filesystem storage.
    ///
    /// This is provided for development and tools. Portable applications should
    /// use SDL_OpenTitleStorage() for access to game data and
    /// SDL_OpenUserStorage() for access to user data.
    ///
    /// @param path the base path prepended to all storage paths, or NULL for no
    /// base path.
    /// @return a filesystem storage container on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeStorage
    /// @see #getStorageFileSize
    /// @see #getStorageSpaceRemaining
    /// @see #openTitleStorage
    /// @see #openUserStorage
    /// @see #readStorageFile
    /// @see #writeStorageFile
    public SDL_Storage openFileStorage(
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenFileStorage);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Storage(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Opens up a container using a client-provided storage interface.
    ///
    /// Applications do not need to use this function unless they are providing
    /// their own SDL_Storage implementation. If you just need an SDL_Storage, you
    /// should use the built-in implementations in SDL, like SDL_OpenTitleStorage()
    /// or SDL_OpenUserStorage().
    ///
    /// This function makes a copy of `iface` and the caller does not need to keep
    /// it around after this call.
    ///
    /// @param iface the interface that implements this storage, initialized using
    /// SDL_INIT_INTERFACE().
    /// @param userdata the pointer that will be passed to the interface functions.
    /// @return a storage container on success or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #closeStorage
    /// @see #getStorageFileSize
    /// @see #getStorageSpaceRemaining
    /// @see `SDL_INIT_INTERFACE`
    /// @see #readStorageFile
    /// @see #storageReady
    /// @see #writeStorageFile
    public SDL_Storage openStorage(
        @Nullable @Pointer ISDL_StorageInterface iface,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OpenStorage);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (iface != null ? iface.segment() : MemorySegment.NULL),
                userdata
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Storage(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Closes and frees a storage container.
    ///
    /// @param storage a storage container to close.
    /// @return true if the container was freed with no errors, false otherwise;
    /// call SDL_GetError() for more information. Even if the function
    /// returns an error, the container data will be freed; the error is
    /// only for informational purposes.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #openFileStorage
    /// @see #openStorage
    /// @see #openTitleStorage
    /// @see #openUserStorage
    public @NativeType("boolean") boolean closeStorage(
        @Nullable SDL_Storage storage
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CloseStorage);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Checks if the storage container is ready to use.
    ///
    /// This function should be called in regular intervals until it returns true -
    /// however, it is not recommended to spinwait on this call, as the backend may
    /// depend on a synchronous message loop. You might instead poll this in your
    /// game's main loop while processing events and drawing a loading screen.
    ///
    /// @param storage a storage container to query.
    /// @return true if the container is ready, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean storageReady(
        @Nullable SDL_Storage storage
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StorageReady);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the size of a file within a storage container.
    ///
    /// @param storage a storage container to query.
    /// @param path the relative path of the file to query.
    /// @param length a pointer to be filled with the file's length.
    /// @return true if the file could be queried or false on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #readStorageFile
    /// @see #storageReady
    public @NativeType("boolean") boolean getStorageFileSize(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path,
        @Nullable @Pointer(comment="Uint64") @Unsigned LongPtr length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetStorageFileSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                (MemorySegment) (length != null ? length.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Synchronously read a file from a storage container into a client-provided
    /// buffer.
    ///
    /// The value of `length` must match the length of the file exactly; call
    /// SDL_GetStorageFileSize() to get this value. This behavior may be relaxed in
    /// a future release.
    ///
    /// @param storage a storage container to read from.
    /// @param path the relative path of the file to read.
    /// @param destination a client-provided buffer to read the file into.
    /// @param length the length of the destination buffer.
    /// @return true if the file was read or false on failure; call SDL_GetError()
    /// for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getStorageFileSize
    /// @see #storageReady
    /// @see #writeStorageFile
    public @NativeType("boolean") boolean readStorageFile(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path,
        @Pointer(comment="void*") MemorySegment destination,
        @NativeType("Uint64") @Unsigned long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadStorageFile);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                destination,
                length
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Synchronously write a file from client memory into a storage container.
    ///
    /// @param storage a storage container to write to.
    /// @param path the relative path of the file to write.
    /// @param source a client-provided buffer to write from.
    /// @param length the length of the source buffer.
    /// @return true if the file was written or false on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getStorageSpaceRemaining
    /// @see #readStorageFile
    /// @see #storageReady
    public @NativeType("boolean") boolean writeStorageFile(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path,
        @Pointer(comment="void*") MemorySegment source,
        @NativeType("Uint64") @Unsigned long length
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteStorageFile);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                source,
                length
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a directory in a writable storage container.
    ///
    /// @param storage a storage container.
    /// @param path the path of the directory to create.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    public @NativeType("boolean") boolean createStorageDirectory(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateStorageDirectory);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Enumerate a directory in a storage container through a callback function.
    ///
    /// This function provides every directory entry through an app-provided
    /// callback, called once for each directory entry, until all results have been
    /// provided or the callback returns either SDL_ENUM_SUCCESS or
    /// SDL_ENUM_FAILURE.
    ///
    /// This will return false if there was a system problem in general, or if a
    /// callback returns SDL_ENUM_FAILURE. A successful return means a callback
    /// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
    /// were enumerated.
    ///
    /// If `path` is NULL, this is treated as a request to enumerate the root of
    /// the storage container's tree. An empty string also works for this.
    ///
    /// @param storage a storage container.
    /// @param path the path of the directory to enumerate, or NULL for the root.
    /// @param callback a function that is called for each entry in the directory.
    /// @param userdata a pointer that is passed to `callback`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    public @NativeType("boolean") boolean enumerateStorageDirectory(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path,
        @Pointer(comment="SDL_EnumerateDirectoryCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EnumerateStorageDirectory);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Remove a file or an empty directory in a writable storage container.
    ///
    /// @param storage a storage container.
    /// @param path the path of the directory to enumerate.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    public @NativeType("boolean") boolean removeStoragePath(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemoveStoragePath);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Rename a file or directory in a writable storage container.
    ///
    /// @param storage a storage container.
    /// @param oldpath the old path.
    /// @param newpath the new path.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    public @NativeType("boolean") boolean renameStoragePath(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr oldpath,
        @Nullable BytePtr newpath
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RenameStoragePath);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (oldpath != null ? oldpath.segment() : MemorySegment.NULL),
                (MemorySegment) (newpath != null ? newpath.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a file in a writable storage container.
    ///
    /// @param storage a storage container.
    /// @param oldpath the old path.
    /// @param newpath the new path.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    public @NativeType("boolean") boolean copyStorageFile(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr oldpath,
        @Nullable BytePtr newpath
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CopyStorageFile);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (oldpath != null ? oldpath.segment() : MemorySegment.NULL),
                (MemorySegment) (newpath != null ? newpath.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get information about a filesystem path in a storage container.
    ///
    /// @param storage a storage container.
    /// @param path the path to query.
    /// @param info a pointer filled in with information about the path, or NULL to
    /// check for the existence of a file.
    /// @return true on success or false if the file doesn't exist, or another
    /// failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    public @NativeType("boolean") boolean getStoragePathInfo(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path,
        @Nullable @Pointer ISDL_PathInfo info
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetStoragePathInfo);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                (MemorySegment) (info != null ? info.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Queries the remaining space in a storage container.
    ///
    /// @param storage a storage container to query.
    /// @return the amount of remaining space, in bytes.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #storageReady
    /// @see #writeStorageFile
    public @NativeType("Uint64") @Unsigned long getStorageSpaceRemaining(
        @Nullable SDL_Storage storage
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetStorageSpaceRemaining);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Enumerate a directory tree, filtered by pattern, and return a list.
    ///
    /// Files are filtered out if they don't match the string in `pattern`, which
    /// may contain wildcard characters `*` (match everything) and `?` (match one
    /// character). If pattern is NULL, no filtering is done and all results are
    /// returned. Subdirectories are permitted, and are specified with a path
    /// separator of '/'. Wildcard characters `*` and `?` never match a path
    /// separator.
    ///
    /// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
    /// case-insensitive.
    ///
    /// The returned array is always NULL-terminated, for your iterating
    /// convenience, but if `count` is non-NULL, on return it will contain the
    /// number of items in the array, not counting the NULL terminator.
    ///
    /// If `path` is NULL, this is treated as a request to enumerate the root of
    /// the storage container's tree. An empty string also works for this.
    ///
    /// @param storage a storage container.
    /// @param path the path of the directory to enumerate, or NULL for the root.
    /// @param pattern the pattern that files in the directory must match. Can be
    /// NULL.
    /// @param flags `SDL_GLOB_*` bitflags that affect this search.
    /// @param count on return, will be set to the number of items in the returned
    /// array. Can be NULL.
    /// @return an array of strings on success or NULL on failure; call
    /// SDL_GetError() for more information. The caller should pass the
    /// returned pointer to SDL_free when done with it. This is a single
    /// allocation that should be freed with SDL_free() when it is no
    /// longer needed.
    ///
    /// @threadsafety It is safe to call this function from any thread, assuming
    /// the `storage` object is thread-safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public PointerPtr globStorageDirectory(
        @Nullable SDL_Storage storage,
        @Nullable BytePtr path,
        @Nullable BytePtr pattern,
        @EnumType(SDL_GlobFlags.class) int flags,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GlobStorageDirectory);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (storage != null ? storage.segment() : MemorySegment.NULL),
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL),
                (MemorySegment) (pattern != null ? pattern.segment() : MemorySegment.NULL),
                flags,
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a new surface with a specific pixel format.
    ///
    /// The pixels of the new surface are initialized to zero.
    ///
    /// @param width the width of the surface.
    /// @param height the height of the surface.
    /// @param format the SDL_PixelFormat for the new surface's pixel format.
    /// @return the new SDL_Surface structure that is created or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createSurfaceFrom
    /// @see #destroySurface
    public SDL_Surface createSurface(
        int width,
        int height,
        @EnumType(SDL_PixelFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateSurface);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                width,
                height,
                format
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allocate a new surface with a specific pixel format and existing pixel
    /// data.
    ///
    /// No copy is made of the pixel data. Pixel data is not managed automatically;
    /// you must free the surface before you free the pixel data.
    ///
    /// Pitch is the offset in bytes from one row of pixels to the next, e.g.
    /// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.
    ///
    /// You may pass NULL for pixels and 0 for pitch to create a surface that you
    /// will fill in with valid values later.
    ///
    /// @param width the width of the surface.
    /// @param height the height of the surface.
    /// @param format the SDL_PixelFormat for the new surface's pixel format.
    /// @param pixels a pointer to existing pixel data.
    /// @param pitch the number of bytes between each row, including padding.
    /// @return the new SDL_Surface structure that is created or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createSurface
    /// @see #destroySurface
    public SDL_Surface createSurfaceFrom(
        int width,
        int height,
        @EnumType(SDL_PixelFormat.class) int format,
        @Pointer(comment="void*") MemorySegment pixels,
        int pitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateSurfaceFrom);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                width,
                height,
                format,
                pixels,
                pitch
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Free a surface.
    ///
    /// It is safe to pass NULL to this function.
    ///
    /// @param surface the SDL_Surface to free.
    ///
    /// @threadsafety No other thread should be using the surface when it is freed.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createSurface
    /// @see #createSurfaceFrom
    public void destroySurface(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroySurface);
        try {
            hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a surface.
    ///
    /// The following properties are understood by SDL:
    ///
    /// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
    /// surfaces, this defines the value of 100% diffuse white, with higher
    /// values being displayed in the High Dynamic Range headroom. This defaults
    /// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.
    /// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
    /// surfaces, this defines the maximum dynamic range used by the content, in
    /// terms of the SDR white point. This defaults to 0.0, which disables tone
    /// mapping.
    /// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator
    /// used when compressing from a surface with high dynamic range to another
    /// with lower dynamic range. Currently this supports "chrome", which uses
    /// the same tone mapping that Chrome uses for HDR content, the form "*=N",
    /// where N is a floating point scale factor applied in linear space, and
    /// "none", which disables tone mapping. This defaults to "chrome".
    /// - `SDL_PROP_SURFACE_HOTSPOT_X_NUMBER`: the hotspot pixel offset from the
    /// left edge of the image, if this surface is being used as a cursor.
    /// - `SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the
    /// top edge of the image, if this surface is being used as a cursor.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getSurfaceProperties(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the colorspace used by a surface.
    ///
    /// Setting the colorspace doesn't change the pixels, only how they are
    /// interpreted in color operations.
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param colorspace an SDL_Colorspace value describing the surface
    /// colorspace.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceColorspace
    public @NativeType("boolean") boolean setSurfaceColorspace(
        @Nullable SDL_Surface surface,
        @EnumType(SDL_Colorspace.class) int colorspace
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceColorspace);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                colorspace
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the colorspace used by a surface.
    ///
    /// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point
    /// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for
    /// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @return the colorspace used by the surface, or SDL_COLORSPACE_UNKNOWN if
    /// the surface is NULL.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfaceColorspace
    public @EnumType(SDL_Colorspace.class) int getSurfaceColorspace(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceColorspace);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a palette and associate it with a surface.
    ///
    /// This function creates a palette compatible with the provided surface. The
    /// palette is then returned for you to modify, and the surface will
    /// automatically use the new palette in future operations. You do not need to
    /// destroy the returned palette, it will be freed when the reference count
    /// reaches 0, usually when the surface is destroyed.
    ///
    /// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or
    /// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as
    /// white and 1 as black. Other surfaces will get a palette initialized with
    /// white in every entry.
    ///
    /// If this function is called for a surface that already has a palette, a new
    /// palette will be created to replace it.
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @return a new SDL_Palette structure on success or NULL on failure (e.g. if
    /// the surface didn't have an index format); call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setPaletteColors
    public @Pointer ISDL_Palette createSurfacePalette(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateSurfacePalette);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Palette(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the palette used by a surface.
    ///
    /// A single palette can be shared with many surfaces.
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param palette the SDL_Palette structure to use.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createPalette
    /// @see #getSurfacePalette
    public @NativeType("boolean") boolean setSurfacePalette(
        @Nullable SDL_Surface surface,
        @Nullable @Pointer ISDL_Palette palette
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfacePalette);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the palette used by a surface.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @return a pointer to the palette used by the surface, or NULL if there is
    /// no palette used.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfacePalette
    public @Pointer ISDL_Palette getSurfacePalette(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfacePalette);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Palette(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Add an alternate version of a surface.
    ///
    /// This function adds an alternate version of this surface, usually used for
    /// content with high DPI representations like cursors or icons. The size,
    /// format, and content do not need to match the original surface, and these
    /// alternate versions will not be updated when the original surface changes.
    ///
    /// This function adds a reference to the alternate version, so you should call
    /// SDL_DestroySurface() on the image after this call.
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param image a pointer to an alternate SDL_Surface to associate with this
    /// surface.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #removeSurfaceAlternateImages
    /// @see #getSurfaceImages
    /// @see #surfaceHasAlternateImages
    public @NativeType("boolean") boolean addSurfaceAlternateImage(
        @Nullable SDL_Surface surface,
        @Nullable SDL_Surface image
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddSurfaceAlternateImage);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (image != null ? image.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether a surface has alternate versions available.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @return true if alternate versions are available or false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addSurfaceAlternateImage
    /// @see #removeSurfaceAlternateImages
    /// @see #getSurfaceImages
    public @NativeType("boolean") boolean surfaceHasAlternateImages(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SurfaceHasAlternateImages);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get an array including all versions of a surface.
    ///
    /// This returns all versions of a surface, with the surface being queried as
    /// the first element in the returned array.
    ///
    /// Freeing the array of surfaces does not affect the surfaces in the array.
    /// They are still referenced by the surface being queried and will be cleaned
    /// up normally.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @param count a pointer filled in with the number of surface pointers
    /// returned, may be NULL.
    /// @return a NULL terminated array of SDL_Surface pointers or NULL on
    /// failure; call SDL_GetError() for more information. This should be
    /// freed with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addSurfaceAlternateImage
    /// @see #removeSurfaceAlternateImages
    /// @see #surfaceHasAlternateImages
    public @Pointer SDL_Surface.Ptr getSurfaceImages(
        @Nullable SDL_Surface surface,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceImages);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface.Ptr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Remove all alternate versions of a surface.
    ///
    /// This function removes a reference from all the alternative versions,
    /// destroying them if this is the last reference to them.
    ///
    /// @param surface the SDL_Surface structure to update.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addSurfaceAlternateImage
    /// @see #getSurfaceImages
    /// @see #surfaceHasAlternateImages
    public void removeSurfaceAlternateImages(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemoveSurfaceAlternateImages);
        try {
            hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set up a surface for directly accessing the pixels.
    ///
    /// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
    /// and read from `surface-&amp;gt;pixels`, using the pixel format stored in
    /// `surface-&amp;gt;format`. Once you are done accessing the surface, you should use
    /// SDL_UnlockSurface() to release it.
    ///
    /// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
    /// 0, then you can read and write to the surface at any time, and the pixel
    /// format of the surface will not change.
    ///
    /// @param surface the SDL_Surface structure to be locked.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe. The locking referred to by
    /// this function is making the pixels available for direct
    /// access, not thread-safe locking.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_MUSTLOCK`
    /// @see #unlockSurface
    public @NativeType("boolean") boolean lockSurface(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LockSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Release a surface after directly accessing the pixels.
    ///
    /// @param surface the SDL_Surface structure to be unlocked.
    ///
    /// @threadsafety This function is not thread safe. The locking referred to by
    /// this function is making the pixels available for direct
    /// access, not thread-safe locking.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #lockSurface
    public void unlockSurface(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UnlockSurface);
        try {
            hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load a BMP image from a seekable SDL data stream.
    ///
    /// The new surface should be freed with SDL_DestroySurface(). Not doing so
    /// will result in a memory leak.
    ///
    /// @param src the data stream for the surface.
    /// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
    /// in the case of an error.
    /// @return a pointer to a new SDL_Surface structure or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroySurface
    /// @see #loadBMP
    /// @see #saveBMP_IO
    public SDL_Surface loadBMP_IO(
        @Nullable SDL_IOStream src,
        @NativeType("boolean") boolean closeio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadBMP_IO);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                closeio
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Load a BMP image from a file.
    ///
    /// The new surface should be freed with SDL_DestroySurface(). Not doing so
    /// will result in a memory leak.
    ///
    /// @param file the BMP file to load.
    /// @return a pointer to a new SDL_Surface structure or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroySurface
    /// @see #loadBMP_IO
    /// @see #saveBMP
    public SDL_Surface loadBMP(
        @Nullable BytePtr file
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_LoadBMP);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Save a surface to a seekable SDL data stream in BMP format.
    ///
    /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
    /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
    /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
    /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
    /// not supported.
    ///
    /// @param surface the SDL_Surface structure containing the image to be saved.
    /// @param dst a data stream to save to.
    /// @param closeio if true, calls SDL_CloseIO() on `dst` before returning, even
    /// in the case of an error.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadBMP_IO
    /// @see #saveBMP
    public @NativeType("boolean") boolean saveBMP_IO(
        @Nullable SDL_Surface surface,
        @Nullable SDL_IOStream dst,
        @NativeType("boolean") boolean closeio
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SaveBMP_IO);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                closeio
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Save a surface to a file.
    ///
    /// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
    /// BMP directly. Other RGB formats with 8-bit or higher get converted to a
    /// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
    /// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
    /// not supported.
    ///
    /// @param surface the SDL_Surface structure containing the image to be saved.
    /// @param file a file to save to.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #loadBMP
    /// @see #saveBMP_IO
    public @NativeType("boolean") boolean saveBMP(
        @Nullable SDL_Surface surface,
        @Nullable BytePtr file
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SaveBMP);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (file != null ? file.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the RLE acceleration hint for a surface.
    ///
    /// If RLE is enabled, color key and alpha blending blits are much faster, but
    /// the surface must be locked before directly accessing the pixels.
    ///
    /// @param surface the SDL_Surface structure to optimize.
    /// @param enabled true to enable RLE acceleration, false to disable it.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurface
    /// @see #lockSurface
    /// @see #unlockSurface
    public @NativeType("boolean") boolean setSurfaceRLE(
        @Nullable SDL_Surface surface,
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceRLE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Returns whether the surface is RLE enabled.
    ///
    /// It is safe to pass a NULL `surface` here; it will return false.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @return true if the surface is RLE enabled, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfaceRLE
    public @NativeType("boolean") boolean surfaceHasRLE(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SurfaceHasRLE);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the color key (transparent pixel) in a surface.
    ///
    /// The color key defines a pixel value that will be treated as transparent in
    /// a blit. For example, one can use this to specify that cyan pixels should be
    /// considered transparent, and therefore not rendered.
    ///
    /// It is a pixel of the format used by the surface, as generated by
    /// SDL_MapRGB().
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param enabled true to enable color key, false to disable color key.
    /// @param key the transparent pixel.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceColorKey
    /// @see #setSurfaceRLE
    /// @see #surfaceHasColorKey
    public @NativeType("boolean") boolean setSurfaceColorKey(
        @Nullable SDL_Surface surface,
        @NativeType("boolean") boolean enabled,
        @NativeType("Uint32") @Unsigned int key
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceColorKey);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                enabled,
                key
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Returns whether the surface has a color key.
    ///
    /// It is safe to pass a NULL `surface` here; it will return false.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @return true if the surface has a color key, false otherwise.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfaceColorKey
    /// @see #getSurfaceColorKey
    public @NativeType("boolean") boolean surfaceHasColorKey(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SurfaceHasColorKey);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the color key (transparent pixel) for a surface.
    ///
    /// The color key is a pixel of the format used by the surface, as generated by
    /// SDL_MapRGB().
    ///
    /// If the surface doesn't have color key enabled this function returns false.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @param key a pointer filled in with the transparent pixel.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfaceColorKey
    /// @see #surfaceHasColorKey
    public @NativeType("boolean") boolean getSurfaceColorKey(
        @Nullable SDL_Surface surface,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr key
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceColorKey);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (key != null ? key.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an additional color value multiplied into blit operations.
    ///
    /// When this surface is blitted, during the blit operation each source color
    /// channel is modulated by the appropriate color value according to the
    /// following formula:
    ///
    /// `srcC = srcC * (color / 255)`
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param r the red color value multiplied into blit operations.
    /// @param g the green color value multiplied into blit operations.
    /// @param b the blue color value multiplied into blit operations.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceColorMod
    /// @see #setSurfaceAlphaMod
    public @NativeType("boolean") boolean setSurfaceColorMod(
        @Nullable SDL_Surface surface,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceColorMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                r,
                g,
                b
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the additional color value multiplied into blit operations.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @param r a pointer filled in with the current red color value.
    /// @param g a pointer filled in with the current green color value.
    /// @param b a pointer filled in with the current blue color value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceAlphaMod
    /// @see #setSurfaceColorMod
    public @NativeType("boolean") boolean getSurfaceColorMod(
        @Nullable SDL_Surface surface,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr r,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr g,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceColorMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an additional alpha value used in blit operations.
    ///
    /// When this surface is blitted, during the blit operation the source alpha
    /// value is modulated by this alpha value according to the following formula:
    ///
    /// `srcA = srcA * (alpha / 255)`
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param alpha the alpha value multiplied into blit operations.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceAlphaMod
    /// @see #setSurfaceColorMod
    public @NativeType("boolean") boolean setSurfaceAlphaMod(
        @Nullable SDL_Surface surface,
        @NativeType("Uint8") @Unsigned byte alpha
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceAlphaMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                alpha
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the additional alpha value used in blit operations.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @param alpha a pointer filled in with the current alpha value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceColorMod
    /// @see #setSurfaceAlphaMod
    public @NativeType("boolean") boolean getSurfaceAlphaMod(
        @Nullable SDL_Surface surface,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr alpha
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceAlphaMod);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (alpha != null ? alpha.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the blend mode used for blit operations.
    ///
    /// To copy a surface to another surface (or texture) without blending with the
    /// existing data, the blendmode of the SOURCE surface should be set to
    /// `SDL_BLENDMODE_NONE`.
    ///
    /// @param surface the SDL_Surface structure to update.
    /// @param blendMode the SDL_BlendMode to use for blit blending.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceBlendMode
    public @NativeType("boolean") boolean setSurfaceBlendMode(
        @Nullable SDL_Surface surface,
        @EnumType(SDL_BlendMode.class) int blendMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceBlendMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                blendMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the blend mode used for blit operations.
    ///
    /// @param surface the SDL_Surface structure to query.
    /// @param blendMode a pointer filled in with the current SDL_BlendMode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfaceBlendMode
    public @NativeType("boolean") boolean getSurfaceBlendMode(
        @Nullable SDL_Surface surface,
        @Nullable @EnumType(SDL_BlendMode.class) IntPtr blendMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceBlendMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (blendMode != null ? blendMode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the clipping rectangle for a surface.
    ///
    /// When `surface` is the destination of a blit, only the area within the clip
    /// rectangle is drawn into.
    ///
    /// Note that blits are automatically clipped to the edges of the source and
    /// destination surfaces.
    ///
    /// @param surface the SDL_Surface structure to be clipped.
    /// @param rect the SDL_Rect structure representing the clipping rectangle, or
    /// NULL to disable clipping.
    /// @return true if the rectangle intersects the surface, otherwise false and
    /// blits will be completely clipped.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getSurfaceClipRect
    public @NativeType("boolean") boolean setSurfaceClipRect(
        @Nullable SDL_Surface surface,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetSurfaceClipRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the clipping rectangle for a surface.
    ///
    /// When `surface` is the destination of a blit, only the area within the clip
    /// rectangle is drawn into.
    ///
    /// @param surface the SDL_Surface structure representing the surface to be
    /// clipped.
    /// @param rect an SDL_Rect structure filled in with the clipping rectangle for
    /// the surface.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setSurfaceClipRect
    public @NativeType("boolean") boolean getSurfaceClipRect(
        @Nullable SDL_Surface surface,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSurfaceClipRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Flip a surface vertically or horizontally.
    ///
    /// @param surface the surface to flip.
    /// @param flip the direction to flip.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean flipSurface(
        @Nullable SDL_Surface surface,
        @EnumType(SDL_FlipMode.class) int flip
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlipSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                flip
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a new surface identical to the existing surface.
    ///
    /// If the original surface has alternate images, the new surface will have a
    /// reference to them as well.
    ///
    /// The returned surface should be freed with SDL_DestroySurface().
    ///
    /// @param surface the surface to duplicate.
    /// @return a copy of the surface or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroySurface
    public SDL_Surface duplicateSurface(
        @Nullable SDL_Surface surface
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DuplicateSurface);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Creates a new surface identical to the existing surface, scaled to the
    /// desired size.
    ///
    /// The returned surface should be freed with SDL_DestroySurface().
    ///
    /// @param surface the surface to duplicate and scale.
    /// @param width the width of the new surface.
    /// @param height the height of the new surface.
    /// @param scaleMode the SDL_ScaleMode to be used.
    /// @return a copy of the surface or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroySurface
    public SDL_Surface scaleSurface(
        @Nullable SDL_Surface surface,
        int width,
        int height,
        @EnumType(SDL_ScaleMode.class) int scaleMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ScaleSurface);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                width,
                height,
                scaleMode
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy an existing surface to a new surface of the specified format.
    ///
    /// This function is used to optimize images for faster *repeat* blitting. This
    /// is accomplished by converting the original and storing the result as a new
    /// surface. The new, optimized surface can then be used as the source for
    /// future blits, making them faster.
    ///
    /// If you are converting to an indexed surface and want to map colors to a
    /// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.
    ///
    /// If the original surface has alternate images, the new surface will have a
    /// reference to them as well.
    ///
    /// @param surface the existing SDL_Surface structure to convert.
    /// @param format the new pixel format.
    /// @return the new SDL_Surface structure that is created or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #convertSurfaceAndColorspace
    /// @see #destroySurface
    public SDL_Surface convertSurface(
        @Nullable SDL_Surface surface,
        @EnumType(SDL_PixelFormat.class) int format
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ConvertSurface);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                format
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy an existing surface to a new surface of the specified format and
    /// colorspace.
    ///
    /// This function converts an existing surface to a new format and colorspace
    /// and returns the new surface. This will perform any pixel format and
    /// colorspace conversion needed.
    ///
    /// If the original surface has alternate images, the new surface will have a
    /// reference to them as well.
    ///
    /// @param surface the existing SDL_Surface structure to convert.
    /// @param format the new pixel format.
    /// @param palette an optional palette to use for indexed formats, may be NULL.
    /// @param colorspace the new colorspace.
    /// @param props an SDL_PropertiesID with additional color properties, or 0.
    /// @return the new SDL_Surface structure that is created or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #convertSurface
    /// @see #destroySurface
    public SDL_Surface convertSurfaceAndColorspace(
        @Nullable SDL_Surface surface,
        @EnumType(SDL_PixelFormat.class) int format,
        @Nullable @Pointer ISDL_Palette palette,
        @EnumType(SDL_Colorspace.class) int colorspace,
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ConvertSurfaceAndColorspace);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                format,
                (MemorySegment) (palette != null ? palette.segment() : MemorySegment.NULL),
                colorspace,
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a block of pixels of one format to another format.
    ///
    /// @param width the width of the block to copy, in pixels.
    /// @param height the height of the block to copy, in pixels.
    /// @param src_format an SDL_PixelFormat value of the `src` pixels format.
    /// @param src a pointer to the source pixels.
    /// @param src_pitch the pitch of the source pixels, in bytes.
    /// @param dst_format an SDL_PixelFormat value of the `dst` pixels format.
    /// @param dst a pointer to be filled in with new pixel data.
    /// @param dst_pitch the pitch of the destination pixels, in bytes.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety The same destination pixels should not be used from two
    /// threads at once. It is safe to use the same source pixels
    /// from multiple threads.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #convertPixelsAndColorspace
    public @NativeType("boolean") boolean convertPixels(
        int width,
        int height,
        @EnumType(SDL_PixelFormat.class) int src_format,
        @Pointer(comment="void*") MemorySegment src,
        int src_pitch,
        @EnumType(SDL_PixelFormat.class) int dst_format,
        @Pointer(comment="void*") MemorySegment dst,
        int dst_pitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ConvertPixels);
        try {
            return (boolean) hFunction.invokeExact(
                width,
                height,
                src_format,
                src,
                src_pitch,
                dst_format,
                dst,
                dst_pitch
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy a block of pixels of one format and colorspace to another format and
    /// colorspace.
    ///
    /// @param width the width of the block to copy, in pixels.
    /// @param height the height of the block to copy, in pixels.
    /// @param src_format an SDL_PixelFormat value of the `src` pixels format.
    /// @param src_colorspace an SDL_Colorspace value describing the colorspace of
    /// the `src` pixels.
    /// @param src_properties an SDL_PropertiesID with additional source color
    /// properties, or 0.
    /// @param src a pointer to the source pixels.
    /// @param src_pitch the pitch of the source pixels, in bytes.
    /// @param dst_format an SDL_PixelFormat value of the `dst` pixels format.
    /// @param dst_colorspace an SDL_Colorspace value describing the colorspace of
    /// the `dst` pixels.
    /// @param dst_properties an SDL_PropertiesID with additional destination color
    /// properties, or 0.
    /// @param dst a pointer to be filled in with new pixel data.
    /// @param dst_pitch the pitch of the destination pixels, in bytes.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety The same destination pixels should not be used from two
    /// threads at once. It is safe to use the same source pixels
    /// from multiple threads.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #convertPixels
    public @NativeType("boolean") boolean convertPixelsAndColorspace(
        int width,
        int height,
        @EnumType(SDL_PixelFormat.class) int src_format,
        @EnumType(SDL_Colorspace.class) int src_colorspace,
        @NativeType("SDL_PropertiesID") @Unsigned int src_properties,
        @Pointer(comment="void*") MemorySegment src,
        int src_pitch,
        @EnumType(SDL_PixelFormat.class) int dst_format,
        @EnumType(SDL_Colorspace.class) int dst_colorspace,
        @NativeType("SDL_PropertiesID") @Unsigned int dst_properties,
        @Pointer(comment="void*") MemorySegment dst,
        int dst_pitch
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ConvertPixelsAndColorspace);
        try {
            return (boolean) hFunction.invokeExact(
                width,
                height,
                src_format,
                src_colorspace,
                src_properties,
                src,
                src_pitch,
                dst_format,
                dst_colorspace,
                dst_properties,
                dst,
                dst_pitch
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Premultiply the alpha on a block of pixels.
    ///
    /// This is safe to use with src == dst, but not for other overlapping areas.
    ///
    /// @param width the width of the block to convert, in pixels.
    /// @param height the height of the block to convert, in pixels.
    /// @param src_format an SDL_PixelFormat value of the `src` pixels format.
    /// @param src a pointer to the source pixels.
    /// @param src_pitch the pitch of the source pixels, in bytes.
    /// @param dst_format an SDL_PixelFormat value of the `dst` pixels format.
    /// @param dst a pointer to be filled in with premultiplied pixel data.
    /// @param dst_pitch the pitch of the destination pixels, in bytes.
    /// @param linear true to convert from sRGB to linear space for the alpha
    /// multiplication, false to do multiplication in sRGB space.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety The same destination pixels should not be used from two
    /// threads at once. It is safe to use the same source pixels
    /// from multiple threads.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean premultiplyAlpha(
        int width,
        int height,
        @EnumType(SDL_PixelFormat.class) int src_format,
        @Pointer(comment="void*") MemorySegment src,
        int src_pitch,
        @EnumType(SDL_PixelFormat.class) int dst_format,
        @Pointer(comment="void*") MemorySegment dst,
        int dst_pitch,
        @NativeType("boolean") boolean linear
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PremultiplyAlpha);
        try {
            return (boolean) hFunction.invokeExact(
                width,
                height,
                src_format,
                src,
                src_pitch,
                dst_format,
                dst,
                dst_pitch,
                linear
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Premultiply the alpha in a surface.
    ///
    /// This is safe to use with src == dst, but not for other overlapping areas.
    ///
    /// @param surface the surface to modify.
    /// @param linear true to convert from sRGB to linear space for the alpha
    /// multiplication, false to do multiplication in sRGB space.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean premultiplySurfaceAlpha(
        @Nullable SDL_Surface surface,
        @NativeType("boolean") boolean linear
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_PremultiplySurfaceAlpha);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                linear
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Clear a surface with a specific color, with floating point precision.
    ///
    /// This function handles all surface formats, and ignores any clip rectangle.
    ///
    /// If the surface is YUV, the color is assumed to be in the sRGB colorspace,
    /// otherwise the color is assumed to be in the colorspace of the suface.
    ///
    /// @param surface the SDL_Surface to clear.
    /// @param r the red component of the pixel, normally in the range 0-1.
    /// @param g the green component of the pixel, normally in the range 0-1.
    /// @param b the blue component of the pixel, normally in the range 0-1.
    /// @param a the alpha component of the pixel, normally in the range 0-1.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean clearSurface(
        @Nullable SDL_Surface surface,
        float r,
        float g,
        float b,
        float a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClearSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a fast fill of a rectangle with a specific color.
    ///
    /// `color` should be a pixel of the format used by the surface, and can be
    /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
    /// alpha component then the destination is simply filled with that alpha
    /// information, no blending takes place.
    ///
    /// If there is a clip rectangle set on the destination (set via
    /// SDL_SetSurfaceClipRect()), then this function will fill based on the
    /// intersection of the clip rectangle and `rect`.
    ///
    /// @param dst the SDL_Surface structure that is the drawing target.
    /// @param rect the SDL_Rect structure representing the rectangle to fill, or
    /// NULL to fill the entire surface.
    /// @param color the color to fill with.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #fillSurfaceRects
    public @NativeType("boolean") boolean fillSurfaceRect(
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect rect,
        @NativeType("Uint32") @Unsigned int color
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FillSurfaceRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL),
                color
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a fast fill of a set of rectangles with a specific color.
    ///
    /// `color` should be a pixel of the format used by the surface, and can be
    /// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
    /// alpha component then the destination is simply filled with that alpha
    /// information, no blending takes place.
    ///
    /// If there is a clip rectangle set on the destination (set via
    /// SDL_SetSurfaceClipRect()), then this function will fill based on the
    /// intersection of the clip rectangle and `rect`.
    ///
    /// @param dst the SDL_Surface structure that is the drawing target.
    /// @param rects an array of SDL_Rects representing the rectangles to fill.
    /// @param count the number of rectangles in the array.
    /// @param color the color to fill with.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #fillSurfaceRect
    public @NativeType("boolean") boolean fillSurfaceRects(
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect rects,
        int count,
        @NativeType("Uint32") @Unsigned int color
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FillSurfaceRects);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (rects != null ? rects.segment() : MemorySegment.NULL),
                count,
                color
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Performs a fast blit from the source surface to the destination surface
    /// with clipping.
    ///
    /// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or
    /// `dst`) is copied while ensuring clipping to `dst-&amp;gt;clip_rect`.
    ///
    /// The blit function should not be called on a locked surface.
    ///
    /// The blit semantics for surfaces with and without blending and colorkey are
    /// defined as follows:
    ///
    /// ```
    /// RGBA-&amp;gt;RGB:
    /// Source surface blend mode set to SDL_BLENDMODE_BLEND:
    /// alpha-blend (using the source alpha-channel and per-surface alpha)
    /// SDL_SRCCOLORKEY ignored.
    /// Source surface blend mode set to SDL_BLENDMODE_NONE:
    /// copy RGB.
    /// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
    /// RGB values of the source color key, ignoring alpha in the
    /// comparison.
    ///
    /// RGB-&amp;gt;RGBA:
    /// Source surface blend mode set to SDL_BLENDMODE_BLEND:
    /// alpha-blend (using the source per-surface alpha)
    /// Source surface blend mode set to SDL_BLENDMODE_NONE:
    /// copy RGB, set destination alpha to source per-surface alpha value.
    /// both:
    /// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
    /// source color key.
    ///
    /// RGBA-&amp;gt;RGBA:
    /// Source surface blend mode set to SDL_BLENDMODE_BLEND:
    /// alpha-blend (using the source alpha-channel and per-surface alpha)
    /// SDL_SRCCOLORKEY ignored.
    /// Source surface blend mode set to SDL_BLENDMODE_NONE:
    /// copy all of RGBA to the destination.
    /// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
    /// RGB values of the source color key, ignoring alpha in the
    /// comparison.
    ///
    /// RGB-&amp;gt;RGB:
    /// Source surface blend mode set to SDL_BLENDMODE_BLEND:
    /// alpha-blend (using the source per-surface alpha)
    /// Source surface blend mode set to SDL_BLENDMODE_NONE:
    /// copy RGB.
    /// both:
    /// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
    /// source color key.
    /// ```
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, or NULL to copy the entire surface.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the x and y position in
    /// the destination surface, or NULL for (0,0). The width and
    /// height are ignored, and are copied from `srcrect`. If you
    /// want a specific width and height, you should use
    /// SDL_BlitSurfaceScaled().
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurfaceScaled
    public @NativeType("boolean") boolean blitSurface(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform low-level surface blitting only.
    ///
    /// This is a semi-private blit function and it performs low-level surface
    /// blitting, assuming the input rectangles have already been clipped.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, may not be NULL.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, may not be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurface
    public @NativeType("boolean") boolean blitSurfaceUnchecked(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurfaceUnchecked);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a scaled blit to a destination surface, which may be of a different
    /// format.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, or NULL to copy the entire surface.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, or NULL to fill the entire
    /// destination surface.
    /// @param scaleMode the SDL_ScaleMode to be used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurface
    public @NativeType("boolean") boolean blitSurfaceScaled(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect,
        @EnumType(SDL_ScaleMode.class) int scaleMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurfaceScaled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL),
                scaleMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform low-level surface scaled blitting only.
    ///
    /// This is a semi-private function and it performs low-level surface blitting,
    /// assuming the input rectangles have already been clipped.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, may not be NULL.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, may not be NULL.
    /// @param scaleMode the SDL_ScaleMode to be used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurfaceScaled
    public @NativeType("boolean") boolean blitSurfaceUncheckedScaled(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect,
        @EnumType(SDL_ScaleMode.class) int scaleMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurfaceUncheckedScaled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL),
                scaleMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a stretched pixel copy from one surface to another.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, may not be NULL.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, may not be NULL.
    /// @param scaleMode the SDL_ScaleMode to be used.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.4.0.
    ///
    /// @see #blitSurfaceScaled
    public @NativeType("boolean") boolean stretchSurface(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect,
        @EnumType(SDL_ScaleMode.class) int scaleMode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_StretchSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL),
                scaleMode
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a tiled blit to a destination surface, which may be of a different
    /// format.
    ///
    /// The pixels in `srcrect` will be repeated as many times as needed to
    /// completely fill `dstrect`.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, or NULL to copy the entire surface.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, or NULL to fill the entire surface.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurface
    public @NativeType("boolean") boolean blitSurfaceTiled(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurfaceTiled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a scaled and tiled blit to a destination surface, which may be of a
    /// different format.
    ///
    /// The pixels in `srcrect` will be scaled and repeated as many times as needed
    /// to completely fill `dstrect`.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be
    /// copied, or NULL to copy the entire surface.
    /// @param scale the scale used to transform srcrect into the destination
    /// rectangle, e.g. a 32x32 texture with a scale of 2 would fill
    /// 64x64 tiles.
    /// @param scaleMode scale algorithm to be used.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, or NULL to fill the entire surface.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurface
    public @NativeType("boolean") boolean blitSurfaceTiledWithScale(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        float scale,
        @EnumType(SDL_ScaleMode.class) int scaleMode,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurfaceTiledWithScale);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                scale,
                scaleMode,
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Perform a scaled blit using the 9-grid algorithm to a destination surface,
    /// which may be of a different format.
    ///
    /// The pixels in the source surface are split into a 3x3 grid, using the
    /// different corner sizes for each corner, and the sides and center making up
    /// the remaining pixels. The corners are then scaled using `scale` and fit
    /// into the corners of the destination rectangle. The sides and center are
    /// then stretched into place to cover the remaining destination rectangle.
    ///
    /// @param src the SDL_Surface structure to be copied from.
    /// @param srcrect the SDL_Rect structure representing the rectangle to be used
    /// for the 9-grid, or NULL to use the entire surface.
    /// @param left_width the width, in pixels, of the left corners in `srcrect`.
    /// @param right_width the width, in pixels, of the right corners in `srcrect`.
    /// @param top_height the height, in pixels, of the top corners in `srcrect`.
    /// @param bottom_height the height, in pixels, of the bottom corners in
    /// `srcrect`.
    /// @param scale the scale used to transform the corner of `srcrect` into the
    /// corner of `dstrect`, or 0.0f for an unscaled blit.
    /// @param scaleMode scale algorithm to be used.
    /// @param dst the SDL_Surface structure that is the blit target.
    /// @param dstrect the SDL_Rect structure representing the target rectangle in
    /// the destination surface, or NULL to fill the entire surface.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety Only one thread should be using the `src` and `dst` surfaces
    /// at any given time.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #blitSurface
    public @NativeType("boolean") boolean blitSurface9Grid(
        @Nullable SDL_Surface src,
        @Nullable @Pointer ISDL_Rect srcrect,
        int left_width,
        int right_width,
        int top_height,
        int bottom_height,
        float scale,
        @EnumType(SDL_ScaleMode.class) int scaleMode,
        @Nullable SDL_Surface dst,
        @Nullable @Pointer ISDL_Rect dstrect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_BlitSurface9Grid);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (src != null ? src.segment() : MemorySegment.NULL),
                (MemorySegment) (srcrect != null ? srcrect.segment() : MemorySegment.NULL),
                left_width,
                right_width,
                top_height,
                bottom_height,
                scale,
                scaleMode,
                (MemorySegment) (dst != null ? dst.segment() : MemorySegment.NULL),
                (MemorySegment) (dstrect != null ? dstrect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Map an RGB triple to an opaque pixel value for a surface.
    ///
    /// This function maps the RGB color value to the specified pixel format and
    /// returns the pixel value best approximating the given RGB color value for
    /// the given pixel format.
    ///
    /// If the surface has a palette, the index of the closest matching color in
    /// the palette will be returned.
    ///
    /// If the surface pixel format has an alpha component it will be returned as
    /// all 1 bits (fully opaque).
    ///
    /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
    /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
    /// format the return value can be assigned to a Uint16, and similarly a Uint8
    /// for an 8-bpp format).
    ///
    /// @param surface the surface to use for the pixel format and palette.
    /// @param r the red component of the pixel in the range 0-255.
    /// @param g the green component of the pixel in the range 0-255.
    /// @param b the blue component of the pixel in the range 0-255.
    /// @return a pixel value.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #mapSurfaceRGBA
    public @NativeType("Uint32") @Unsigned int mapSurfaceRGB(
        @Nullable SDL_Surface surface,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MapSurfaceRGB);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                r,
                g,
                b
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Map an RGBA quadruple to a pixel value for a surface.
    ///
    /// This function maps the RGBA color value to the specified pixel format and
    /// returns the pixel value best approximating the given RGBA color value for
    /// the given pixel format.
    ///
    /// If the surface pixel format has no alpha component the alpha value will be
    /// ignored (as it will be in formats with a palette).
    ///
    /// If the surface has a palette, the index of the closest matching color in
    /// the palette will be returned.
    ///
    /// If the pixel format bpp (color depth) is less than 32-bpp then the unused
    /// upper bits of the return value can safely be ignored (e.g., with a 16-bpp
    /// format the return value can be assigned to a Uint16, and similarly a Uint8
    /// for an 8-bpp format).
    ///
    /// @param surface the surface to use for the pixel format and palette.
    /// @param r the red component of the pixel in the range 0-255.
    /// @param g the green component of the pixel in the range 0-255.
    /// @param b the blue component of the pixel in the range 0-255.
    /// @param a the alpha component of the pixel in the range 0-255.
    /// @return a pixel value.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #mapSurfaceRGB
    public @NativeType("Uint32") @Unsigned int mapSurfaceRGBA(
        @Nullable SDL_Surface surface,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b,
        @NativeType("Uint8") @Unsigned byte a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MapSurfaceRGBA);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Retrieves a single pixel from a surface.
    ///
    /// This function prioritizes correctness over speed: it is suitable for unit
    /// tests, but is not intended for use in a game engine.
    ///
    /// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color
    /// components from pixel formats with less than 8 bits per RGB component.
    ///
    /// @param surface the surface to read.
    /// @param x the horizontal coordinate, 0 &amp;lt;= x &amp;lt; width.
    /// @param y the vertical coordinate, 0 &amp;lt;= y &amp;lt; height.
    /// @param r a pointer filled in with the red channel, 0-255, or NULL to ignore
    /// this channel.
    /// @param g a pointer filled in with the green channel, 0-255, or NULL to
    /// ignore this channel.
    /// @param b a pointer filled in with the blue channel, 0-255, or NULL to
    /// ignore this channel.
    /// @param a a pointer filled in with the alpha channel, 0-255, or NULL to
    /// ignore this channel.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readSurfacePixel(
        @Nullable SDL_Surface surface,
        int x,
        int y,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr r,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr g,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr b,
        @Nullable @Pointer(comment="Uint8") @Unsigned BytePtr a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadSurfacePixel);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                x,
                y,
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL),
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Retrieves a single pixel from a surface.
    ///
    /// This function prioritizes correctness over speed: it is suitable for unit
    /// tests, but is not intended for use in a game engine.
    ///
    /// @param surface the surface to read.
    /// @param x the horizontal coordinate, 0 &amp;lt;= x &amp;lt; width.
    /// @param y the vertical coordinate, 0 &amp;lt;= y &amp;lt; height.
    /// @param r a pointer filled in with the red channel, normally in the range
    /// 0-1, or NULL to ignore this channel.
    /// @param g a pointer filled in with the green channel, normally in the range
    /// 0-1, or NULL to ignore this channel.
    /// @param b a pointer filled in with the blue channel, normally in the range
    /// 0-1, or NULL to ignore this channel.
    /// @param a a pointer filled in with the alpha channel, normally in the range
    /// 0-1, or NULL to ignore this channel.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean readSurfacePixelFloat(
        @Nullable SDL_Surface surface,
        int x,
        int y,
        @Nullable FloatPtr r,
        @Nullable FloatPtr g,
        @Nullable FloatPtr b,
        @Nullable FloatPtr a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ReadSurfacePixelFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                x,
                y,
                (MemorySegment) (r != null ? r.segment() : MemorySegment.NULL),
                (MemorySegment) (g != null ? g.segment() : MemorySegment.NULL),
                (MemorySegment) (b != null ? b.segment() : MemorySegment.NULL),
                (MemorySegment) (a != null ? a.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Writes a single pixel to a surface.
    ///
    /// This function prioritizes correctness over speed: it is suitable for unit
    /// tests, but is not intended for use in a game engine.
    ///
    /// Like SDL_MapRGBA, this uses the entire 0..255 range when converting color
    /// components from pixel formats with less than 8 bits per RGB component.
    ///
    /// @param surface the surface to write.
    /// @param x the horizontal coordinate, 0 &amp;lt;= x &amp;lt; width.
    /// @param y the vertical coordinate, 0 &amp;lt;= y &amp;lt; height.
    /// @param r the red channel value, 0-255.
    /// @param g the green channel value, 0-255.
    /// @param b the blue channel value, 0-255.
    /// @param a the alpha channel value, 0-255.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeSurfacePixel(
        @Nullable SDL_Surface surface,
        int x,
        int y,
        @NativeType("Uint8") @Unsigned byte r,
        @NativeType("Uint8") @Unsigned byte g,
        @NativeType("Uint8") @Unsigned byte b,
        @NativeType("Uint8") @Unsigned byte a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteSurfacePixel);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                x,
                y,
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Writes a single pixel to a surface.
    ///
    /// This function prioritizes correctness over speed: it is suitable for unit
    /// tests, but is not intended for use in a game engine.
    ///
    /// @param surface the surface to write.
    /// @param x the horizontal coordinate, 0 &amp;lt;= x &amp;lt; width.
    /// @param y the vertical coordinate, 0 &amp;lt;= y &amp;lt; height.
    /// @param r the red channel value, normally in the range 0-1.
    /// @param g the green channel value, normally in the range 0-1.
    /// @param b the blue channel value, normally in the range 0-1.
    /// @param a the alpha channel value, normally in the range 0-1.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function is not thread safe.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean writeSurfacePixelFloat(
        @Nullable SDL_Surface surface,
        int x,
        int y,
        float r,
        float g,
        float b,
        float a
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WriteSurfacePixelFloat);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (surface != null ? surface.segment() : MemorySegment.NULL),
                x,
                y,
                r,
                g,
                b,
                a
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a callback for every Windows message, run before TranslateMessage().
    ///
    /// The callback may modify the message, and should return true if the message
    /// should continue to be processed, or false to prevent further processing.
    ///
    /// @param callback the SDL_WindowsMessageHook function to call.
    /// @param userdata a pointer to pass to every iteration of `callback`.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_WindowsMessageHook`
    /// @see #HINT_WINDOWS_ENABLE_MESSAGELOOP
    public void setWindowsMessageHook(
        @Pointer(comment="SDL_WindowsMessageHook") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowsMessageHook);
        try {
            hFunction.invokeExact(
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the D3D9 adapter index that matches the specified display.
    ///
    /// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and
    /// controls on which monitor a full screen application will appear.
    ///
    /// @param displayID the instance of the display to query.
    /// @return the D3D9 adapter index on success or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getDirect3D9AdapterIndex(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDirect3D9AdapterIndex);
        try {
            return (int) hFunction.invokeExact(
                displayID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the DXGI Adapter and Output indices for the specified display.
    ///
    /// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and
    /// `EnumOutputs` respectively to get the objects required to create a DX10 or
    /// DX11 device and swap chain.
    ///
    /// @param displayID the instance of the display to query.
    /// @param adapterIndex a pointer to be filled in with the adapter index.
    /// @param outputIndex a pointer to be filled in with the output index.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getDXGIOutputInfo(
        @NativeType("SDL_DisplayID") @Unsigned int displayID,
        @Nullable IntPtr adapterIndex,
        @Nullable IntPtr outputIndex
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDXGIOutputInfo);
        try {
            return (boolean) hFunction.invokeExact(
                displayID,
                (MemorySegment) (adapterIndex != null ? adapterIndex.segment() : MemorySegment.NULL),
                (MemorySegment) (outputIndex != null ? outputIndex.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a callback for every X11 event.
    ///
    /// The callback may modify the event, and should return true if the event
    /// should continue to be processed, or false to prevent further processing.
    ///
    /// @param callback the SDL_X11EventHook function to call.
    /// @param userdata a pointer to pass to every iteration of `callback`.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void setX11EventHook(
        @Pointer(comment="SDL_X11EventHook") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetX11EventHook);
        try {
            hFunction.invokeExact(
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the UNIX nice value for a thread.
    ///
    /// This uses setpriority() if possible, and RealtimeKit if available.
    ///
    /// @param threadID the Unix thread ID to change priority of.
    /// @param priority the new, Unix-specific, priority value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setLinuxThreadPriority(
        @NativeType("Sint64") long threadID,
        int priority
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetLinuxThreadPriority);
        try {
            return (boolean) hFunction.invokeExact(
                threadID,
                priority
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the priority (not nice level) and scheduling policy for a thread.
    ///
    /// This uses setpriority() if possible, and RealtimeKit if available.
    ///
    /// @param threadID the Unix thread ID to change priority of.
    /// @param sdlPriority the new SDL_ThreadPriority value.
    /// @param schedPolicy the new scheduling policy (SCHED_FIFO, SCHED_RR,
    /// SCHED_OTHER, etc...).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setLinuxThreadPriorityAndPolicy(
        @NativeType("Sint64") long threadID,
        int sdlPriority,
        int schedPolicy
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetLinuxThreadPriorityAndPolicy);
        try {
            return (boolean) hFunction.invokeExact(
                threadID,
                sdlPriority,
                schedPolicy
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to set the animation callback on Apple iOS.
    ///
    /// The function prototype for `callback` is:
    ///
    /// ```c
    /// void callback(void *callbackParam);
    /// ```
    ///
    /// Where its parameter, `callbackParam`, is what was passed as `callbackParam`
    /// to SDL_SetiOSAnimationCallback().
    ///
    /// This function is only available on Apple iOS.
    ///
    /// For more information see:
    ///
    /// https://wiki.libsdl.org/SDL3/README/ios
    ///
    /// Note that if you use the "main callbacks" instead of a standard C `main`
    /// function, you don't have to use this API, as SDL will manage this for you.
    ///
    /// Details on main callbacks are here:
    ///
    /// https://wiki.libsdl.org/SDL3/README/main-functions
    ///
    /// @param window the window for which the animation callback should be set.
    /// @param interval the number of frames after which **callback** will be
    /// called.
    /// @param callback the function to call for every frame.
    /// @param callbackParam a pointer that is passed to `callback`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setiOSEventPump
    public @NativeType("boolean") boolean setiOSAnimationCallback(
        @Nullable SDL_Window window,
        int interval,
        @Pointer(comment="SDL_iOSAnimationCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment callbackParam
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetiOSAnimationCallback);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                interval,
                callback,
                callbackParam
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Use this function to enable or disable the SDL event pump on Apple iOS.
    ///
    /// This function is only available on Apple iOS.
    ///
    /// @param enabled true to enable the event pump, false to disable it.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setiOSAnimationCallback
    public void setiOSEventPump(
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetiOSEventPump);
        try {
            hFunction.invokeExact(
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the Android Java Native Interface Environment of the current thread.
    ///
    /// This is the JNIEnv one needs to access the Java virtual machine from native
    /// code, and is needed for many Android APIs to be usable from C.
    ///
    /// The prototype of the function in SDL's code actually declare a void* return
    /// type, even if the implementation returns a pointer to a JNIEnv. The
    /// rationale being that the SDL headers can avoid including jni.h.
    ///
    /// @return a pointer to Java native interface object (JNIEnv) to which the
    /// current thread is attached, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAndroidActivity
    public @Pointer(comment="void*") MemorySegment getAndroidJNIEnv() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidJNIEnv);
        try {
            return (MemorySegment) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Retrieve the Java instance of the Android activity class.
    ///
    /// The prototype of the function in SDL's code actually declares a void*
    /// return type, even if the implementation returns a jobject. The rationale
    /// being that the SDL headers can avoid including jni.h.
    ///
    /// The jobject returned by the function is a local reference and must be
    /// released by the caller. See the PushLocalFrame() and PopLocalFrame() or
    /// DeleteLocalRef() functions of the Java native interface:
    ///
    /// https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html
    ///
    /// @return the jobject representing the instance of the Activity class of the
    /// Android application, or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAndroidJNIEnv
    public @Pointer(comment="void*") MemorySegment getAndroidActivity() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidActivity);
        try {
            return (MemorySegment) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query Android API level of the current device.
    ///
    /// - API level 35: Android 15 (VANILLA_ICE_CREAM)
    /// - API level 34: Android 14 (UPSIDE_DOWN_CAKE)
    /// - API level 33: Android 13 (TIRAMISU)
    /// - API level 32: Android 12L (S_V2)
    /// - API level 31: Android 12 (S)
    /// - API level 30: Android 11 (R)
    /// - API level 29: Android 10 (Q)
    /// - API level 28: Android 9 (P)
    /// - API level 27: Android 8.1 (O_MR1)
    /// - API level 26: Android 8.0 (O)
    /// - API level 25: Android 7.1 (N_MR1)
    /// - API level 24: Android 7.0 (N)
    /// - API level 23: Android 6.0 (M)
    /// - API level 22: Android 5.1 (LOLLIPOP_MR1)
    /// - API level 21: Android 5.0 (LOLLIPOP, L)
    /// - API level 20: Android 4.4W (KITKAT_WATCH)
    /// - API level 19: Android 4.4 (KITKAT)
    /// - API level 18: Android 4.3 (JELLY_BEAN_MR2)
    /// - API level 17: Android 4.2 (JELLY_BEAN_MR1)
    /// - API level 16: Android 4.1 (JELLY_BEAN)
    /// - API level 15: Android 4.0.3 (ICE_CREAM_SANDWICH_MR1)
    /// - API level 14: Android 4.0 (ICE_CREAM_SANDWICH)
    /// - API level 13: Android 3.2 (HONEYCOMB_MR2)
    /// - API level 12: Android 3.1 (HONEYCOMB_MR1)
    /// - API level 11: Android 3.0 (HONEYCOMB)
    /// - API level 10: Android 2.3.3 (GINGERBREAD_MR1)
    ///
    /// @return the Android API level.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getAndroidSDKVersion() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidSDKVersion);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if the application is running on a Chromebook.
    ///
    /// @return true if this is a Chromebook, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isChromebook() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsChromebook);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if the application is running on a Samsung DeX docking station.
    ///
    /// @return true if this is a DeX docking station, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isDeXMode() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsDeXMode);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Trigger the Android system back button behavior.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void sendAndroidBackButton() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SendAndroidBackButton);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the path used for internal storage for this Android application.
    ///
    /// This path is unique to your application and cannot be written to by other
    /// applications.
    ///
    /// Your internal storage path is typically:
    /// `/data/data/your.app.package/files`.
    ///
    /// This is a C wrapper over `android.content.Context.getFilesDir()`:
    ///
    /// https://developer.android.com/reference/android/content/Context{@code getFilesDir}()
    ///
    /// @return the path used for internal storage or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAndroidExternalStoragePath
    /// @see #getAndroidCachePath
    public BytePtr getAndroidInternalStoragePath() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidInternalStoragePath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of external storage for this Android application.
    ///
    /// The current state of external storage, a bitmask of these values:
    /// `SDL_ANDROID_EXTERNAL_STORAGE_READ`, `SDL_ANDROID_EXTERNAL_STORAGE_WRITE`.
    ///
    /// If external storage is currently unavailable, this will return 0.
    ///
    /// @return the current state of external storage, or 0 if external storage is
    /// currently unavailable.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAndroidExternalStoragePath
    public @NativeType("Uint32") @Unsigned int getAndroidExternalStorageState() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidExternalStorageState);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the path used for external storage for this Android application.
    ///
    /// This path is unique to your application, but is public and can be written
    /// to by other applications.
    ///
    /// Your external storage path is typically:
    /// `/storage/sdcard0/Android/data/your.app.package/files`.
    ///
    /// This is a C wrapper over `android.content.Context.getExternalFilesDir()`:
    ///
    /// https://developer.android.com/reference/android/content/Context{@code getExternalFilesDir}()
    ///
    /// @return the path used for external storage for this application on success
    /// or NULL on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAndroidExternalStorageState
    /// @see #getAndroidInternalStoragePath
    /// @see #getAndroidCachePath
    public BytePtr getAndroidExternalStoragePath() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidExternalStoragePath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the path used for caching data for this Android application.
    ///
    /// This path is unique to your application, but is public and can be written
    /// to by other applications.
    ///
    /// Your cache path is typically: `/data/data/your.app.package/cache/`.
    ///
    /// This is a C wrapper over `android.content.Context.getCacheDir()`:
    ///
    /// https://developer.android.com/reference/android/content/Context{@code getCacheDir}()
    ///
    /// @return the path used for caches for this application on success or NULL
    /// on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getAndroidInternalStoragePath
    /// @see #getAndroidExternalStoragePath
    public BytePtr getAndroidCachePath() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetAndroidCachePath);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request permissions at runtime, asynchronously.
    ///
    /// You do not need to call this for built-in functionality of SDL; recording
    /// from a microphone or reading images from a camera, using standard SDL APIs,
    /// will manage permission requests for you.
    ///
    /// This function never blocks. Instead, the app-supplied callback will be
    /// called when a decision has been made. This callback may happen on a
    /// different thread, and possibly much later, as it might wait on a user to
    /// respond to a system dialog. If permission has already been granted for a
    /// specific entitlement, the callback will still fire, probably on the current
    /// thread and before this function returns.
    ///
    /// If the request submission fails, this function returns -1 and the callback
    /// will NOT be called, but this should only happen in catastrophic conditions,
    /// like memory running out. Normally there will be a yes or no to the request
    /// through the callback.
    ///
    /// For the `permission` parameter, choose a value from here:
    ///
    /// https://developer.android.com/reference/android/Manifest.permission
    ///
    /// @param permission the permission to request.
    /// @param cb the callback to trigger when the request has a response.
    /// @param userdata an app-controlled pointer that is passed to the callback.
    /// @return true if the request was submitted, false if there was an error
    /// submitting. The result of the request is only ever reported
    /// through the callback, not this return value.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean requestAndroidPermission(
        @Nullable BytePtr permission,
        @Pointer(comment="SDL_RequestAndroidPermissionCallback") MemorySegment cb,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RequestAndroidPermission);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (permission != null ? permission.segment() : MemorySegment.NULL),
                cb,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Shows an Android toast notification.
    ///
    /// Toasts are a sort of lightweight notification that are unique to Android.
    ///
    /// https://developer.android.com/guide/topics/ui/notifiers/toasts
    ///
    /// Shows toast in UI thread.
    ///
    /// For the `gravity` parameter, choose a value from here, or -1 if you don't
    /// have a preference:
    ///
    /// https://developer.android.com/reference/android/view/Gravity
    ///
    /// @param message text message to be shown.
    /// @param duration 0=short, 1=long.
    /// @param gravity where the notification should appear on the screen.
    /// @param xoffset set this parameter only when gravity &amp;gt;=0.
    /// @param yoffset set this parameter only when gravity &amp;gt;=0.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean showAndroidToast(
        @Nullable BytePtr message,
        int duration,
        int gravity,
        int xoffset,
        int yoffset
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowAndroidToast);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (message != null ? message.segment() : MemorySegment.NULL),
                duration,
                gravity,
                xoffset,
                yoffset
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Send a user command to SDLActivity.
    ///
    /// Override "boolean onUnhandledMessage(Message msg)" to handle the message.
    ///
    /// @param command user command that must be greater or equal to 0x8000.
    /// @param param user parameter.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean sendAndroidMessage(
        @NativeType("Uint32") @Unsigned int command,
        int param
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SendAndroidMessage);
        try {
            return (boolean) hFunction.invokeExact(
                command,
                param
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if the current device is a tablet.
    ///
    /// If SDL can't determine this, it will return false.
    ///
    /// @return true if the device is a tablet, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isTablet() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsTablet);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query if the current device is a TV.
    ///
    /// If SDL can't determine this, it will return false.
    ///
    /// @return true if the device is a TV, false otherwise.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean isTV() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_IsTV);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the application sandbox environment, if any.
    ///
    /// @return the application sandbox environment or SDL_SANDBOX_NONE if the
    /// application is not running in a sandbox environment.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_Sandbox.class) int getSandbox() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSandbox);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationWillTerminate.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationWillTerminate() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationWillTerminate);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationDidReceiveMemoryWarning.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationDidReceiveMemoryWarning() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationDidReceiveMemoryWarning);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationWillResignActive.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationWillEnterBackground() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationWillEnterBackground);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationDidEnterBackground.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationDidEnterBackground() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationDidEnterBackground);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationWillEnterForeground.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationWillEnterForeground() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationWillEnterForeground);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationDidBecomeActive.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationDidEnterForeground() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationDidEnterForeground);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let iOS apps with external event handling report
    /// onApplicationDidChangeStatusBarOrientation.
    ///
    /// This functions allows iOS apps that have their own event handling to hook
    /// into SDL to generate SDL events. This maps directly to an iOS-specific
    /// event, but since it doesn't do anything iOS-specific internally, it is
    /// available on all platforms, in case it might be useful for some specific
    /// paradigm. Most apps do not need to use this directly; SDL's internal event
    /// code will handle all this for windows created by SDL_CreateWindow!
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void onApplicationDidChangeStatusBarOrientation() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_OnApplicationDidChangeStatusBarOrientation);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets a reference to the global async task queue handle for GDK,
    /// initializing if needed.
    ///
    /// Once you are done with the task queue, you should call
    /// XTaskQueueCloseHandle to reduce the reference count to avoid a resource
    /// leak.
    ///
    /// @param outTaskQueue a pointer to be filled in with task queue handle.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getGDKTaskQueue(
        @Nullable @Pointer XTaskQueueHandle.Ptr outTaskQueue
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGDKTaskQueue);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (outTaskQueue != null ? outTaskQueue.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets a reference to the default user handle for GDK.
    ///
    /// This is effectively a synchronous version of XUserAddAsync, which always
    /// prefers the default user and allows a sign-in UI.
    ///
    /// @param outUserHandle a pointer to be filled in with the default user
    /// handle.
    /// @return true if success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getGDKDefaultUser(
        @Nullable @Pointer XUserHandle.Ptr outUserHandle
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGDKDefaultUser);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (outUserHandle != null ? outUserHandle.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new thread with a default stack size.
    ///
    /// This is a convenience function, equivalent to calling
    /// SDL_CreateThreadWithProperties with the following properties set:
    ///
    /// - `SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER`: `fn`
    /// - `SDL_PROP_THREAD_CREATE_NAME_STRING`: `name`
    /// - `SDL_PROP_THREAD_CREATE_USERDATA_POINTER`: `data`
    ///
    /// Note that this "function" is actually a macro that calls an internal
    /// function with two extra parameters not listed here; they are hidden through
    /// preprocessor macros and are needed to support various C runtimes at the
    /// point of the function call. Language bindings that aren't using the C
    /// headers will need to deal with this.
    ///
    /// Usually, apps should just call this function the same way on every platform
    /// and let the macros hide the details.
    ///
    /// @param fn the SDL_ThreadFunction function to call in the new thread.
    /// @param name the name of the thread.
    /// @param data a pointer that is passed to `fn`.
    /// @return an opaque pointer to the new thread object on success, NULL if the
    /// new thread could not be created; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createThreadWithProperties
    /// @see #waitThread
    public SDL_Thread createThread(
        @Pointer(comment="SDL_ThreadFunction") MemorySegment fn,
        @Nullable BytePtr name,
        @Pointer(comment="void*") MemorySegment data
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateThread);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                fn,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                data
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Thread(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a new thread with with the specified properties.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER`: an SDL_ThreadFunction
    /// value that will be called at the start of the new thread's life.
    /// Required.
    /// - `SDL_PROP_THREAD_CREATE_NAME_STRING`: the name of the new thread, which
    /// might be available to debuggers. Optional, defaults to NULL.
    /// - `SDL_PROP_THREAD_CREATE_USERDATA_POINTER`: an arbitrary app-defined
    /// pointer, which is passed to the entry function on the new thread, as its
    /// only parameter. Optional, defaults to NULL.
    /// - `SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER`: the size, in bytes, of the new
    /// thread's stack. Optional, defaults to 0 (system-defined default).
    ///
    /// SDL makes an attempt to report `SDL_PROP_THREAD_CREATE_NAME_STRING` to the
    /// system, so that debuggers can display it. Not all platforms support this.
    ///
    /// Thread naming is a little complicated: Most systems have very small limits
    /// for the string length (Haiku has 32 bytes, Linux currently has 16, Visual
    /// C++ 6.0 has _nine_!), and possibly other arbitrary rules. You'll have to
    /// see what happens with your system's debugger. The name should be UTF-8 (but
    /// using the naming limits of C identifiers is a better bet). There are no
    /// requirements for thread naming conventions, so long as the string is
    /// null-terminated UTF-8, but these guidelines are helpful in choosing a name:
    ///
    /// https://stackoverflow.com/questions/149932/naming-conventions-for-threads
    ///
    /// If a system imposes requirements, SDL will try to munge the string for it
    /// (truncate, etc), but the original string contents will be available from
    /// SDL_GetThreadName().
    ///
    /// The size (in bytes) of the new stack can be specified with
    /// `SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER`. Zero means "use the system
    /// default" which might be wildly different between platforms. x86 Linux
    /// generally defaults to eight megabytes, an embedded device might be a few
    /// kilobytes instead. You generally need to specify a stack that is a multiple
    /// of the system's page size (in many cases, this is 4 kilobytes, but check
    /// your system documentation).
    ///
    /// Note that this "function" is actually a macro that calls an internal
    /// function with two extra parameters not listed here; they are hidden through
    /// preprocessor macros and are needed to support various C runtimes at the
    /// point of the function call. Language bindings that aren't using the C
    /// headers will need to deal with this.
    ///
    /// The actual symbol in SDL is `SDL_CreateThreadWithPropertiesRuntime`, so
    /// there is no symbol clash, but trying to load an SDL shared library and look
    /// for "SDL_CreateThreadWithProperties" will fail.
    ///
    /// Usually, apps should just call this function the same way on every platform
    /// and let the macros hide the details.
    ///
    /// @param props the properties to use.
    /// @return an opaque pointer to the new thread object on success, NULL if the
    /// new thread could not be created; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createThread
    /// @see #waitThread
    public SDL_Thread createThreadWithProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateThreadWithProperties);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Thread(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// The actual entry point for SDL_CreateThread.
    ///
    /// @param fn the SDL_ThreadFunction function to call in the new thread
    /// @param name the name of the thread
    /// @param data a pointer that is passed to `fn`
    /// @param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.
    /// @param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.
    /// @return an opaque pointer to the new thread object on success, NULL if the
    /// new thread could not be created; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Thread createThreadRuntime(
        @Pointer(comment="SDL_ThreadFunction") MemorySegment fn,
        @Nullable BytePtr name,
        @Pointer(comment="void*") MemorySegment data,
        @Pointer(comment="SDL_FunctionPointer") MemorySegment pfnBeginThread,
        @Pointer(comment="SDL_FunctionPointer") MemorySegment pfnEndThread
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateThreadRuntime);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                fn,
                (MemorySegment) (name != null ? name.segment() : MemorySegment.NULL),
                data,
                pfnBeginThread,
                pfnEndThread
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Thread(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// The actual entry point for SDL_CreateThreadWithProperties.
    ///
    /// @param props the properties to use
    /// @param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.
    /// @param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.
    /// @return an opaque pointer to the new thread object on success, NULL if the
    /// new thread could not be created; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Thread createThreadWithPropertiesRuntime(
        @NativeType("SDL_PropertiesID") @Unsigned int props,
        @Pointer(comment="SDL_FunctionPointer") MemorySegment pfnBeginThread,
        @Pointer(comment="SDL_FunctionPointer") MemorySegment pfnEndThread
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateThreadWithPropertiesRuntime);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props,
                pfnBeginThread,
                pfnEndThread
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Thread(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the thread name as it was specified in SDL_CreateThread().
    ///
    /// @param thread the thread to query.
    /// @return a pointer to a UTF-8 string that names the specified thread, or
    /// NULL if it doesn't have a name.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getThreadName(
        @Nullable SDL_Thread thread
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetThreadName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (thread != null ? thread.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the thread identifier for the current thread.
    ///
    /// This thread identifier is as reported by the underlying operating system.
    /// If SDL is running on a platform that does not support threads the return
    /// value will always be zero.
    ///
    /// This function also returns a valid thread ID when called from the main
    /// thread.
    ///
    /// @return the ID of the current thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getThreadID
    public @NativeType("SDL_ThreadID") @Unsigned long getCurrentThreadID() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentThreadID);
        try {
            return (long) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the thread identifier for the specified thread.
    ///
    /// This thread identifier is as reported by the underlying operating system.
    /// If SDL is running on a platform that does not support threads the return
    /// value will always be zero.
    ///
    /// @param thread the thread to query.
    /// @return the ID of the specified thread, or the ID of the current thread if
    /// `thread` is NULL.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCurrentThreadID
    public @NativeType("SDL_ThreadID") @Unsigned long getThreadID(
        @Nullable SDL_Thread thread
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetThreadID);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (thread != null ? thread.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the priority for the current thread.
    ///
    /// Note that some platforms will not let you alter the priority (or at least,
    /// promote the thread to a higher priority) at all, and some require you to be
    /// an administrator account. Be prepared for this to fail.
    ///
    /// @param priority the SDL_ThreadPriority to set.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setCurrentThreadPriority(
        @EnumType(SDL_ThreadPriority.class) int priority
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetCurrentThreadPriority);
        try {
            return (boolean) hFunction.invokeExact(
                priority
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait for a thread to finish.
    ///
    /// Threads that haven't been detached will remain until this function cleans
    /// them up. Not doing so is a resource leak.
    ///
    /// Once a thread has been cleaned up through this function, the SDL_Thread
    /// that references it becomes invalid and should not be referenced again. As
    /// such, only one thread may call SDL_WaitThread() on another.
    ///
    /// The return code from the thread function is placed in the area pointed to
    /// by `status`, if `status` is not NULL.
    ///
    /// You may not wait on a thread that has been used in a call to
    /// SDL_DetachThread(). Use either that function or this one, but not both, or
    /// behavior is undefined.
    ///
    /// It is safe to pass a NULL thread to this function; it is a no-op.
    ///
    /// Note that the thread pointer is freed by this function and is not valid
    /// afterward.
    ///
    /// @param thread the SDL_Thread pointer that was returned from the
    /// SDL_CreateThread() call that started this thread.
    /// @param status a pointer filled in with the value returned from the thread
    /// function by its 'return', or -1 if the thread has been
    /// detached or isn't valid, may be NULL.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createThread
    /// @see #detachThread
    public void waitThread(
        @Nullable SDL_Thread thread,
        @Nullable IntPtr status
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WaitThread);
        try {
            hFunction.invokeExact(
                (MemorySegment) (thread != null ? thread.segment() : MemorySegment.NULL),
                (MemorySegment) (status != null ? status.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current state of a thread.
    ///
    /// @param thread the thread to query.
    /// @return the current state of a thread, or SDL_THREAD_UNKNOWN if the thread
    /// isn't valid.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_ThreadState`
    public @EnumType(SDL_ThreadState.class) int getThreadState(
        @Nullable SDL_Thread thread
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetThreadState);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (thread != null ? thread.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Let a thread clean up on exit without intervention.
    ///
    /// A thread may be "detached" to signify that it should not remain until
    /// another thread has called SDL_WaitThread() on it. Detaching a thread is
    /// useful for long-running threads that nothing needs to synchronize with or
    /// further manage. When a detached thread is done, it simply goes away.
    ///
    /// There is no way to recover the return code of a detached thread. If you
    /// need this, don't detach the thread and instead use SDL_WaitThread().
    ///
    /// Once a thread is detached, you should usually assume the SDL_Thread isn't
    /// safe to reference again, as it will become invalid immediately upon the
    /// detached thread's exit, instead of remaining until someone has called
    /// SDL_WaitThread() to finally clean it up. As such, don't detach the same
    /// thread more than once.
    ///
    /// If a thread has already exited when passed to SDL_DetachThread(), it will
    /// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
    /// not safe to detach a thread that might be used with SDL_WaitThread().
    ///
    /// You may not call SDL_WaitThread() on a thread that has been detached. Use
    /// either that function or this one, but not both, or behavior is undefined.
    ///
    /// It is safe to pass NULL to this function; it is a no-op.
    ///
    /// @param thread the SDL_Thread pointer that was returned from the
    /// SDL_CreateThread() call that started this thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createThread
    /// @see #waitThread
    public void detachThread(
        @Nullable SDL_Thread thread
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DetachThread);
        try {
            hFunction.invokeExact(
                (MemorySegment) (thread != null ? thread.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current thread's value associated with a thread local storage ID.
    ///
    /// @param id a pointer to the thread local storage ID, may not be NULL.
    /// @return the value associated with the ID for the current thread or NULL if
    /// no value has been set; call SDL_GetError() for more information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setTLS
    public @Pointer(comment="void*") MemorySegment getTLS(
        @Nullable @Pointer ISDL_AtomicInt id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTLS);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (id != null ? id.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the current thread's value associated with a thread local storage ID.
    ///
    /// If the thread local storage ID is not initialized (the value is 0), a new
    /// ID will be created in a thread-safe way, so all calls using a pointer to
    /// the same ID will refer to the same local storage.
    ///
    /// Note that replacing a value from a previous call to this function on the
    /// same thread does _not_ call the previous value's destructor!
    ///
    /// `destructor` can be NULL; it is assumed that `value` does not need to be
    /// cleaned up if so.
    ///
    /// @param id a pointer to the thread local storage ID, may not be NULL.
    /// @param value the value to associate with the ID for the current thread.
    /// @param destructor a function called when the thread exits, to free the
    /// value, may be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTLS
    public @NativeType("boolean") boolean setTLS(
        @Nullable @Pointer ISDL_AtomicInt id,
        @Pointer(comment="void*") MemorySegment value,
        @Pointer(comment="SDL_TLSDestructorCallback") MemorySegment destructor
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTLS);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (id != null ? id.segment() : MemorySegment.NULL),
                value,
                destructor
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Cleanup all TLS data for this thread.
    ///
    /// If you are creating your threads outside of SDL and then calling SDL
    /// functions, you should call this function before your thread exits, to
    /// properly clean up SDL memory.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void cleanupTLS() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CleanupTLS);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets the current preferred date and time format for the system locale.
    ///
    /// This might be a "slow" call that has to query the operating system. It's
    /// best to ask for this once and save the results. However, the preferred
    /// formats can change, usually because the user has changed a system
    /// preference outside of your program.
    ///
    /// @param dateFormat a pointer to the SDL_DateFormat to hold the returned date
    /// format, may be NULL.
    /// @param timeFormat a pointer to the SDL_TimeFormat to hold the returned time
    /// format, may be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getDateTimeLocalePreferences(
        @Nullable @EnumType(SDL_DateFormat.class) IntPtr dateFormat,
        @Nullable @EnumType(SDL_TimeFormat.class) IntPtr timeFormat
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDateTimeLocalePreferences);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dateFormat != null ? dateFormat.segment() : MemorySegment.NULL),
                (MemorySegment) (timeFormat != null ? timeFormat.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets the current value of the system realtime clock in nanoseconds since
    /// Jan 1, 1970 in Universal Coordinated Time (UTC).
    ///
    /// @param ticks the SDL_Time to hold the returned tick count.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getCurrentTime(
        @Nullable @Pointer(comment="SDL_Time") LongPtr ticks
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentTime);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (ticks != null ? ticks.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Converts an SDL_Time in nanoseconds since the epoch to a calendar time in
    /// the SDL_DateTime format.
    ///
    /// @param ticks the SDL_Time to be converted.
    /// @param dt the resulting SDL_DateTime.
    /// @param localTime the resulting SDL_DateTime will be expressed in local time
    /// if true, otherwise it will be in Universal Coordinated
    /// Time (UTC).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean timeToDateTime(
        @NativeType("SDL_Time") long ticks,
        @Nullable @Pointer ISDL_DateTime dt,
        @NativeType("boolean") boolean localTime
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TimeToDateTime);
        try {
            return (boolean) hFunction.invokeExact(
                ticks,
                (MemorySegment) (dt != null ? dt.segment() : MemorySegment.NULL),
                localTime
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.
    ///
    /// This function ignores the day_of_week member of the SDL_DateTime struct, so
    /// it may remain unset.
    ///
    /// @param dt the source SDL_DateTime.
    /// @param ticks the resulting SDL_Time.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean dateTimeToTime(
        @Nullable @Pointer ISDL_DateTime dt,
        @Nullable @Pointer(comment="SDL_Time") LongPtr ticks
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DateTimeToTime);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (dt != null ? dt.segment() : MemorySegment.NULL),
                (MemorySegment) (ticks != null ? ticks.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals
    /// since January 1, 1601).
    ///
    /// This function fills in the two 32-bit values of the FILETIME structure.
    ///
    /// @param ticks the time to convert.
    /// @param dwLowDateTime a pointer filled in with the low portion of the
    /// Windows FILETIME value.
    /// @param dwHighDateTime a pointer filled in with the high portion of the
    /// Windows FILETIME value.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void timeToWindows(
        @NativeType("SDL_Time") long ticks,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr dwLowDateTime,
        @Nullable @Pointer(comment="Uint32") @Unsigned IntPtr dwHighDateTime
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TimeToWindows);
        try {
            hFunction.invokeExact(
                ticks,
                (MemorySegment) (dwLowDateTime != null ? dwLowDateTime.segment() : MemorySegment.NULL),
                (MemorySegment) (dwHighDateTime != null ? dwHighDateTime.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Converts a Windows FILETIME (100-nanosecond intervals since January 1,
    /// 1601) to an SDL time.
    ///
    /// This function takes the two 32-bit values of the FILETIME structure as
    /// parameters.
    ///
    /// @param dwLowDateTime the low portion of the Windows FILETIME value.
    /// @param dwHighDateTime the high portion of the Windows FILETIME value.
    /// @return the converted SDL time.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_Time") long timeFromWindows(
        @NativeType("Uint32") @Unsigned int dwLowDateTime,
        @NativeType("Uint32") @Unsigned int dwHighDateTime
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_TimeFromWindows);
        try {
            return (long) hFunction.invokeExact(
                dwLowDateTime,
                dwHighDateTime
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of days in a month for a given year.
    ///
    /// @param year the year.
    /// @param month the month [1-12].
    /// @return the number of days in the requested month or -1 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getDaysInMonth(
        int year,
        int month
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDaysInMonth);
        try {
            return (int) hFunction.invokeExact(
                year,
                month
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the day of year for a calendar date.
    ///
    /// @param year the year component of the date.
    /// @param month the month component of the date.
    /// @param day the day component of the date.
    /// @return the day of year [0-365] if the date is valid or -1 on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getDayOfYear(
        int year,
        int month,
        int day
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDayOfYear);
        try {
            return (int) hFunction.invokeExact(
                year,
                month,
                day
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the day of week for a calendar date.
    ///
    /// @param year the year component of the date.
    /// @param month the month component of the date.
    /// @param day the day component of the date.
    /// @return a value between 0 and 6 (0 being Sunday) if the date is valid or
    /// -1 on failure; call SDL_GetError() for more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public int getDayOfWeek(
        int year,
        int month,
        int day
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDayOfWeek);
        try {
            return (int) hFunction.invokeExact(
                year,
                month,
                day
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of milliseconds since SDL library initialization.
    ///
    /// @return an unsigned 64-bit value representing the number of milliseconds
    /// since the SDL library initialized.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint64") @Unsigned long getTicks() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTicks);
        try {
            return (long) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of nanoseconds since SDL library initialization.
    ///
    /// @return an unsigned 64-bit value representing the number of nanoseconds
    /// since the SDL library initialized.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("Uint64") @Unsigned long getTicksNS() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTicksNS);
        try {
            return (long) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current value of the high resolution counter.
    ///
    /// This function is typically used for profiling.
    ///
    /// The counter values are only meaningful relative to each other. Differences
    /// between values can be converted to times by using
    /// SDL_GetPerformanceFrequency().
    ///
    /// @return the current counter value.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPerformanceFrequency
    public @NativeType("Uint64") @Unsigned long getPerformanceCounter() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPerformanceCounter);
        try {
            return (long) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the count per second of the high resolution counter.
    ///
    /// @return a platform-specific count per second.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getPerformanceCounter
    public @NativeType("Uint64") @Unsigned long getPerformanceFrequency() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPerformanceFrequency);
        try {
            return (long) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait a specified number of milliseconds before returning.
    ///
    /// This function waits a specified number of milliseconds before returning. It
    /// waits at least the specified time, but possibly longer due to OS
    /// scheduling.
    ///
    /// @param ms the number of milliseconds to delay.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #delayNS
    /// @see #delayPrecise
    public void delay(
        @NativeType("Uint32") @Unsigned int ms
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_Delay);
        try {
            hFunction.invokeExact(
                ms
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait a specified number of nanoseconds before returning.
    ///
    /// This function waits a specified number of nanoseconds before returning. It
    /// waits at least the specified time, but possibly longer due to OS
    /// scheduling.
    ///
    /// @param ns the number of nanoseconds to delay.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #delay
    /// @see #delayPrecise
    public void delayNS(
        @NativeType("Uint64") @Unsigned long ns
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DelayNS);
        try {
            hFunction.invokeExact(
                ns
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Wait a specified number of nanoseconds before returning.
    ///
    /// This function waits a specified number of nanoseconds before returning. It
    /// will attempt to wait as close to the requested time as possible, busy
    /// waiting if necessary, but could return later due to OS scheduling.
    ///
    /// @param ns the number of nanoseconds to delay.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #delay
    /// @see #delayNS
    public void delayPrecise(
        @NativeType("Uint64") @Unsigned long ns
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DelayPrecise);
        try {
            hFunction.invokeExact(
                ns
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Call a callback function at a future time.
    ///
    /// The callback function is passed the current timer interval and the user
    /// supplied parameter from the SDL_AddTimer() call and should return the next
    /// timer interval. If the value returned from the callback is 0, the timer is
    /// canceled and will be removed.
    ///
    /// The callback is run on a separate thread, and for short timeouts can
    /// potentially be called before this function returns.
    ///
    /// Timers take into account the amount of time it took to execute the
    /// callback. For example, if the callback took 250 ms to execute and returned
    /// 1000 (ms), the timer would only wait another 750 ms before its next
    /// iteration.
    ///
    /// Timing may be inexact due to OS scheduling. Be sure to note the current
    /// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your
    /// callback needs to adjust for variances.
    ///
    /// @param interval the timer delay, in milliseconds, passed to `callback`.
    /// @param callback the SDL_TimerCallback function to call when the specified
    /// `interval` elapses.
    /// @param userdata a pointer that is passed to `callback`.
    /// @return a timer ID or 0 on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addTimerNS
    /// @see #removeTimer
    public @NativeType("SDL_TimerID") @Unsigned int addTimer(
        @NativeType("Uint32") @Unsigned int interval,
        @Pointer(comment="SDL_TimerCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddTimer);
        try {
            return (int) hFunction.invokeExact(
                interval,
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Call a callback function at a future time.
    ///
    /// The callback function is passed the current timer interval and the user
    /// supplied parameter from the SDL_AddTimerNS() call and should return the
    /// next timer interval. If the value returned from the callback is 0, the
    /// timer is canceled and will be removed.
    ///
    /// The callback is run on a separate thread, and for short timeouts can
    /// potentially be called before this function returns.
    ///
    /// Timers take into account the amount of time it took to execute the
    /// callback. For example, if the callback took 250 ns to execute and returned
    /// 1000 (ns), the timer would only wait another 750 ns before its next
    /// iteration.
    ///
    /// Timing may be inexact due to OS scheduling. Be sure to note the current
    /// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your
    /// callback needs to adjust for variances.
    ///
    /// @param interval the timer delay, in nanoseconds, passed to `callback`.
    /// @param callback the SDL_TimerCallback function to call when the specified
    /// `interval` elapses.
    /// @param userdata a pointer that is passed to `callback`.
    /// @return a timer ID or 0 on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addTimer
    /// @see #removeTimer
    public @NativeType("SDL_TimerID") @Unsigned int addTimerNS(
        @NativeType("Uint64") @Unsigned long interval,
        @Pointer(comment="SDL_NSTimerCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_AddTimerNS);
        try {
            return (int) hFunction.invokeExact(
                interval,
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Remove a timer created with SDL_AddTimer().
    ///
    /// @param id the ID of the timer to remove.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety It is safe to call this function from any thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #addTimer
    public @NativeType("boolean") boolean removeTimer(
        @NativeType("SDL_TimerID") @Unsigned int id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemoveTimer);
        try {
            return (boolean) hFunction.invokeExact(
                id
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create an icon to be placed in the operating system's tray, or equivalent.
    ///
    /// Many platforms advise not using a system tray unless persistence is a
    /// necessary feature. Avoid needlessly creating a tray icon, as the user may
    /// feel like it clutters their interface.
    ///
    /// Using tray icons require the video subsystem.
    ///
    /// @param icon a surface to be used as icon. May be NULL.
    /// @param tooltip a tooltip to be displayed when the mouse hovers the icon in
    /// UTF-8 encoding. Not supported on all platforms. May be NULL.
    /// @return The newly created system tray icon.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTrayMenu
    /// @see #getTrayMenu
    /// @see #destroyTray
    public SDL_Tray createTray(
        @Nullable SDL_Surface icon,
        @Nullable BytePtr tooltip
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateTray);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (icon != null ? icon.segment() : MemorySegment.NULL),
                (MemorySegment) (tooltip != null ? tooltip.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Tray(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Updates the system tray icon's icon.
    ///
    /// @param tray the tray icon to be updated.
    /// @param icon the new icon. May be NULL.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTray
    public void setTrayIcon(
        @Nullable SDL_Tray tray,
        @Nullable SDL_Surface icon
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTrayIcon);
        try {
            hFunction.invokeExact(
                (MemorySegment) (tray != null ? tray.segment() : MemorySegment.NULL),
                (MemorySegment) (icon != null ? icon.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Updates the system tray icon's tooltip.
    ///
    /// @param tray the tray icon to be updated.
    /// @param tooltip the new tooltip in UTF-8 encoding. May be NULL.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTray
    public void setTrayTooltip(
        @Nullable SDL_Tray tray,
        @Nullable BytePtr tooltip
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTrayTooltip);
        try {
            hFunction.invokeExact(
                (MemorySegment) (tray != null ? tray.segment() : MemorySegment.NULL),
                (MemorySegment) (tooltip != null ? tooltip.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a menu for a system tray.
    ///
    /// This should be called at most once per tray icon.
    ///
    /// This function does the same thing as SDL_CreateTraySubmenu(), except that
    /// it takes a SDL_Tray instead of a SDL_TrayEntry.
    ///
    /// A menu does not need to be destroyed; it will be destroyed with the tray.
    ///
    /// @param tray the tray to bind the menu to.
    /// @return the newly created menu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTray
    /// @see #getTrayMenu
    /// @see #getTrayMenuParentTray
    public SDL_TrayMenu createTrayMenu(
        @Nullable SDL_Tray tray
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateTrayMenu);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (tray != null ? tray.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayMenu(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a submenu for a system tray entry.
    ///
    /// This should be called at most once per tray entry.
    ///
    /// This function does the same thing as SDL_CreateTrayMenu, except that it
    /// takes a SDL_TrayEntry instead of a SDL_Tray.
    ///
    /// A menu does not need to be destroyed; it will be destroyed with the tray.
    ///
    /// @param entry the tray entry to bind the menu to.
    /// @return the newly created menu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #insertTrayEntryAt
    /// @see #getTraySubmenu
    /// @see #getTrayMenuParentEntry
    public SDL_TrayMenu createTraySubmenu(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateTraySubmenu);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayMenu(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets a previously created tray menu.
    ///
    /// You should have called SDL_CreateTrayMenu() on the tray object. This
    /// function allows you to fetch it again later.
    ///
    /// This function does the same thing as SDL_GetTraySubmenu(), except that it
    /// takes a SDL_Tray instead of a SDL_TrayEntry.
    ///
    /// A menu does not need to be destroyed; it will be destroyed with the tray.
    ///
    /// @param tray the tray entry to bind the menu to.
    /// @return the newly created menu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTray
    /// @see #createTrayMenu
    public SDL_TrayMenu getTrayMenu(
        @Nullable SDL_Tray tray
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayMenu);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (tray != null ? tray.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayMenu(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets a previously created tray entry submenu.
    ///
    /// You should have called SDL_CreateTraySubmenu() on the entry object. This
    /// function allows you to fetch it again later.
    ///
    /// This function does the same thing as SDL_GetTrayMenu(), except that it
    /// takes a SDL_TrayEntry instead of a SDL_Tray.
    ///
    /// A menu does not need to be destroyed; it will be destroyed with the tray.
    ///
    /// @param entry the tray entry to bind the menu to.
    /// @return the newly created menu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #insertTrayEntryAt
    /// @see #createTraySubmenu
    public SDL_TrayMenu getTraySubmenu(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTraySubmenu);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayMenu(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Returns a list of entries in the menu, in order.
    ///
    /// @param menu The menu to get entries from.
    /// @param count An optional pointer to obtain the number of entries in the
    /// menu.
    /// @return a NULL-terminated list of entries within the given menu. The
    /// pointer becomes invalid when any function that inserts or deletes
    /// entries in the menu is called.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #removeTrayEntry
    /// @see #insertTrayEntryAt
    public @Pointer SDL_TrayEntry.Ptr getTrayEntries(
        @Nullable SDL_TrayMenu menu,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayEntries);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (menu != null ? menu.segment() : MemorySegment.NULL),
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayEntry.Ptr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Removes a tray entry.
    ///
    /// @param entry The entry to be deleted.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    public void removeTrayEntry(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RemoveTrayEntry);
        try {
            hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Insert a tray entry at a given position.
    ///
    /// If label is NULL, the entry will be a separator. Many functions won't work
    /// for an entry that is a separator.
    ///
    /// An entry does not need to be destroyed; it will be destroyed with the tray.
    ///
    /// @param menu the menu to append the entry to.
    /// @param pos the desired position for the new entry. Entries at or following
    /// this place will be moved. If pos is -1, the entry is appended.
    /// @param label the text to be displayed on the entry, in UTF-8 encoding, or
    /// NULL for a separator.
    /// @param flags a combination of flags, some of which are mandatory.
    /// @return the newly created entry, or NULL if pos is out of bounds.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see `SDL_TrayEntryFlags`
    /// @see #getTrayEntries
    /// @see #removeTrayEntry
    /// @see #getTrayEntryParent
    public SDL_TrayEntry insertTrayEntryAt(
        @Nullable SDL_TrayMenu menu,
        int pos,
        @Nullable BytePtr label,
        @EnumType(SDL_TrayEntryFlags.class) int flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_InsertTrayEntryAt);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (menu != null ? menu.segment() : MemorySegment.NULL),
                pos,
                (MemorySegment) (label != null ? label.segment() : MemorySegment.NULL),
                flags
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayEntry(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the label of an entry.
    ///
    /// An entry cannot change between a separator and an ordinary entry; that is,
    /// it is not possible to set a non-NULL label on an entry that has a NULL
    /// label (separators), or to set a NULL label to an entry that has a non-NULL
    /// label. The function will silently fail if that happens.
    ///
    /// @param entry the entry to be updated.
    /// @param label the new label for the entry in UTF-8 encoding.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    /// @see #getTrayEntryLabel
    public void setTrayEntryLabel(
        @Nullable SDL_TrayEntry entry,
        @Nullable BytePtr label
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTrayEntryLabel);
        try {
            hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL),
                (MemorySegment) (label != null ? label.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets the label of an entry.
    ///
    /// If the returned value is NULL, the entry is a separator.
    ///
    /// @param entry the entry to be read.
    /// @return the label of the entry in UTF-8 encoding.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    /// @see #setTrayEntryLabel
    public BytePtr getTrayEntryLabel(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayEntryLabel);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets whether or not an entry is checked.
    ///
    /// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.
    ///
    /// @param entry the entry to be updated.
    /// @param checked true if the entry should be checked; false otherwise.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    /// @see #getTrayEntryChecked
    public void setTrayEntryChecked(
        @Nullable SDL_TrayEntry entry,
        @NativeType("boolean") boolean checked
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTrayEntryChecked);
        try {
            hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL),
                checked
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets whether or not an entry is checked.
    ///
    /// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.
    ///
    /// @param entry the entry to be read.
    /// @return true if the entry is checked; false otherwise.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    /// @see #setTrayEntryChecked
    public @NativeType("boolean") boolean getTrayEntryChecked(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayEntryChecked);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets whether or not an entry is enabled.
    ///
    /// @param entry the entry to be updated.
    /// @param enabled true if the entry should be enabled; false otherwise.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    /// @see #getTrayEntryEnabled
    public void setTrayEntryEnabled(
        @Nullable SDL_TrayEntry entry,
        @NativeType("boolean") boolean enabled
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTrayEntryEnabled);
        try {
            hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL),
                enabled
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets whether or not an entry is enabled.
    ///
    /// @param entry the entry to be read.
    /// @return true if the entry is enabled; false otherwise.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    /// @see #setTrayEntryEnabled
    public @NativeType("boolean") boolean getTrayEntryEnabled(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayEntryEnabled);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets a callback to be invoked when the entry is selected.
    ///
    /// @param entry the entry to be updated.
    /// @param callback a callback to be invoked when the entry is selected.
    /// @param userdata an optional pointer to pass extra data to the callback when
    /// it will be invoked.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getTrayEntries
    /// @see #insertTrayEntryAt
    public void setTrayEntryCallback(
        @Nullable SDL_TrayEntry entry,
        @Pointer(comment="SDL_TrayCallback") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetTrayEntryCallback);
        try {
            hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL),
                callback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Simulate a click on a tray entry.
    ///
    /// @param entry The entry to activate.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void clickTrayEntry(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ClickTrayEntry);
        try {
            hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroys a tray object.
    ///
    /// This also destroys all associated menus and entries.
    ///
    /// @param tray the tray icon to be destroyed.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTray
    public void destroyTray(
        @Nullable SDL_Tray tray
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyTray);
        try {
            hFunction.invokeExact(
                (MemorySegment) (tray != null ? tray.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets the menu containing a certain tray entry.
    ///
    /// @param entry the entry for which to get the parent menu.
    /// @return the parent menu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #insertTrayEntryAt
    public SDL_TrayMenu getTrayEntryParent(
        @Nullable SDL_TrayEntry entry
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayEntryParent);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (entry != null ? entry.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayMenu(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets the entry for which the menu is a submenu, if the current menu is a
    /// submenu.
    ///
    /// Either this function or SDL_GetTrayMenuParentTray() will return non-NULL
    /// for any given menu.
    ///
    /// @param menu the menu for which to get the parent entry.
    /// @return the parent entry, or NULL if this menu is not a submenu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTraySubmenu
    /// @see #getTrayMenuParentTray
    public SDL_TrayEntry getTrayMenuParentEntry(
        @Nullable SDL_TrayMenu menu
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayMenuParentEntry);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (menu != null ? menu.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_TrayEntry(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Gets the tray for which this menu is the first-level menu, if the current
    /// menu isn't a submenu.
    ///
    /// Either this function or SDL_GetTrayMenuParentEntry() will return non-NULL
    /// for any given menu.
    ///
    /// @param menu the menu for which to get the parent enttrayry.
    /// @return the parent tray, or NULL if this menu is a submenu.
    ///
    /// @threadsafety This function should be called on the thread that created the
    /// tray.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createTrayMenu
    /// @see #getTrayMenuParentEntry
    public SDL_Tray getTrayMenuParentTray(
        @Nullable SDL_TrayMenu menu
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTrayMenuParentTray);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (menu != null ? menu.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Tray(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update the trays.
    ///
    /// This is called automatically by the event loop and is only needed if you're
    /// using trays but aren't handling SDL events.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void updateTrays() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateTrays);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of registered touch devices.
    ///
    /// On some platforms SDL first sees the touch device if it was actually used.
    /// Therefore the returned list might be empty, although devices are available.
    /// After using all devices at least once the number will be correct.
    ///
    /// @param count a pointer filled in with the number of devices returned, may
    /// be NULL.
    /// @return a 0 terminated array of touch device IDs or NULL on failure; call
    /// SDL_GetError() for more information. This should be freed with
    /// SDL_free() when it is no longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="SDL_TouchID") @Unsigned LongPtr getTouchDevices(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTouchDevices);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new LongPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the touch device name as reported from the driver.
    ///
    /// @param touchID the touch device instance ID.
    /// @return touch device name, or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @since This function is available since SDL 3.2.0.
    public BytePtr getTouchDeviceName(
        @NativeType("SDL_TouchID") @Unsigned long touchID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTouchDeviceName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                touchID
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the type of the given touch device.
    ///
    /// @param touchID the ID of a touch device.
    /// @return touch device type.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_TouchDeviceType.class) int getTouchDeviceType(
        @NativeType("SDL_TouchID") @Unsigned long touchID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTouchDeviceType);
        try {
            return (int) hFunction.invokeExact(
                touchID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of active fingers for a given touch device.
    ///
    /// @param touchID the ID of a touch device.
    /// @param count a pointer filled in with the number of fingers returned, can
    /// be NULL.
    /// @return a NULL terminated array of SDL_Finger pointers or NULL on failure;
    /// call SDL_GetError() for more information. This is a single
    /// allocation that should be freed with SDL_free() when it is no
    /// longer needed.
    ///
    /// @since This function is available since SDL 3.2.0.
    public PointerPtr getTouchFingers(
        @NativeType("SDL_TouchID") @Unsigned long touchID,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetTouchFingers);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                touchID,
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the version of SDL that is linked against your program.
    ///
    /// If you are linking to SDL dynamically, then it is possible that the current
    /// version will be different than the version you compiled against. This
    /// function returns the current version, while SDL_VERSION is the version you
    /// compiled with.
    ///
    /// This function may be called safely at any time, even before SDL_Init().
    ///
    /// @return the version of the linked library.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRevision
    public int getVersion() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetVersion);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the code revision of SDL that is linked against your program.
    ///
    /// This value is the revision of the code you are linked with and may be
    /// different from the code you are compiling with, which is found in the
    /// constant SDL_REVISION.
    ///
    /// The revision is arbitrary string (a hash value) uniquely identifying the
    /// exact revision of the SDL library in use, and is only useful in comparing
    /// against other revisions. It is NOT an incrementing number.
    ///
    /// If SDL wasn't built from a git repository with the appropriate tools, this
    /// will return an empty string.
    ///
    /// You shouldn't use this function for anything but logging it for debugging
    /// purposes. The string is not intended to be reliable in any way.
    ///
    /// @return an arbitrary string, uniquely identifying the exact revision of
    /// the SDL library in use.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getVersion
    public BytePtr getRevision() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetRevision);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the number of video drivers compiled into SDL.
    ///
    /// @return the number of built in video drivers.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getVideoDriver
    public int getNumVideoDrivers() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNumVideoDrivers);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of a built in video driver.
    ///
    /// The video drivers are presented in the order in which they are normally
    /// checked during initialization.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
    /// "x11" or "windows". These never have Unicode characters, and are not meant
    /// to be proper names.
    ///
    /// @param index the index of a video driver.
    /// @return the name of the video driver with the given **index**.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumVideoDrivers
    public BytePtr getVideoDriver(
        int index
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetVideoDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                index
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of the currently initialized video driver.
    ///
    /// The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
    /// "x11" or "windows". These never have Unicode characters, and are not meant
    /// to be proper names.
    ///
    /// @return the name of the current video driver or NULL if no driver has been
    /// initialized.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getNumVideoDrivers
    /// @see #getVideoDriver
    public BytePtr getCurrentVideoDriver() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentVideoDriver);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the current system theme.
    ///
    /// @return the current system theme, light, dark, or unknown.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_SystemTheme.class) int getSystemTheme() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetSystemTheme);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of currently connected displays.
    ///
    /// @param count a pointer filled in with the number of displays returned, may
    /// be NULL.
    /// @return a 0 terminated array of display instance IDs or NULL on failure;
    /// call SDL_GetError() for more information. This should be freed
    /// with SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="SDL_DisplayID") @Unsigned IntPtr getDisplays(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplays);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new IntPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return the primary display.
    ///
    /// @return the instance ID of the primary display on success or 0 on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplays
    public @NativeType("SDL_DisplayID") @Unsigned int getPrimaryDisplay() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetPrimaryDisplay);
        try {
            return (int) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a display.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR
    /// headroom above the SDR white point. This is for informational and
    /// diagnostic purposes only, as not all platforms provide this information
    /// at the display level.
    ///
    /// On KMS/DRM:
    ///
    /// - `SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel
    /// orientation" property for the display in degrees of clockwise rotation.
    /// Note that this is provided only as a hint, and the application is
    /// responsible for any coordinate transformations needed to conform to the
    /// requested display orientation.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getDisplayProperties(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayProperties);
        try {
            return (int) hFunction.invokeExact(
                displayID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the name of a display in UTF-8 encoding.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return the name of a display or NULL on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplays
    public BytePtr getDisplayName(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayName);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                displayID
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the desktop area represented by a display.
    ///
    /// The primary display is often located at (0,0), but may be placed at a
    /// different location depending on monitor layout.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @param rect the SDL_Rect structure filled in with the display bounds.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplayUsableBounds
    /// @see #getDisplays
    public @NativeType("boolean") boolean getDisplayBounds(
        @NativeType("SDL_DisplayID") @Unsigned int displayID,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayBounds);
        try {
            return (boolean) hFunction.invokeExact(
                displayID,
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the usable desktop area represented by a display, in screen
    /// coordinates.
    ///
    /// This is the same area as SDL_GetDisplayBounds() reports, but with portions
    /// reserved by the system removed. For example, on Apple's macOS, this
    /// subtracts the area occupied by the menu bar and dock.
    ///
    /// Setting a window to be fullscreen generally bypasses these unusable areas,
    /// so these are good guidelines for the maximum space available to a
    /// non-fullscreen window.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @param rect the SDL_Rect structure filled in with the display bounds.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplayBounds
    /// @see #getDisplays
    public @NativeType("boolean") boolean getDisplayUsableBounds(
        @NativeType("SDL_DisplayID") @Unsigned int displayID,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayUsableBounds);
        try {
            return (boolean) hFunction.invokeExact(
                displayID,
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the orientation of a display when it is unrotated.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return the SDL_DisplayOrientation enum value of the display, or
    /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplays
    public @EnumType(SDL_DisplayOrientation.class) int getNaturalDisplayOrientation(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetNaturalDisplayOrientation);
        try {
            return (int) hFunction.invokeExact(
                displayID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the orientation of a display.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return the SDL_DisplayOrientation enum value of the display, or
    /// `SDL_ORIENTATION_UNKNOWN` if it isn't available.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplays
    public @EnumType(SDL_DisplayOrientation.class) int getCurrentDisplayOrientation(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentDisplayOrientation);
        try {
            return (int) hFunction.invokeExact(
                displayID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the content scale of a display.
    ///
    /// The content scale is the expected scale for content based on the DPI
    /// settings of the display. For example, a 4K display might have a 2.0 (200%)
    /// display scale, which means that the user expects UI elements to be twice as
    /// big on this display, to aid in readability.
    ///
    /// After window creation, SDL_GetWindowDisplayScale() should be used to query
    /// the content scale factor for individual windows instead of querying the
    /// display for a window and calling this function, as the per-window content
    /// scale factor may differ from the base value of the display it is on,
    /// particularly on high-DPI and/or multi-monitor desktop configurations.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return the content scale of the display, or 0.0f on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowDisplayScale
    /// @see #getDisplays
    public float getDisplayContentScale(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayContentScale);
        try {
            return (float) hFunction.invokeExact(
                displayID
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of fullscreen display modes available on a display.
    ///
    /// The display modes are sorted in this priority:
    ///
    /// - w -&amp;gt; largest to smallest
    /// - h -&amp;gt; largest to smallest
    /// - bits per pixel -&amp;gt; more colors to fewer colors
    /// - packed pixel layout -&amp;gt; largest to smallest
    /// - refresh rate -&amp;gt; highest to lowest
    /// - pixel density -&amp;gt; lowest to highest
    ///
    /// @param displayID the instance ID of the display to query.
    /// @param count a pointer filled in with the number of display modes returned,
    /// may be NULL.
    /// @return a NULL terminated array of display mode pointers or NULL on
    /// failure; call SDL_GetError() for more information. This is a
    /// single allocation that should be freed with SDL_free() when it is
    /// no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplays
    public PointerPtr getFullscreenDisplayModes(
        @NativeType("SDL_DisplayID") @Unsigned int displayID,
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetFullscreenDisplayModes);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                displayID,
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new PointerPtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the closest match to the requested display mode.
    ///
    /// The available display modes are scanned and `closest` is filled in with the
    /// closest mode matching the requested mode and returned. The mode format and
    /// refresh rate default to the desktop mode if they are set to 0. The modes
    /// are scanned with size being first priority, format being second priority,
    /// and finally checking the refresh rate. If all the available modes are too
    /// small, then false is returned.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @param w the width in pixels of the desired display mode.
    /// @param h the height in pixels of the desired display mode.
    /// @param refresh_rate the refresh rate of the desired display mode, or 0.0f
    /// for the desktop refresh rate.
    /// @param include_high_density_modes boolean to include high density modes in
    /// the search.
    /// @param closest a pointer filled in with the closest display mode equal to
    /// or larger than the desired mode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplays
    /// @see #getFullscreenDisplayModes
    public @NativeType("boolean") boolean getClosestFullscreenDisplayMode(
        @NativeType("SDL_DisplayID") @Unsigned int displayID,
        int w,
        int h,
        float refresh_rate,
        @NativeType("boolean") boolean include_high_density_modes,
        @Nullable @Pointer ISDL_DisplayMode closest
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetClosestFullscreenDisplayMode);
        try {
            return (boolean) hFunction.invokeExact(
                displayID,
                w,
                h,
                refresh_rate,
                include_high_density_modes,
                (MemorySegment) (closest != null ? closest.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get information about the desktop's display mode.
    ///
    /// There's a difference between this function and SDL_GetCurrentDisplayMode()
    /// when SDL runs fullscreen and has changed the resolution. In that case this
    /// function will return the previous native display mode, and not the current
    /// display mode.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return a pointer to the desktop display mode or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getCurrentDisplayMode
    /// @see #getDisplays
    public @Pointer ISDL_DisplayMode getDesktopDisplayMode(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDesktopDisplayMode);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                displayID
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_DisplayMode(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get information about the current display mode.
    ///
    /// There's a difference between this function and SDL_GetDesktopDisplayMode()
    /// when SDL runs fullscreen and has changed the resolution. In that case this
    /// function will return the current display mode, and not the previous native
    /// display mode.
    ///
    /// @param displayID the instance ID of the display to query.
    /// @return a pointer to the desktop display mode or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDesktopDisplayMode
    /// @see #getDisplays
    public @Pointer ISDL_DisplayMode getCurrentDisplayMode(
        @NativeType("SDL_DisplayID") @Unsigned int displayID
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetCurrentDisplayMode);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                displayID
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_DisplayMode(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the display containing a point.
    ///
    /// @param point the point to query.
    /// @return the instance ID of the display containing the point or 0 on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplayBounds
    /// @see #getDisplays
    public @NativeType("SDL_DisplayID") @Unsigned int getDisplayForPoint(
        @Nullable @Pointer ISDL_Point point
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayForPoint);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (point != null ? point.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the display primarily containing a rect.
    ///
    /// @param rect the rect to query.
    /// @return the instance ID of the display entirely containing the rect or
    /// closest to the center of the rect on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplayBounds
    /// @see #getDisplays
    public @NativeType("SDL_DisplayID") @Unsigned int getDisplayForRect(
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayForRect);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the display associated with a window.
    ///
    /// @param window the window to query.
    /// @return the instance ID of the display containing the center of the window
    /// on success or 0 on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getDisplayBounds
    /// @see #getDisplays
    public @NativeType("SDL_DisplayID") @Unsigned int getDisplayForWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetDisplayForWindow);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the pixel density of a window.
    ///
    /// This is a ratio of pixel size to window size. For example, if the window is
    /// 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it
    /// would have a pixel density of 2.0.
    ///
    /// @param window the window to query.
    /// @return the pixel density or 0.0f on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowDisplayScale
    public float getWindowPixelDensity(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowPixelDensity);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the content display scale relative to a window's pixel size.
    ///
    /// This is a combination of the window pixel density and the display content
    /// scale, and is the expected scale for displaying content in this window. For
    /// example, if a 3840x2160 window had a display scale of 2.0, the user expects
    /// the content to take twice as many pixels and be the same physical size as
    /// if it were being displayed in a 1920x1080 window with a display scale of
    /// 1.0.
    ///
    /// Conceptually this value corresponds to the scale display setting, and is
    /// updated when that setting is changed, or the window moves to a display with
    /// a different scale setting.
    ///
    /// @param window the window to query.
    /// @return the display scale, or 0.0f on failure; call SDL_GetError() for
    /// more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public float getWindowDisplayScale(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowDisplayScale);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the display mode to use when a window is visible and fullscreen.
    ///
    /// This only affects the display mode used when the window is fullscreen. To
    /// change the window size when the window is not fullscreen, use
    /// SDL_SetWindowSize().
    ///
    /// If the window is currently in the fullscreen state, this request is
    /// asynchronous on some windowing systems and the new mode dimensions may not
    /// be applied immediately upon the return of this function. If an immediate
    /// change is required, call SDL_SyncWindow() to block until the changes have
    /// taken effect.
    ///
    /// When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an
    /// SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode
    /// dimensions.
    ///
    /// @param window the window to affect.
    /// @param mode a pointer to the display mode to use, which can be NULL for
    /// borderless fullscreen desktop mode, or one of the fullscreen
    /// modes returned by SDL_GetFullscreenDisplayModes() to set an
    /// exclusive fullscreen mode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowFullscreenMode
    /// @see #setWindowFullscreen
    /// @see #syncWindow
    public @NativeType("boolean") boolean setWindowFullscreenMode(
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_DisplayMode mode
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowFullscreenMode);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (mode != null ? mode.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Query the display mode to use when a window is visible at fullscreen.
    ///
    /// @param window the window to query.
    /// @return a pointer to the exclusive fullscreen mode to use or NULL for
    /// borderless fullscreen desktop mode.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowFullscreenMode
    /// @see #setWindowFullscreen
    public @Pointer ISDL_DisplayMode getWindowFullscreenMode(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowFullscreenMode);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_DisplayMode(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the raw ICC profile data for the screen the window is currently on.
    ///
    /// @param window the window to query.
    /// @param size the size of the ICC profile.
    /// @return the raw ICC profile data on success or NULL on failure; call
    /// SDL_GetError() for more information. This should be freed with
    /// SDL_free() when it is no longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="void*") MemorySegment getWindowICCProfile(
        @Nullable SDL_Window window,
        @Nullable PointerPtr size
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowICCProfile);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (size != null ? size.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the pixel format associated with the window.
    ///
    /// @param window the window to query.
    /// @return the pixel format of the window on success or
    /// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @EnumType(SDL_PixelFormat.class) int getWindowPixelFormat(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowPixelFormat);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a list of valid windows.
    ///
    /// @param count a pointer filled in with the number of windows returned, may
    /// be NULL.
    /// @return a NULL terminated array of SDL_Window pointers or NULL on failure;
    /// call SDL_GetError() for more information. This is a single
    /// allocation that should be freed with SDL_free() when it is no
    /// longer needed.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer SDL_Window.Ptr getWindows(
        @Nullable IntPtr count
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindows);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (count != null ? count.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window.Ptr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a window with the specified dimensions and flags.
    ///
    /// The window size is a request and may be different than expected based on
    /// the desktop layout and window manager policies. Your application should be
    /// prepared to handle a window of any size.
    ///
    /// `flags` may be any of the following OR'd together:
    ///
    /// - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution
    /// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
    /// - `SDL_WINDOW_OCCLUDED`: window partially or completely obscured by another
    /// window
    /// - `SDL_WINDOW_HIDDEN`: window is not visible
    /// - `SDL_WINDOW_BORDERLESS`: no window decoration
    /// - `SDL_WINDOW_RESIZABLE`: window can be resized
    /// - `SDL_WINDOW_MINIMIZED`: window is minimized
    /// - `SDL_WINDOW_MAXIMIZED`: window is maximized
    /// - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus
    /// - `SDL_WINDOW_INPUT_FOCUS`: window has input focus
    /// - `SDL_WINDOW_MOUSE_FOCUS`: window has mouse focus
    /// - `SDL_WINDOW_EXTERNAL`: window not created by SDL
    /// - `SDL_WINDOW_MODAL`: window is modal
    /// - `SDL_WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back
    /// buffer if possible
    /// - `SDL_WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to
    /// MOUSE_GRABBED)
    /// - `SDL_WINDOW_ALWAYS_ON_TOP`: window should always be above others
    /// - `SDL_WINDOW_UTILITY`: window should be treated as a utility window, not
    /// showing in the task bar and window list
    /// - `SDL_WINDOW_TOOLTIP`: window should be treated as a tooltip and does not
    /// get mouse or keyboard focus, requires a parent window
    /// - `SDL_WINDOW_POPUP_MENU`: window should be treated as a popup menu,
    /// requires a parent window
    /// - `SDL_WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input
    /// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
    /// - `SDL_WINDOW_METAL`: window usable with a Metal instance
    /// - `SDL_WINDOW_TRANSPARENT`: window with transparent buffer
    /// - `SDL_WINDOW_NOT_FOCUSABLE`: window should not be focusable
    ///
    /// The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.
    ///
    /// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
    /// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
    ///
    /// The window pixel size may differ from its window coordinate size if the
    /// window is on a high pixel density display. Use SDL_GetWindowSize() to query
    /// the client area's size in window coordinates, and
    /// SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the
    /// drawable size in pixels. Note that the drawable size can vary after the
    /// window is created and should be queried again if you get an
    /// SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.
    ///
    /// If the window is created with any of the SDL_WINDOW_OPENGL or
    /// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
    /// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
    /// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
    ///
    /// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
    /// SDL_CreateWindow() will fail, because SDL_Vulkan_LoadLibrary() will fail.
    ///
    /// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
    /// SDL_CreateWindow() will fail.
    ///
    /// If you intend to use this window with an SDL_Renderer, you should use
    /// SDL_CreateWindowAndRenderer() instead of this function, to avoid window
    /// flicker.
    ///
    /// On non-Apple devices, SDL requires you to either not link to the Vulkan
    /// loader or link to a dynamic library version. This limitation may be removed
    /// in a future version of SDL.
    ///
    /// @param title the title of the window, in UTF-8 encoding.
    /// @param w the width of the window.
    /// @param h the height of the window.
    /// @param flags 0, or one or more SDL_WindowFlags OR'd together.
    /// @return the window that was created or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createWindowAndRenderer
    /// @see #createPopupWindow
    /// @see #createWindowWithProperties
    /// @see #destroyWindow
    public SDL_Window createWindow(
        @Nullable BytePtr title,
        int w,
        int h,
        @EnumType(SDL_WindowFlags.class) long flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateWindow);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (title != null ? title.segment() : MemorySegment.NULL),
                w,
                h,
                flags
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a child popup window of the specified parent window.
    ///
    /// The window size is a request and may be different than expected based on
    /// the desktop layout and window manager policies. Your application should be
    /// prepared to handle a window of any size.
    ///
    /// The flags parameter **must** contain at least one of the following:
    ///
    /// - `SDL_WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any
    /// input events.
    /// - `SDL_WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost
    /// popup menu will implicitly gain the keyboard focus.
    ///
    /// The following flags are not relevant to popup window creation and will be
    /// ignored:
    ///
    /// - `SDL_WINDOW_MINIMIZED`
    /// - `SDL_WINDOW_MAXIMIZED`
    /// - `SDL_WINDOW_FULLSCREEN`
    /// - `SDL_WINDOW_BORDERLESS`
    ///
    /// The following flags are incompatible with popup window creation and will
    /// cause it to fail:
    ///
    /// - `SDL_WINDOW_UTILITY`
    /// - `SDL_WINDOW_MODAL`
    ///
    /// The parent parameter **must** be non-null and a valid window. The parent of
    /// a popup window can be either a regular, toplevel window, or another popup
    /// window.
    ///
    /// Popup windows cannot be minimized, maximized, made fullscreen, raised,
    /// flash, be made a modal window, be the parent of a toplevel window, or grab
    /// the mouse and/or keyboard. Attempts to do so will fail.
    ///
    /// Popup windows implicitly do not have a border/decorations and do not appear
    /// on the taskbar/dock or in lists of windows such as alt-tab menus.
    ///
    /// If a parent window is hidden or destroyed, any child popup windows will be
    /// recursively hidden or destroyed as well. Child popup windows not explicitly
    /// hidden will be restored when the parent is shown.
    ///
    /// @param parent the parent of the window, must not be NULL.
    /// @param offset_x the x position of the popup window relative to the origin
    /// of the parent.
    /// @param offset_y the y position of the popup window relative to the origin
    /// of the parent window.
    /// @param w the width of the window.
    /// @param h the height of the window.
    /// @param flags SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP_MENU, and zero or more
    /// additional SDL_WindowFlags OR'd together.
    /// @return the window that was created or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createWindow
    /// @see #createWindowWithProperties
    /// @see #destroyWindow
    /// @see #getWindowParent
    public SDL_Window createPopupWindow(
        @Nullable SDL_Window parent,
        int offset_x,
        int offset_y,
        int w,
        int h,
        @EnumType(SDL_WindowFlags.class) long flags
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreatePopupWindow);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (parent != null ? parent.segment() : MemorySegment.NULL),
                offset_x,
                offset_y,
                w,
                h,
                flags
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create a window with the specified properties.
    ///
    /// The window size is a request and may be different than expected based on
    /// the desktop layout and window manager policies. Your application should be
    /// prepared to handle a window of any size.
    ///
    /// These are the supported properties:
    ///
    /// - `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should
    /// be always on top
    /// - `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no
    /// window decoration
    /// - `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the
    /// window will be used with an externally managed graphics context.
    /// - `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should
    /// accept keyboard input (defaults true)
    /// - `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should
    /// start in fullscreen mode at desktop resolution
    /// - `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window
    /// - `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start
    /// hidden
    /// - `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window
    /// uses a high pixel density buffer if possible
    /// - `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should
    /// start maximized
    /// - `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu
    /// - `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used
    /// with Metal rendering
    /// - `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should
    /// start minimized
    /// - `SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN`: true if the window is modal to
    /// its parent
    /// - `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts
    /// with grabbed mouse focus
    /// - `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used
    /// with OpenGL rendering
    /// - `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the
    /// parent of this window, required for windows with the "tooltip", "menu",
    /// and "modal" properties
    /// - `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be
    /// resizable
    /// - `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8
    /// encoding
    /// - `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show
    /// transparent in the areas with alpha of 0
    /// - `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip
    /// - `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility
    /// window, not showing in the task bar and window list
    /// - `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used
    /// with Vulkan rendering
    /// - `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window
    /// - `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or
    /// `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
    /// relative to the parent for windows with the "tooltip" or "menu" property
    /// set.
    /// - `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or
    /// `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
    /// relative to the parent for windows with the "tooltip" or "menu" property
    /// set.
    ///
    /// These are additional supported properties on macOS:
    ///
    /// - `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the
    /// `(__unsafe_unretained)` NSWindow associated with the window, if you want
    /// to wrap an existing window.
    /// - `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`
    /// NSView associated with the window, defaults to `[window contentView]`
    ///
    /// These are additional supported properties on Wayland:
    ///
    /// - `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if
    /// the application wants to use the Wayland surface for a custom role and
    /// does not want it attached to an XDG toplevel window. See
    /// [README/wayland](README/wayland) for more information on using custom
    /// surfaces.
    /// - `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the
    /// application wants an associated `wl_egl_window` object to be created and
    /// attached to the window, even if the window does not have the OpenGL
    /// property or `SDL_WINDOW_OPENGL` flag set.
    /// - `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface
    /// associated with the window, if you want to wrap an existing window. See
    /// [README/wayland](README/wayland) for more information.
    ///
    /// These are additional supported properties on Windows:
    ///
    /// - `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the
    /// window, if you want to wrap an existing window.
    /// - `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,
    /// another window to share pixel format with, useful for OpenGL windows
    ///
    /// These are additional supported properties with X11:
    ///
    /// - `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated
    /// with the window, if you want to wrap an existing window.
    ///
    /// The window is implicitly shown if the "hidden" property is not set.
    ///
    /// Windows with the "tooltip" and "menu" properties are popup windows and have
    /// the behaviors and guidelines outlined in SDL_CreatePopupWindow().
    ///
    /// If this window is being created to be used with an SDL_Renderer, you should
    /// not add a graphics API specific property
    /// (`SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that
    /// internally when it chooses a renderer. However, SDL might need to recreate
    /// your window at that point, which may cause the window to appear briefly,
    /// and then flicker as it is recreated. The correct approach to this is to
    /// create the window with the `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN` property
    /// set to true, then create the renderer, then show the window with
    /// SDL_ShowWindow().
    ///
    /// @param props the properties to use.
    /// @return the window that was created or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createProperties
    /// @see #createWindow
    /// @see #destroyWindow
    public SDL_Window createWindowWithProperties(
        @NativeType("SDL_PropertiesID") @Unsigned int props
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_CreateWindowWithProperties);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                props
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the numeric ID of a window.
    ///
    /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
    /// these events to specific SDL_Window objects.
    ///
    /// @param window the window to query.
    /// @return the ID of the window on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowFromID
    public @NativeType("SDL_WindowID") @Unsigned int getWindowID(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowID);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a window from a stored ID.
    ///
    /// The numeric ID is what SDL_WindowEvent references, and is necessary to map
    /// these events to specific SDL_Window objects.
    ///
    /// @param id the ID of the window.
    /// @return the window associated with `id` or NULL if it doesn't exist; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowID
    public SDL_Window getWindowFromID(
        @NativeType("SDL_WindowID") @Unsigned int id
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowFromID);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                id
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get parent of a window.
    ///
    /// @param window the window to query.
    /// @return the parent of the window on success or NULL if the window has no
    /// parent.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createPopupWindow
    public SDL_Window getWindowParent(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowParent);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the properties associated with a window.
    ///
    /// The following read-only properties are provided by SDL:
    ///
    /// - `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped
    /// window
    /// - `SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN`: true if the window has HDR
    /// headroom above the SDR white point. This property can change dynamically
    /// when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
    /// - `SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the
    /// SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the
    /// SDR white level in scRGB colorspace, and on Apple platforms this is
    /// always 1.0 for EDR content. This property can change dynamically when
    /// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
    /// - `SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT`: the additional high dynamic range
    /// that can be displayed, in terms of the SDR white point. When HDR is not
    /// enabled, this will be 1.0. This property can change dynamically when
    /// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
    ///
    /// On Android:
    ///
    /// - `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated
    /// with the window
    /// - `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with
    /// the window
    ///
    /// On iOS:
    ///
    /// - `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`
    /// UIWindow associated with the window
    /// - `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
    /// associated with metal views on the window
    /// - `SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's
    /// framebuffer object. It must be bound when rendering to the screen using
    /// OpenGL.
    /// - `SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's
    /// renderbuffer object. It must be bound when SDL_GL_SwapWindow is called.
    /// - `SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL
    /// view's resolve framebuffer, when MSAA is used.
    ///
    /// On KMS/DRM:
    ///
    /// - `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated
    /// with the window (e.g. the X in /dev/dri/cardX)
    /// - `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the
    /// window
    /// - `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated
    /// with the window
    ///
    /// On macOS:
    ///
    /// - `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`
    /// NSWindow associated with the window
    /// - `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
    /// assocated with metal views on the window
    ///
    /// On OpenVR:
    ///
    /// - `SDL_PROP_WINDOW_OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the
    /// associated overlay window.
    ///
    /// On Vivante:
    ///
    /// - `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType
    /// associated with the window
    /// - `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType
    /// associated with the window
    /// - `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with
    /// the window
    ///
    /// On Windows:
    ///
    /// - `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window
    /// - `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window
    /// - `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with
    /// the window
    ///
    /// On Wayland:
    ///
    /// Note: The `xdg_*` window objects do not internally persist across window
    /// show/hide calls. They will be null if the window is hidden and must be
    /// queried each time it is shown.
    ///
    /// - `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with
    /// the window
    /// - `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with
    /// the window
    /// - `SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated
    /// with the window
    /// - `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window
    /// associated with the window
    /// - `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated
    /// with the window
    /// - `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role
    /// associated with the window
    /// - 'SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export
    /// handle associated with the window
    /// - `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role
    /// associated with the window
    /// - `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner
    /// associated with the window, in popup mode
    ///
    /// On X11:
    ///
    /// - `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with
    /// the window
    /// - `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with
    /// the window
    /// - `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the
    /// window
    ///
    /// @param window the window to query.
    /// @return a valid property ID on success or 0 on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("SDL_PropertiesID") @Unsigned int getWindowProperties(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowProperties);
        try {
            return (int) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the window flags.
    ///
    /// @param window the window to query.
    /// @return a mask of the SDL_WindowFlags associated with `window`.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createWindow
    /// @see #hideWindow
    /// @see #maximizeWindow
    /// @see #minimizeWindow
    /// @see #setWindowFullscreen
    /// @see #setWindowMouseGrab
    /// @see #showWindow
    public @EnumType(SDL_WindowFlags.class) long getWindowFlags(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowFlags);
        try {
            return (long) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the title of a window.
    ///
    /// This string is expected to be in UTF-8 encoding.
    ///
    /// @param window the window to change.
    /// @param title the desired window title in UTF-8 format.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowTitle
    public @NativeType("boolean") boolean setWindowTitle(
        @Nullable SDL_Window window,
        @Nullable BytePtr title
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowTitle);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (title != null ? title.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the title of a window.
    ///
    /// @param window the window to query.
    /// @return the title of the window in UTF-8 format or "" if there is no
    /// title.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowTitle
    public BytePtr getWindowTitle(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowTitle);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new BytePtr(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the icon for a window.
    ///
    /// If this function is passed a surface with alternate representations, the
    /// surface will be interpreted as the content to be used for 100% display
    /// scale, and the alternate representations will be used for high DPI
    /// situations. For example, if the original surface is 32x32, then on a 2x
    /// macOS display or 200% display scale on Windows, a 64x64 version of the
    /// image will be used, if available. If a matching version of the image isn't
    /// available, the closest larger size image will be downscaled to the
    /// appropriate size and be used instead, if available. Otherwise, the closest
    /// smaller image will be upscaled and be used instead.
    ///
    /// @param window the window to change.
    /// @param icon an SDL_Surface structure containing the icon for the window.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setWindowIcon(
        @Nullable SDL_Window window,
        @Nullable SDL_Surface icon
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowIcon);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (icon != null ? icon.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the window's position be set.
    ///
    /// If the window is in an exclusive fullscreen or maximized state, this
    /// request has no effect.
    ///
    /// This can be used to reposition fullscreen-desktop windows onto a different
    /// display, however, as exclusive fullscreen windows are locked to a specific
    /// display, they can only be repositioned programmatically via
    /// SDL_SetWindowFullscreenMode().
    ///
    /// On some windowing systems this request is asynchronous and the new
    /// coordinates may not have have been applied immediately upon the return of
    /// this function. If an immediate change is required, call SDL_SyncWindow() to
    /// block until the changes have taken effect.
    ///
    /// When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be
    /// emitted with the window's new coordinates. Note that the new coordinates
    /// may not match the exact coordinates requested, as some windowing systems
    /// can restrict the position of the window in certain scenarios (e.g.
    /// constraining the position so the window is always within desktop bounds).
    /// Additionally, as this is just a request, it can be denied by the windowing
    /// system.
    ///
    /// @param window the window to reposition.
    /// @param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or
    /// `SDL_WINDOWPOS_UNDEFINED`.
    /// @param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or
    /// `SDL_WINDOWPOS_UNDEFINED`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowPosition
    /// @see #syncWindow
    public @NativeType("boolean") boolean setWindowPosition(
        @Nullable SDL_Window window,
        int x,
        int y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowPosition);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the position of a window.
    ///
    /// This is the current position of the window as last reported by the
    /// windowing system.
    ///
    /// If you do not need the value for one of the positions a NULL may be passed
    /// in the `x` or `y` parameter.
    ///
    /// @param window the window to query.
    /// @param x a pointer filled in with the x position of the window, may be
    /// NULL.
    /// @param y a pointer filled in with the y position of the window, may be
    /// NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowPosition
    public @NativeType("boolean") boolean getWindowPosition(
        @Nullable SDL_Window window,
        @Nullable IntPtr x,
        @Nullable IntPtr y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowPosition);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (x != null ? x.segment() : MemorySegment.NULL),
                (MemorySegment) (y != null ? y.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the size of a window's client area be set.
    ///
    /// If the window is in a fullscreen or maximized state, this request has no
    /// effect.
    ///
    /// To change the exclusive fullscreen mode of a window, use
    /// SDL_SetWindowFullscreenMode().
    ///
    /// On some windowing systems, this request is asynchronous and the new window
    /// size may not have have been applied immediately upon the return of this
    /// function. If an immediate change is required, call SDL_SyncWindow() to
    /// block until the changes have taken effect.
    ///
    /// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
    /// emitted with the new window dimensions. Note that the new dimensions may
    /// not match the exact size requested, as some windowing systems can restrict
    /// the window size in certain scenarios (e.g. constraining the size of the
    /// content area to remain within the usable desktop bounds). Additionally, as
    /// this is just a request, it can be denied by the windowing system.
    ///
    /// @param window the window to change.
    /// @param w the width of the window, must be &amp;gt; 0.
    /// @param h the height of the window, must be &amp;gt; 0.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSize
    /// @see #setWindowFullscreenMode
    /// @see #syncWindow
    public @NativeType("boolean") boolean setWindowSize(
        @Nullable SDL_Window window,
        int w,
        int h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                w,
                h
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the size of a window's client area.
    ///
    /// The window pixel size may differ from its window coordinate size if the
    /// window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()
    /// or SDL_GetRenderOutputSize() to get the real client area size in pixels.
    ///
    /// @param window the window to query the width and height from.
    /// @param w a pointer filled in with the width of the window, may be NULL.
    /// @param h a pointer filled in with the height of the window, may be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getRenderOutputSize
    /// @see #getWindowSizeInPixels
    /// @see #setWindowSize
    public @NativeType("boolean") boolean getWindowSize(
        @Nullable SDL_Window window,
        @Nullable IntPtr w,
        @Nullable IntPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the safe area for this window.
    ///
    /// Some devices have portions of the screen which are partially obscured or
    /// not interactive, possibly due to on-screen controls, curved edges, camera
    /// notches, TV overscan, etc. This function provides the area of the window
    /// which is safe to have interactable content. You should continue rendering
    /// into the rest of the window, but it should not contain visually important
    /// or interactible content.
    ///
    /// @param window the window to query.
    /// @param rect a pointer filled in with the client area that is safe for
    /// interactive content.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean getWindowSafeArea(
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowSafeArea);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the aspect ratio of a window's client area be set.
    ///
    /// The aspect ratio is the ratio of width divided by height, e.g. 2560x1600
    /// would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are
    /// narrower.
    ///
    /// If, at the time of this request, the window in a fixed-size state, such as
    /// maximized or fullscreen, the request will be deferred until the window
    /// exits this state and becomes resizable again.
    ///
    /// On some windowing systems, this request is asynchronous and the new window
    /// aspect ratio may not have have been applied immediately upon the return of
    /// this function. If an immediate change is required, call SDL_SyncWindow() to
    /// block until the changes have taken effect.
    ///
    /// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
    /// emitted with the new window dimensions. Note that the new dimensions may
    /// not match the exact aspect ratio requested, as some windowing systems can
    /// restrict the window size in certain scenarios (e.g. constraining the size
    /// of the content area to remain within the usable desktop bounds).
    /// Additionally, as this is just a request, it can be denied by the windowing
    /// system.
    ///
    /// @param window the window to change.
    /// @param min_aspect the minimum aspect ratio of the window, or 0.0f for no
    /// limit.
    /// @param max_aspect the maximum aspect ratio of the window, or 0.0f for no
    /// limit.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowAspectRatio
    /// @see #syncWindow
    public @NativeType("boolean") boolean setWindowAspectRatio(
        @Nullable SDL_Window window,
        float min_aspect,
        float max_aspect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowAspectRatio);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                min_aspect,
                max_aspect
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the size of a window's client area.
    ///
    /// @param window the window to query the width and height from.
    /// @param min_aspect a pointer filled in with the minimum aspect ratio of the
    /// window, may be NULL.
    /// @param max_aspect a pointer filled in with the maximum aspect ratio of the
    /// window, may be NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowAspectRatio
    public @NativeType("boolean") boolean getWindowAspectRatio(
        @Nullable SDL_Window window,
        @Nullable FloatPtr min_aspect,
        @Nullable FloatPtr max_aspect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowAspectRatio);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (min_aspect != null ? min_aspect.segment() : MemorySegment.NULL),
                (MemorySegment) (max_aspect != null ? max_aspect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the size of a window's borders (decorations) around the client area.
    ///
    /// Note: If this function fails (returns false), the size values will be
    /// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
    /// window in question was borderless.
    ///
    /// Note: This function may fail on systems where the window has not yet been
    /// decorated by the display server (for example, immediately after calling
    /// SDL_CreateWindow). It is recommended that you wait at least until the
    /// window has been presented and composited, so that the window system has a
    /// chance to decorate the window and provide the border dimensions to SDL.
    ///
    /// This function also returns false if getting the information is not
    /// supported.
    ///
    /// @param window the window to query the size values of the border
    /// (decorations) from.
    /// @param top pointer to variable for storing the size of the top border; NULL
    /// is permitted.
    /// @param left pointer to variable for storing the size of the left border;
    /// NULL is permitted.
    /// @param bottom pointer to variable for storing the size of the bottom
    /// border; NULL is permitted.
    /// @param right pointer to variable for storing the size of the right border;
    /// NULL is permitted.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSize
    public @NativeType("boolean") boolean getWindowBordersSize(
        @Nullable SDL_Window window,
        @Nullable IntPtr top,
        @Nullable IntPtr left,
        @Nullable IntPtr bottom,
        @Nullable IntPtr right
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowBordersSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (top != null ? top.segment() : MemorySegment.NULL),
                (MemorySegment) (left != null ? left.segment() : MemorySegment.NULL),
                (MemorySegment) (bottom != null ? bottom.segment() : MemorySegment.NULL),
                (MemorySegment) (right != null ? right.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the size of a window's client area, in pixels.
    ///
    /// @param window the window from which the drawable size should be queried.
    /// @param w a pointer to variable for storing the width in pixels, may be
    /// NULL.
    /// @param h a pointer to variable for storing the height in pixels, may be
    /// NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createWindow
    /// @see #getWindowSize
    public @NativeType("boolean") boolean getWindowSizeInPixels(
        @Nullable SDL_Window window,
        @Nullable IntPtr w,
        @Nullable IntPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowSizeInPixels);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the minimum size of a window's client area.
    ///
    /// @param window the window to change.
    /// @param min_w the minimum width of the window, or 0 for no limit.
    /// @param min_h the minimum height of the window, or 0 for no limit.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMinimumSize
    /// @see #setWindowMaximumSize
    public @NativeType("boolean") boolean setWindowMinimumSize(
        @Nullable SDL_Window window,
        int min_w,
        int min_h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowMinimumSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                min_w,
                min_h
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the minimum size of a window's client area.
    ///
    /// @param window the window to query.
    /// @param w a pointer filled in with the minimum width of the window, may be
    /// NULL.
    /// @param h a pointer filled in with the minimum height of the window, may be
    /// NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMaximumSize
    /// @see #setWindowMinimumSize
    public @NativeType("boolean") boolean getWindowMinimumSize(
        @Nullable SDL_Window window,
        @Nullable IntPtr w,
        @Nullable IntPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowMinimumSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the maximum size of a window's client area.
    ///
    /// @param window the window to change.
    /// @param max_w the maximum width of the window, or 0 for no limit.
    /// @param max_h the maximum height of the window, or 0 for no limit.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMaximumSize
    /// @see #setWindowMinimumSize
    public @NativeType("boolean") boolean setWindowMaximumSize(
        @Nullable SDL_Window window,
        int max_w,
        int max_h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowMaximumSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                max_w,
                max_h
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the maximum size of a window's client area.
    ///
    /// @param window the window to query.
    /// @param w a pointer filled in with the maximum width of the window, may be
    /// NULL.
    /// @param h a pointer filled in with the maximum height of the window, may be
    /// NULL.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMinimumSize
    /// @see #setWindowMaximumSize
    public @NativeType("boolean") boolean getWindowMaximumSize(
        @Nullable SDL_Window window,
        @Nullable IntPtr w,
        @Nullable IntPtr h
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowMaximumSize);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (w != null ? w.segment() : MemorySegment.NULL),
                (MemorySegment) (h != null ? h.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the border state of a window.
    ///
    /// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
    /// or remove the border from the actual window. This is a no-op if the
    /// window's border already matches the requested state.
    ///
    /// You can't change the border state of a fullscreen window.
    ///
    /// @param window the window of which to change the border state.
    /// @param bordered false to remove border, true to add border.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowFlags
    public @NativeType("boolean") boolean setWindowBordered(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean bordered
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowBordered);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                bordered
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the user-resizable state of a window.
    ///
    /// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
    /// allow/disallow user resizing of the window. This is a no-op if the window's
    /// resizable state already matches the requested state.
    ///
    /// You can't change the resizable state of a fullscreen window.
    ///
    /// @param window the window of which to change the resizable state.
    /// @param resizable true to allow resizing, false to disallow.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowFlags
    public @NativeType("boolean") boolean setWindowResizable(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean resizable
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowResizable);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                resizable
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the window to always be above the others.
    ///
    /// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
    /// will bring the window to the front and keep the window above the rest.
    ///
    /// @param window the window of which to change the always on top state.
    /// @param on_top true to set the window always on top, false to disable.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowFlags
    public @NativeType("boolean") boolean setWindowAlwaysOnTop(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean on_top
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowAlwaysOnTop);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                on_top
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Show a window.
    ///
    /// @param window the window to show.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #hideWindow
    /// @see #raiseWindow
    public @NativeType("boolean") boolean showWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Hide a window.
    ///
    /// @param window the window to hide.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #showWindow
    /// @see #HIDDEN
    public @NativeType("boolean") boolean hideWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_HideWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that a window be raised above other windows and gain the input
    /// focus.
    ///
    /// The result of this request is subject to desktop window manager policy,
    /// particularly if raising the requested window would result in stealing focus
    /// from another application. If the window is successfully raised and gains
    /// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and
    /// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.
    ///
    /// @param window the window to raise.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean raiseWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RaiseWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the window be made as large as possible.
    ///
    /// Non-resizable windows can't be maximized. The window must have the
    /// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.
    ///
    /// On some windowing systems this request is asynchronous and the new window
    /// state may not have have been applied immediately upon the return of this
    /// function. If an immediate change is required, call SDL_SyncWindow() to
    /// block until the changes have taken effect.
    ///
    /// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be
    /// emitted. Note that, as this is just a request, the windowing system can
    /// deny the state change.
    ///
    /// When maximizing a window, whether the constraints set via
    /// SDL_SetWindowMaximumSize() are honored depends on the policy of the window
    /// manager. Win32 and macOS enforce the constraints when maximizing, while X11
    /// and Wayland window managers may vary.
    ///
    /// @param window the window to maximize.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #minimizeWindow
    /// @see #restoreWindow
    /// @see #syncWindow
    public @NativeType("boolean") boolean maximizeWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MaximizeWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the window be minimized to an iconic representation.
    ///
    /// If the window is in a fullscreen state, this request has no direct effect.
    /// It may alter the state the window is returned to when leaving fullscreen.
    ///
    /// On some windowing systems this request is asynchronous and the new window
    /// state may not have been applied immediately upon the return of this
    /// function. If an immediate change is required, call SDL_SyncWindow() to
    /// block until the changes have taken effect.
    ///
    /// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be
    /// emitted. Note that, as this is just a request, the windowing system can
    /// deny the state change.
    ///
    /// @param window the window to minimize.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #maximizeWindow
    /// @see #restoreWindow
    /// @see #syncWindow
    public @NativeType("boolean") boolean minimizeWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_MinimizeWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the size and position of a minimized or maximized window be
    /// restored.
    ///
    /// If the window is in a fullscreen state, this request has no direct effect.
    /// It may alter the state the window is returned to when leaving fullscreen.
    ///
    /// On some windowing systems this request is asynchronous and the new window
    /// state may not have have been applied immediately upon the return of this
    /// function. If an immediate change is required, call SDL_SyncWindow() to
    /// block until the changes have taken effect.
    ///
    /// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be
    /// emitted. Note that, as this is just a request, the windowing system can
    /// deny the state change.
    ///
    /// @param window the window to restore.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #maximizeWindow
    /// @see #minimizeWindow
    /// @see #syncWindow
    public @NativeType("boolean") boolean restoreWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_RestoreWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request that the window's fullscreen state be changed.
    ///
    /// By default a window in fullscreen state uses borderless fullscreen desktop
    /// mode, but a specific exclusive display mode can be set using
    /// SDL_SetWindowFullscreenMode().
    ///
    /// On some windowing systems this request is asynchronous and the new
    /// fullscreen state may not have have been applied immediately upon the return
    /// of this function. If an immediate change is required, call SDL_SyncWindow()
    /// to block until the changes have taken effect.
    ///
    /// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or
    /// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this
    /// is just a request, it can be denied by the windowing system.
    ///
    /// @param window the window to change.
    /// @param fullscreen true for fullscreen mode, false for windowed mode.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowFullscreenMode
    /// @see #setWindowFullscreenMode
    /// @see #syncWindow
    /// @see #FULLSCREEN
    public @NativeType("boolean") boolean setWindowFullscreen(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean fullscreen
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowFullscreen);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                fullscreen
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Block until any pending window state is finalized.
    ///
    /// On asynchronous windowing systems, this acts as a synchronization barrier
    /// for pending window state. It will attempt to wait until any pending window
    /// state has been applied and is guaranteed to return within finite time. Note
    /// that for how long it can potentially block depends on the underlying window
    /// system, as window state changes may involve somewhat lengthy animations
    /// that must complete before the window is in its final requested state.
    ///
    /// On windowing systems where changes are immediate, this does nothing.
    ///
    /// @param window the window for which to wait for the pending state to be
    /// applied.
    /// @return true on success or false if the operation timed out before the
    /// window was in the requested state.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowSize
    /// @see #setWindowPosition
    /// @see #setWindowFullscreen
    /// @see #minimizeWindow
    /// @see #maximizeWindow
    /// @see #restoreWindow
    /// @see #HINT_VIDEO_SYNC_WINDOW_OPERATIONS
    public @NativeType("boolean") boolean syncWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SyncWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Return whether the window has a surface associated with it.
    ///
    /// @param window the window to query.
    /// @return true if there is a surface associated with the window, or false
    /// otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSurface
    public @NativeType("boolean") boolean windowHasSurface(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_WindowHasSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the SDL surface associated with the window.
    ///
    /// A new surface will be created with the optimal format for the window, if
    /// necessary. This surface will be freed when the window is destroyed. Do not
    /// free this surface.
    ///
    /// This surface will be invalidated if the window is resized. After resizing a
    /// window this function must be called again to return a valid surface.
    ///
    /// You may not combine this with 3D or the rendering API on this window.
    ///
    /// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
    ///
    /// @param window the window to query.
    /// @return the surface associated with the window, or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #destroyWindowSurface
    /// @see #windowHasSurface
    /// @see #updateWindowSurface
    /// @see #updateWindowSurfaceRects
    public SDL_Surface getWindowSurface(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowSurface);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Surface(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Toggle VSync for the window surface.
    ///
    /// When a window surface is created, vsync defaults to
    /// SDL_WINDOW_SURFACE_VSYNC_DISABLED.
    ///
    /// The `vsync` parameter can be 1 to synchronize present with every vertical
    /// refresh, 2 to synchronize present with every second vertical refresh, etc.,
    /// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),
    /// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is
    /// supported by every driver, so you should check the return value to see
    /// whether the requested setting is supported.
    ///
    /// @param window the window.
    /// @param vsync the vertical refresh sync interval.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSurfaceVSync
    public @NativeType("boolean") boolean setWindowSurfaceVSync(
        @Nullable SDL_Window window,
        int vsync
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowSurfaceVSync);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                vsync
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get VSync for the window surface.
    ///
    /// @param window the window to query.
    /// @param vsync an int filled with the current vertical refresh sync interval.
    /// See SDL_SetWindowSurfaceVSync() for the meaning of the value.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowSurfaceVSync
    public @NativeType("boolean") boolean getWindowSurfaceVSync(
        @Nullable SDL_Window window,
        @Nullable IntPtr vsync
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowSurfaceVSync);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (vsync != null ? vsync.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy the window surface to the screen.
    ///
    /// This is the function you use to reflect any changes to the surface on the
    /// screen.
    ///
    /// This function is equivalent to the SDL 1.2 API SDL_Flip().
    ///
    /// @param window the window to update.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSurface
    /// @see #updateWindowSurfaceRects
    public @NativeType("boolean") boolean updateWindowSurface(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateWindowSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Copy areas of the window surface to the screen.
    ///
    /// This is the function you use to reflect changes to portions of the surface
    /// on the screen.
    ///
    /// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
    ///
    /// Note that this function will update _at least_ the rectangles specified,
    /// but this is only intended as an optimization; in practice, this might
    /// update more of the screen (or all of the screen!), depending on what method
    /// SDL uses to send pixels to the system.
    ///
    /// @param window the window to update.
    /// @param rects an array of SDL_Rect structures representing areas of the
    /// surface to copy, in pixels.
    /// @param numrects the number of rectangles.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSurface
    /// @see #updateWindowSurface
    public @NativeType("boolean") boolean updateWindowSurfaceRects(
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_Rect rects,
        int numrects
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_UpdateWindowSurfaceRects);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (rects != null ? rects.segment() : MemorySegment.NULL),
                numrects
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy the surface associated with the window.
    ///
    /// @param window the window to update.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowSurface
    /// @see #windowHasSurface
    public @NativeType("boolean") boolean destroyWindowSurface(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyWindowSurface);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a window's keyboard grab mode.
    ///
    /// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
    /// the Meta/Super key. Note that not all system keyboard shortcuts can be
    /// captured by applications (one example is Ctrl+Alt+Del on Windows).
    ///
    /// This is primarily intended for specialized applications such as VNC clients
    /// or VM frontends. Normal games should not use keyboard grab.
    ///
    /// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
    /// window is full-screen to ensure the user is not trapped in your
    /// application. If you have a custom keyboard shortcut to exit fullscreen
    /// mode, you may suppress this behavior with
    /// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
    ///
    /// If the caller enables a grab while another window is currently grabbed, the
    /// other window loses its grab in favor of the caller's window.
    ///
    /// @param window the window for which the keyboard grab mode should be set.
    /// @param grabbed this is true to grab keyboard, and false to release.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowKeyboardGrab
    /// @see #setWindowMouseGrab
    public @NativeType("boolean") boolean setWindowKeyboardGrab(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean grabbed
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowKeyboardGrab);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                grabbed
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set a window's mouse grab mode.
    ///
    /// Mouse grab confines the mouse cursor to the window.
    ///
    /// @param window the window for which the mouse grab mode should be set.
    /// @param grabbed this is true to grab mouse, and false to release.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMouseRect
    /// @see #setWindowMouseRect
    /// @see #setWindowMouseGrab
    /// @see #setWindowKeyboardGrab
    public @NativeType("boolean") boolean setWindowMouseGrab(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean grabbed
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowMouseGrab);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                grabbed
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a window's keyboard grab mode.
    ///
    /// @param window the window to query.
    /// @return true if keyboard is grabbed, and false otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowKeyboardGrab
    public @NativeType("boolean") boolean getWindowKeyboardGrab(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowKeyboardGrab);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get a window's mouse grab mode.
    ///
    /// @param window the window to query.
    /// @return true if mouse is grabbed, and false otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMouseRect
    /// @see #setWindowMouseRect
    /// @see #setWindowMouseGrab
    /// @see #setWindowKeyboardGrab
    public @NativeType("boolean") boolean getWindowMouseGrab(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowMouseGrab);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the window that currently has an input grab enabled.
    ///
    /// @return the window if input is grabbed or NULL otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowMouseGrab
    /// @see #setWindowKeyboardGrab
    public SDL_Window getGrabbedWindow() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetGrabbedWindow);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Confines the cursor to the specified area of a window.
    ///
    /// Note that this does NOT grab the cursor, it only defines the area a cursor
    /// is restricted to when the window has mouse focus.
    ///
    /// @param window the window that will be associated with the barrier.
    /// @param rect a rectangle area in window-relative coordinates. If NULL the
    /// barrier for the specified window will be destroyed.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowMouseRect
    /// @see #getWindowMouseGrab
    /// @see #setWindowMouseGrab
    public @NativeType("boolean") boolean setWindowMouseRect(
        @Nullable SDL_Window window,
        @Nullable @Pointer ISDL_Rect rect
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowMouseRect);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (rect != null ? rect.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the mouse confinement rectangle of a window.
    ///
    /// @param window the window to query.
    /// @return a pointer to the mouse confinement rectangle of a window, or NULL
    /// if there isn't one.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowMouseRect
    /// @see #getWindowMouseGrab
    /// @see #setWindowMouseGrab
    public @Pointer ISDL_Rect getWindowMouseRect(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowMouseRect);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Rect(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the opacity for a window.
    ///
    /// The parameter `opacity` will be clamped internally between 0.0f
    /// (transparent) and 1.0f (opaque).
    ///
    /// This function also returns false if setting the opacity isn't supported.
    ///
    /// @param window the window which will be made transparent or opaque.
    /// @param opacity the opacity value (0.0f - transparent, 1.0f - opaque).
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #getWindowOpacity
    public @NativeType("boolean") boolean setWindowOpacity(
        @Nullable SDL_Window window,
        float opacity
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowOpacity);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                opacity
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the opacity of a window.
    ///
    /// If transparency isn't supported on this platform, opacity will be returned
    /// as 1.0f without error.
    ///
    /// @param window the window to get the current opacity value from.
    /// @return the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on
    /// failure; call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowOpacity
    public float getWindowOpacity(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GetWindowOpacity);
        try {
            return (float) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the window as a child of a parent window.
    ///
    /// If the window is already the child of an existing window, it will be
    /// reparented to the new owner. Setting the parent window to NULL unparents
    /// the window and removes child window status.
    ///
    /// If a parent window is hidden or destroyed, the operation will be
    /// recursively applied to child windows. Child windows hidden with the parent
    /// that did not have their hidden status explicitly set will be restored when
    /// the parent is shown.
    ///
    /// Attempting to set the parent of a window that is currently in the modal
    /// state will fail. Use SDL_SetWindowModal() to cancel the modal status before
    /// attempting to change the parent.
    ///
    /// Popup windows cannot change parents and attempts to do so will fail.
    ///
    /// Setting a parent window that is currently the sibling or descendent of the
    /// child window results in undefined behavior.
    ///
    /// @param window the window that should become the child of a parent.
    /// @param parent the new parent window for the child window.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowModal
    public @NativeType("boolean") boolean setWindowParent(
        @Nullable SDL_Window window,
        @Nullable SDL_Window parent
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowParent);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (parent != null ? parent.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Toggle the state of the window as modal.
    ///
    /// To enable modal status on a window, the window must currently be the child
    /// window of a parent, or toggling modal status on will fail.
    ///
    /// @param window the window on which to set the modal state.
    /// @param modal true to toggle modal status on, false to toggle it off.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #setWindowParent
    /// @see #MODAL
    public @NativeType("boolean") boolean setWindowModal(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean modal
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowModal);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                modal
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set whether the window may have input focus.
    ///
    /// @param window the window to set focusable state.
    /// @param focusable true to allow input focus, false to not allow input focus.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setWindowFocusable(
        @Nullable SDL_Window window,
        @NativeType("boolean") boolean focusable
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowFocusable);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                focusable
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Display the system-level window menu.
    ///
    /// This default window menu is provided by the system and on some platforms
    /// provides functionality for setting or changing privileged state on the
    /// window, such as moving it between workspaces or displays, or toggling the
    /// always-on-top property.
    ///
    /// On platforms or desktops where this is unsupported, this function does
    /// nothing.
    ///
    /// @param window the window for which the menu will be displayed.
    /// @param x the x coordinate of the menu, relative to the origin (top-left) of
    /// the client area.
    /// @param y the y coordinate of the menu, relative to the origin (top-left) of
    /// the client area.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean showWindowSystemMenu(
        @Nullable SDL_Window window,
        int x,
        int y
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ShowWindowSystemMenu);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                x,
                y
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Provide a callback that decides if a window region has special properties.
    ///
    /// Normally windows are dragged and resized by decorations provided by the
    /// system window manager (a title bar, borders, etc), but for some apps, it
    /// makes sense to drag them from somewhere else inside the window itself; for
    /// example, one might have a borderless window that wants to be draggable from
    /// any part, or simulate its own title bar, etc.
    ///
    /// This function lets the app provide a callback that designates pieces of a
    /// given window as special. This callback is run during event processing if we
    /// need to tell the OS to treat a region of the window specially; the use of
    /// this callback is known as "hit testing."
    ///
    /// Mouse input may not be delivered to your application if it is within a
    /// special area; the OS will often apply that input to moving the window or
    /// resizing the window and not deliver it to the application.
    ///
    /// Specifying NULL for a callback disables hit-testing. Hit-testing is
    /// disabled by default.
    ///
    /// Platforms that don't support this functionality will return false
    /// unconditionally, even if you're attempting to disable hit-testing.
    ///
    /// Your callback may fire at any time, and its firing does not indicate any
    /// specific behavior (for example, on Windows, this certainly might fire when
    /// the OS is deciding whether to drag your window, but it fires for lots of
    /// other reasons, too, some unrelated to anything you probably care about _and
    /// when the mouse isn't actually at the location it is testing_). Since this
    /// can fire at any time, you should try to keep your callback efficient,
    /// devoid of allocations, etc.
    ///
    /// @param window the window to set hit-testing on.
    /// @param callback the function to call when doing a hit-test.
    /// @param callback_data an app-defined void pointer passed to **callback**.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setWindowHitTest(
        @Nullable SDL_Window window,
        @Pointer(comment="SDL_HitTest") MemorySegment callback,
        @Pointer(comment="void*") MemorySegment callback_data
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowHitTest);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                callback,
                callback_data
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the shape of a transparent window.
    ///
    /// This sets the alpha channel of a transparent window and any fully
    /// transparent areas are also transparent to mouse clicks. If you are using
    /// something besides the SDL render API, then you are responsible for drawing
    /// the alpha channel of the window to match the shape alpha channel to get
    /// consistent cross-platform results.
    ///
    /// The shape is copied inside this function, so you can free it afterwards. If
    /// your shape surface changes, you should call SDL_SetWindowShape() again to
    /// update the window. This is an expensive operation, so should be done
    /// sparingly.
    ///
    /// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.
    ///
    /// @param window the window.
    /// @param shape the surface representing the shape of the window, or NULL to
    /// remove any current shape.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean setWindowShape(
        @Nullable SDL_Window window,
        @Nullable SDL_Surface shape
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_SetWindowShape);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (shape != null ? shape.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Request a window to demand attention from the user.
    ///
    /// @param window the window to be flashed.
    /// @param operation the operation to perform.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean flashWindow(
        @Nullable SDL_Window window,
        @EnumType(SDL_FlashOperation.class) int operation
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_FlashWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                operation
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Destroy a window.
    ///
    /// Any child windows owned by the window will be recursively destroyed as
    /// well.
    ///
    /// Note that on some platforms, the visible window may not actually be removed
    /// from the screen until the SDL event loop is pumped again, even though the
    /// SDL_Window is no longer valid after this call.
    ///
    /// @param window the window to destroy.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #createPopupWindow
    /// @see #createWindow
    /// @see #createWindowWithProperties
    public void destroyWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DestroyWindow);
        try {
            hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check whether the screensaver is currently enabled.
    ///
    /// The screensaver is disabled by default.
    ///
    /// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
    ///
    /// @return true if the screensaver is enabled, false if it is disabled.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #disableScreenSaver
    /// @see #enableScreenSaver
    public @NativeType("boolean") boolean screenSaverEnabled() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_ScreenSaverEnabled);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Allow the screen to be blanked by a screen saver.
    ///
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #disableScreenSaver
    /// @see #screenSaverEnabled
    public @NativeType("boolean") boolean enableScreenSaver() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EnableScreenSaver);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Prevent the screen from being blanked by a screen saver.
    ///
    /// If you disable the screensaver, it is automatically re-enabled when SDL
    /// quits.
    ///
    /// The screensaver is disabled by default, but this may by changed by
    /// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.
    ///
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #enableScreenSaver
    /// @see #screenSaverEnabled
    public @NativeType("boolean") boolean disableScreenSaver() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_DisableScreenSaver);
        try {
            return (boolean) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Dynamically load an OpenGL library.
    ///
    /// This should be done after initializing the video driver, but before
    /// creating any OpenGL windows. If no OpenGL library is loaded, the default
    /// library will be loaded upon creation of the first OpenGL window.
    ///
    /// If you do this, you need to retrieve all of the GL functions used in your
    /// program from the dynamic library using SDL_GL_GetProcAddress().
    ///
    /// @param path the platform dependent OpenGL library name, or NULL to open the
    /// default OpenGL library.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_GetProcAddress
    /// @see #GL_UnloadLibrary
    public @NativeType("boolean") boolean GL_LoadLibrary(
        @Nullable BytePtr path
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_LoadLibrary);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (path != null ? path.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get an OpenGL function by name.
    ///
    /// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
    /// GL functions must be retrieved this way. Usually this is used to retrieve
    /// function pointers to OpenGL extensions.
    ///
    /// There are some quirks to looking up OpenGL functions that require some
    /// extra care from the application. If you code carefully, you can handle
    /// these quirks without any platform-specific code, though:
    ///
    /// - On Windows, function pointers are specific to the current GL context;
    /// this means you need to have created a GL context and made it current
    /// before calling SDL_GL_GetProcAddress(). If you recreate your context or
    /// create a second context, you should assume that any existing function
    /// pointers aren't valid to use with it. This is (currently) a
    /// Windows-specific limitation, and in practice lots of drivers don't suffer
    /// this limitation, but it is still the way the wgl API is documented to
    /// work and you should expect crashes if you don't respect it. Store a copy
    /// of the function pointers that comes and goes with context lifespan.
    /// - On X11, function pointers returned by this function are valid for any
    /// context, and can even be looked up before a context is created at all.
    /// This means that, for at least some common OpenGL implementations, if you
    /// look up a function that doesn't exist, you'll get a non-NULL result that
    /// is _NOT_ safe to call. You must always make sure the function is actually
    /// available for a given GL context before calling it, by checking for the
    /// existence of the appropriate extension with SDL_GL_ExtensionSupported(),
    /// or verifying that the version of OpenGL you're using offers the function
    /// as core functionality.
    /// - Some OpenGL drivers, on all platforms, *will* return NULL if a function
    /// isn't supported, but you can't count on this behavior. Check for
    /// extensions you use, and if you get a NULL anyway, act as if that
    /// extension wasn't available. This is probably a bug in the driver, but you
    /// can code defensively for this scenario anyhow.
    /// - Just because you're on Linux/Unix, don't assume you'll be using X11.
    /// Next-gen display servers are waiting to replace it, and may or may not
    /// make the same promises about function pointers.
    /// - OpenGL function pointers must be declared `APIENTRY` as in the example
    /// code. This will ensure the proper calling convention is followed on
    /// platforms where this matters (Win32) thereby avoiding stack corruption.
    ///
    /// @param proc the name of an OpenGL function.
    /// @return a pointer to the named OpenGL function. The returned pointer
    /// should be cast to the appropriate function signature.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_ExtensionSupported
    /// @see #GL_LoadLibrary
    /// @see #GL_UnloadLibrary
    public @Pointer(comment="SDL_FunctionPointer") MemorySegment GL_GetProcAddress(
        @Nullable BytePtr proc
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_GetProcAddress);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (proc != null ? proc.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get an EGL library function by name.
    ///
    /// If an EGL library is loaded, this function allows applications to get entry
    /// points for EGL functions. This is useful to provide to an EGL API and
    /// extension loader.
    ///
    /// @param proc the name of an EGL function.
    /// @return a pointer to the named EGL function. The returned pointer should
    /// be cast to the appropriate function signature.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #EGL_GetCurrentDisplay
    public @Pointer(comment="SDL_FunctionPointer") MemorySegment EGL_GetProcAddress(
        @Nullable BytePtr proc
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EGL_GetProcAddress);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (proc != null ? proc.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_LoadLibrary
    public void GL_UnloadLibrary() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_UnloadLibrary);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Check if an OpenGL extension is supported for the current context.
    ///
    /// This function operates on the current GL context; you must have created a
    /// context and it must be current before calling this function. Do not assume
    /// that all contexts you create will have the same set of extensions
    /// available, or that recreating an existing context will offer the same
    /// extensions again.
    ///
    /// While it's probably not a massive overhead, this function is not an O(1)
    /// operation. Check the extensions you care about after creating the GL
    /// context and save that information somewhere instead of calling the function
    /// every time you need to know.
    ///
    /// @param extension the name of the extension to check.
    /// @return true if the extension is supported, false otherwise.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean GL_ExtensionSupported(
        @Nullable BytePtr extension
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_ExtensionSupported);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (extension != null ? extension.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Reset all previously set OpenGL context attributes to their default values.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_GetAttribute
    /// @see #GL_SetAttribute
    public void GL_ResetAttributes() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_ResetAttributes);
        try {
            hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set an OpenGL window attribute before window creation.
    ///
    /// This function sets the OpenGL attribute `attr` to `value`. The requested
    /// attributes should be set before creating an OpenGL window. You should use
    /// SDL_GL_GetAttribute() to check the values after creating the OpenGL
    /// context, since the values obtained can differ from the requested ones.
    ///
    /// @param attr an SDL_GLAttr enum value specifying the OpenGL attribute to
    /// set.
    /// @param value the desired value for the attribute.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_GetAttribute
    /// @see #GL_ResetAttributes
    public @NativeType("boolean") boolean GL_SetAttribute(
        @EnumType(SDL_GLAttr.class) int attr,
        int value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_SetAttribute);
        try {
            return (boolean) hFunction.invokeExact(
                attr,
                value
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the actual value for an attribute from the current context.
    ///
    /// @param attr an SDL_GLAttr enum value specifying the OpenGL attribute to
    /// get.
    /// @param value a pointer filled in with the current value of `attr`.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_ResetAttributes
    /// @see #GL_SetAttribute
    public @NativeType("boolean") boolean GL_GetAttribute(
        @EnumType(SDL_GLAttr.class) int attr,
        @Nullable IntPtr value
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_GetAttribute);
        try {
            return (boolean) hFunction.invokeExact(
                attr,
                (MemorySegment) (value != null ? value.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Create an OpenGL context for an OpenGL window, and make it current.
    ///
    /// Windows users new to OpenGL should note that, for historical reasons, GL
    /// functions added after OpenGL version 1.1 are not available by default.
    /// Those functions must be loaded at run-time, either with an OpenGL
    /// extension-handling library or with SDL_GL_GetProcAddress() and its related
    /// functions.
    ///
    /// SDL_GLContext is opaque to the application.
    ///
    /// @param window the window to associate with the context.
    /// @return the OpenGL context associated with `window` or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_DestroyContext
    /// @see #GL_MakeCurrent
    public SDL_GLContext GL_CreateContext(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_CreateContext);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GLContext(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set up an OpenGL context for rendering into an OpenGL window.
    ///
    /// The context must have been created with a compatible window.
    ///
    /// @param window the window to associate with the context.
    /// @param context the OpenGL context to associate with the window.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_CreateContext
    public @NativeType("boolean") boolean GL_MakeCurrent(
        @Nullable SDL_Window window,
        @Nullable SDL_GLContext context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_MakeCurrent);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL),
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the currently active OpenGL window.
    ///
    /// @return the currently active OpenGL window on success or NULL on failure;
    /// call SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public SDL_Window GL_GetCurrentWindow() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_GetCurrentWindow);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_Window(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the currently active OpenGL context.
    ///
    /// @return the currently active OpenGL context or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_MakeCurrent
    public SDL_GLContext GL_GetCurrentContext() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_GetCurrentContext);
        try {
            MemorySegment s = (MemorySegment) hFunction.invokeExact(
            );
            return s.equals(MemorySegment.NULL) ? null : new SDL_GLContext(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the currently active EGL display.
    ///
    /// @return the currently active EGL display or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="SDL_EGLDisplay") MemorySegment EGL_GetCurrentDisplay() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EGL_GetCurrentDisplay);
        try {
            return (MemorySegment) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the currently active EGL config.
    ///
    /// @return the currently active EGL config or NULL on failure; call
    /// SDL_GetError() for more information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="SDL_EGLConfig") MemorySegment EGL_GetCurrentConfig() {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EGL_GetCurrentConfig);
        try {
            return (MemorySegment) hFunction.invokeExact(
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the EGL surface associated with the window.
    ///
    /// @param window the window to query.
    /// @return the EGLSurface pointer associated with the window, or NULL on
    /// failure.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @Pointer(comment="SDL_EGLSurface") MemorySegment EGL_GetWindowSurface(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EGL_GetWindowSurface);
        try {
            return (MemorySegment) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Sets the callbacks for defining custom EGLAttrib arrays for EGL
    /// initialization.
    ///
    /// Callbacks that aren't needed can be set to NULL.
    ///
    /// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.
    ///
    /// @param platformAttribCallback callback for attributes to pass to
    /// eglGetPlatformDisplay. May be NULL.
    /// @param surfaceAttribCallback callback for attributes to pass to
    /// eglCreateSurface. May be NULL.
    /// @param contextAttribCallback callback for attributes to pass to
    /// eglCreateContext. May be NULL.
    /// @param userdata a pointer that is passed to the callbacks.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public void EGL_SetAttributeCallbacks(
        @Pointer(comment="SDL_EGLAttribArrayCallback") MemorySegment platformAttribCallback,
        @Pointer(comment="SDL_EGLIntArrayCallback") MemorySegment surfaceAttribCallback,
        @Pointer(comment="SDL_EGLIntArrayCallback") MemorySegment contextAttribCallback,
        @Pointer(comment="void*") MemorySegment userdata
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_EGL_SetAttributeCallbacks);
        try {
            hFunction.invokeExact(
                platformAttribCallback,
                surfaceAttribCallback,
                contextAttribCallback,
                userdata
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Set the swap interval for the current OpenGL context.
    ///
    /// Some systems allow specifying -1 for the interval, to enable adaptive
    /// vsync. Adaptive vsync works the same as vsync, but if you've already missed
    /// the vertical retrace for a given frame, it swaps buffers immediately, which
    /// might be less jarring for the user during occasional framerate drops. If an
    /// application requests adaptive vsync and the system does not support it,
    /// this function will fail and return false. In such a case, you should
    /// probably retry the call with 1 for the interval.
    ///
    /// Adaptive vsync is implemented for some glX drivers with
    /// GLX_EXT_swap_control_tear, and for some Windows drivers with
    /// WGL_EXT_swap_control_tear.
    ///
    /// Read more on the Khronos wiki:
    /// https://www.khronos.org/opengl/wiki/Swap_Interval{@code Adaptive_Vsync}
    ///
    /// @param interval 0 for immediate updates, 1 for updates synchronized with
    /// the vertical retrace, -1 for adaptive vsync.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_GetSwapInterval
    public @NativeType("boolean") boolean GL_SetSwapInterval(
        int interval
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_SetSwapInterval);
        try {
            return (boolean) hFunction.invokeExact(
                interval
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Get the swap interval for the current OpenGL context.
    ///
    /// If the system can't determine the swap interval, or there isn't a valid
    /// current context, this function will set *interval to 0 as a safe default.
    ///
    /// @param interval output interval value. 0 if there is no vertical retrace
    /// synchronization, 1 if the buffer swap is synchronized with
    /// the vertical retrace, and -1 if late swaps happen
    /// immediately instead of waiting for the next retrace.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_SetSwapInterval
    public @NativeType("boolean") boolean GL_GetSwapInterval(
        @Nullable IntPtr interval
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_GetSwapInterval);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (interval != null ? interval.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Update a window with OpenGL rendering.
    ///
    /// This is used with double-buffered OpenGL contexts, which are the default.
    ///
    /// On macOS, make sure you bind 0 to the draw framebuffer before swapping the
    /// window, otherwise nothing will happen. If you aren't using
    /// glBindFramebuffer(), this is the default and you won't have to do anything
    /// extra.
    ///
    /// @param window the window to change.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    public @NativeType("boolean") boolean GL_SwapWindow(
        @Nullable SDL_Window window
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_SwapWindow);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (window != null ? window.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /// Delete an OpenGL context.
    ///
    /// @param context the OpenGL context to be deleted.
    /// @return true on success or false on failure; call SDL_GetError() for more
    /// information.
    ///
    /// @threadsafety This function should only be called on the main thread.
    ///
    /// @since This function is available since SDL 3.2.0.
    ///
    /// @see #GL_CreateContext
    public @NativeType("boolean") boolean GL_DestroyContext(
        @Nullable SDL_GLContext context
    ) {
        MethodHandle hFunction = Objects.requireNonNull(HANDLE$SDL_GL_DestroyContext);
        try {
            return (boolean) hFunction.invokeExact(
                (MemorySegment) (context != null ? context.segment() : MemorySegment.NULL)
            );
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    // endregion

    // region segments and handles
    public final @Nullable MemorySegment SEGMENT$SDL_malloc;
    public final @Nullable MemorySegment SEGMENT$SDL_calloc;
    public final @Nullable MemorySegment SEGMENT$SDL_realloc;
    public final @Nullable MemorySegment SEGMENT$SDL_free;
    public final @Nullable MemorySegment SEGMENT$SDL_GetOriginalMemoryFunctions;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMemoryFunctions;
    public final @Nullable MemorySegment SEGMENT$SDL_SetMemoryFunctions;
    public final @Nullable MemorySegment SEGMENT$SDL_aligned_alloc;
    public final @Nullable MemorySegment SEGMENT$SDL_aligned_free;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumAllocations;
    public final @Nullable MemorySegment SEGMENT$SDL_GetEnvironment;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateEnvironment;
    public final @Nullable MemorySegment SEGMENT$SDL_GetEnvironmentVariable;
    public final @Nullable MemorySegment SEGMENT$SDL_GetEnvironmentVariables;
    public final @Nullable MemorySegment SEGMENT$SDL_SetEnvironmentVariable;
    public final @Nullable MemorySegment SEGMENT$SDL_UnsetEnvironmentVariable;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyEnvironment;
    public final @Nullable MemorySegment SEGMENT$SDL_getenv;
    public final @Nullable MemorySegment SEGMENT$SDL_getenv_unsafe;
    public final @Nullable MemorySegment SEGMENT$SDL_setenv_unsafe;
    public final @Nullable MemorySegment SEGMENT$SDL_unsetenv_unsafe;
    public final @Nullable MemorySegment SEGMENT$SDL_qsort;
    public final @Nullable MemorySegment SEGMENT$SDL_bsearch;
    public final @Nullable MemorySegment SEGMENT$SDL_qsort_r;
    public final @Nullable MemorySegment SEGMENT$SDL_bsearch_r;
    public final @Nullable MemorySegment SEGMENT$SDL_abs;
    public final @Nullable MemorySegment SEGMENT$SDL_isalpha;
    public final @Nullable MemorySegment SEGMENT$SDL_isalnum;
    public final @Nullable MemorySegment SEGMENT$SDL_isblank;
    public final @Nullable MemorySegment SEGMENT$SDL_iscntrl;
    public final @Nullable MemorySegment SEGMENT$SDL_isdigit;
    public final @Nullable MemorySegment SEGMENT$SDL_isxdigit;
    public final @Nullable MemorySegment SEGMENT$SDL_ispunct;
    public final @Nullable MemorySegment SEGMENT$SDL_isspace;
    public final @Nullable MemorySegment SEGMENT$SDL_isupper;
    public final @Nullable MemorySegment SEGMENT$SDL_islower;
    public final @Nullable MemorySegment SEGMENT$SDL_isprint;
    public final @Nullable MemorySegment SEGMENT$SDL_isgraph;
    public final @Nullable MemorySegment SEGMENT$SDL_toupper;
    public final @Nullable MemorySegment SEGMENT$SDL_tolower;
    public final @Nullable MemorySegment SEGMENT$SDL_crc16;
    public final @Nullable MemorySegment SEGMENT$SDL_crc32;
    public final @Nullable MemorySegment SEGMENT$SDL_murmur3_32;
    public final @Nullable MemorySegment SEGMENT$SDL_memcpy;
    public final @Nullable MemorySegment SEGMENT$SDL_memmove;
    public final @Nullable MemorySegment SEGMENT$SDL_memset;
    public final @Nullable MemorySegment SEGMENT$SDL_memset4;
    public final @Nullable MemorySegment SEGMENT$SDL_memcmp;
    public final @Nullable MemorySegment SEGMENT$SDL_wcslen;
    public final @Nullable MemorySegment SEGMENT$SDL_wcsnlen;
    public final @Nullable MemorySegment SEGMENT$SDL_wcslcpy;
    public final @Nullable MemorySegment SEGMENT$SDL_wcslcat;
    public final @Nullable MemorySegment SEGMENT$SDL_wcsdup;
    public final @Nullable MemorySegment SEGMENT$SDL_wcsstr;
    public final @Nullable MemorySegment SEGMENT$SDL_wcsnstr;
    public final @Nullable MemorySegment SEGMENT$SDL_wcscmp;
    public final @Nullable MemorySegment SEGMENT$SDL_wcsncmp;
    public final @Nullable MemorySegment SEGMENT$SDL_wcscasecmp;
    public final @Nullable MemorySegment SEGMENT$SDL_wcsncasecmp;
    public final @Nullable MemorySegment SEGMENT$SDL_wcstol;
    public final @Nullable MemorySegment SEGMENT$SDL_strlen;
    public final @Nullable MemorySegment SEGMENT$SDL_strnlen;
    public final @Nullable MemorySegment SEGMENT$SDL_strlcpy;
    public final @Nullable MemorySegment SEGMENT$SDL_utf8strlcpy;
    public final @Nullable MemorySegment SEGMENT$SDL_strlcat;
    public final @Nullable MemorySegment SEGMENT$SDL_strdup;
    public final @Nullable MemorySegment SEGMENT$SDL_strndup;
    public final @Nullable MemorySegment SEGMENT$SDL_strrev;
    public final @Nullable MemorySegment SEGMENT$SDL_strupr;
    public final @Nullable MemorySegment SEGMENT$SDL_strlwr;
    public final @Nullable MemorySegment SEGMENT$SDL_strchr;
    public final @Nullable MemorySegment SEGMENT$SDL_strrchr;
    public final @Nullable MemorySegment SEGMENT$SDL_strstr;
    public final @Nullable MemorySegment SEGMENT$SDL_strnstr;
    public final @Nullable MemorySegment SEGMENT$SDL_strcasestr;
    public final @Nullable MemorySegment SEGMENT$SDL_strtok_r;
    public final @Nullable MemorySegment SEGMENT$SDL_utf8strlen;
    public final @Nullable MemorySegment SEGMENT$SDL_utf8strnlen;
    public final @Nullable MemorySegment SEGMENT$SDL_itoa;
    public final @Nullable MemorySegment SEGMENT$SDL_uitoa;
    public final @Nullable MemorySegment SEGMENT$SDL_ltoa;
    public final @Nullable MemorySegment SEGMENT$SDL_ultoa;
    public final @Nullable MemorySegment SEGMENT$SDL_lltoa;
    public final @Nullable MemorySegment SEGMENT$SDL_ulltoa;
    public final @Nullable MemorySegment SEGMENT$SDL_atoi;
    public final @Nullable MemorySegment SEGMENT$SDL_atof;
    public final @Nullable MemorySegment SEGMENT$SDL_strtol;
    public final @Nullable MemorySegment SEGMENT$SDL_strtoul;
    public final @Nullable MemorySegment SEGMENT$SDL_strtoll;
    public final @Nullable MemorySegment SEGMENT$SDL_strtoull;
    public final @Nullable MemorySegment SEGMENT$SDL_strtod;
    public final @Nullable MemorySegment SEGMENT$SDL_strcmp;
    public final @Nullable MemorySegment SEGMENT$SDL_strncmp;
    public final @Nullable MemorySegment SEGMENT$SDL_strcasecmp;
    public final @Nullable MemorySegment SEGMENT$SDL_strncasecmp;
    public final @Nullable MemorySegment SEGMENT$SDL_strpbrk;
    public final @Nullable MemorySegment SEGMENT$SDL_StepUTF8;
    public final @Nullable MemorySegment SEGMENT$SDL_StepBackUTF8;
    public final @Nullable MemorySegment SEGMENT$SDL_UCS4ToUTF8;
    public final @Nullable MemorySegment SEGMENT$SDL_srand;
    public final @Nullable MemorySegment SEGMENT$SDL_rand;
    public final @Nullable MemorySegment SEGMENT$SDL_randf;
    public final @Nullable MemorySegment SEGMENT$SDL_rand_bits;
    public final @Nullable MemorySegment SEGMENT$SDL_rand_r;
    public final @Nullable MemorySegment SEGMENT$SDL_randf_r;
    public final @Nullable MemorySegment SEGMENT$SDL_rand_bits_r;
    public final @Nullable MemorySegment SEGMENT$SDL_acos;
    public final @Nullable MemorySegment SEGMENT$SDL_acosf;
    public final @Nullable MemorySegment SEGMENT$SDL_asin;
    public final @Nullable MemorySegment SEGMENT$SDL_asinf;
    public final @Nullable MemorySegment SEGMENT$SDL_atan;
    public final @Nullable MemorySegment SEGMENT$SDL_atanf;
    public final @Nullable MemorySegment SEGMENT$SDL_atan2;
    public final @Nullable MemorySegment SEGMENT$SDL_atan2f;
    public final @Nullable MemorySegment SEGMENT$SDL_ceil;
    public final @Nullable MemorySegment SEGMENT$SDL_ceilf;
    public final @Nullable MemorySegment SEGMENT$SDL_copysign;
    public final @Nullable MemorySegment SEGMENT$SDL_copysignf;
    public final @Nullable MemorySegment SEGMENT$SDL_cos;
    public final @Nullable MemorySegment SEGMENT$SDL_cosf;
    public final @Nullable MemorySegment SEGMENT$SDL_exp;
    public final @Nullable MemorySegment SEGMENT$SDL_expf;
    public final @Nullable MemorySegment SEGMENT$SDL_fabs;
    public final @Nullable MemorySegment SEGMENT$SDL_fabsf;
    public final @Nullable MemorySegment SEGMENT$SDL_floor;
    public final @Nullable MemorySegment SEGMENT$SDL_floorf;
    public final @Nullable MemorySegment SEGMENT$SDL_trunc;
    public final @Nullable MemorySegment SEGMENT$SDL_truncf;
    public final @Nullable MemorySegment SEGMENT$SDL_fmod;
    public final @Nullable MemorySegment SEGMENT$SDL_fmodf;
    public final @Nullable MemorySegment SEGMENT$SDL_isinf;
    public final @Nullable MemorySegment SEGMENT$SDL_isinff;
    public final @Nullable MemorySegment SEGMENT$SDL_isnan;
    public final @Nullable MemorySegment SEGMENT$SDL_isnanf;
    public final @Nullable MemorySegment SEGMENT$SDL_log;
    public final @Nullable MemorySegment SEGMENT$SDL_logf;
    public final @Nullable MemorySegment SEGMENT$SDL_log10;
    public final @Nullable MemorySegment SEGMENT$SDL_log10f;
    public final @Nullable MemorySegment SEGMENT$SDL_modf;
    public final @Nullable MemorySegment SEGMENT$SDL_modff;
    public final @Nullable MemorySegment SEGMENT$SDL_pow;
    public final @Nullable MemorySegment SEGMENT$SDL_powf;
    public final @Nullable MemorySegment SEGMENT$SDL_round;
    public final @Nullable MemorySegment SEGMENT$SDL_roundf;
    public final @Nullable MemorySegment SEGMENT$SDL_lround;
    public final @Nullable MemorySegment SEGMENT$SDL_lroundf;
    public final @Nullable MemorySegment SEGMENT$SDL_scalbn;
    public final @Nullable MemorySegment SEGMENT$SDL_scalbnf;
    public final @Nullable MemorySegment SEGMENT$SDL_sin;
    public final @Nullable MemorySegment SEGMENT$SDL_sinf;
    public final @Nullable MemorySegment SEGMENT$SDL_sqrt;
    public final @Nullable MemorySegment SEGMENT$SDL_sqrtf;
    public final @Nullable MemorySegment SEGMENT$SDL_tan;
    public final @Nullable MemorySegment SEGMENT$SDL_tanf;
    public final @Nullable MemorySegment SEGMENT$SDL_iconv_open;
    public final @Nullable MemorySegment SEGMENT$SDL_iconv_close;
    public final @Nullable MemorySegment SEGMENT$SDL_iconv;
    public final @Nullable MemorySegment SEGMENT$SDL_iconv_string;
    public final @Nullable MemorySegment SEGMENT$SDL_AsyncIOFromFile;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAsyncIOSize;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadAsyncIO;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteAsyncIO;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseAsyncIO;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateAsyncIOQueue;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyAsyncIOQueue;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAsyncIOResult;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitAsyncIOResult;
    public final @Nullable MemorySegment SEGMENT$SDL_SignalAsyncIOQueue;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadFileAsync;
    public final @Nullable MemorySegment SEGMENT$SDL_TryLockSpinlock;
    public final @Nullable MemorySegment SEGMENT$SDL_LockSpinlock;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockSpinlock;
    public final @Nullable MemorySegment SEGMENT$SDL_MemoryBarrierReleaseFunction;
    public final @Nullable MemorySegment SEGMENT$SDL_MemoryBarrierAcquireFunction;
    public final @Nullable MemorySegment SEGMENT$SDL_CompareAndSwapAtomicInt;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAtomicInt;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAtomicInt;
    public final @Nullable MemorySegment SEGMENT$SDL_AddAtomicInt;
    public final @Nullable MemorySegment SEGMENT$SDL_CompareAndSwapAtomicU32;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAtomicU32;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAtomicU32;
    public final @Nullable MemorySegment SEGMENT$SDL_CompareAndSwapAtomicPointer;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAtomicPointer;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAtomicPointer;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumAudioDrivers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentAudioDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioPlaybackDevices;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioRecordingDevices;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioDeviceName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioDeviceFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioDeviceChannelMap;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenAudioDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_IsAudioDevicePhysical;
    public final @Nullable MemorySegment SEGMENT$SDL_IsAudioDevicePlayback;
    public final @Nullable MemorySegment SEGMENT$SDL_PauseAudioDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_ResumeAudioDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_AudioDevicePaused;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioDeviceGain;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioDeviceGain;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseAudioDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_BindAudioStreams;
    public final @Nullable MemorySegment SEGMENT$SDL_BindAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_UnbindAudioStreams;
    public final @Nullable MemorySegment SEGMENT$SDL_UnbindAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamFrequencyRatio;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamFrequencyRatio;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamGain;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamGain;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamInputChannelMap;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamOutputChannelMap;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamInputChannelMap;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamOutputChannelMap;
    public final @Nullable MemorySegment SEGMENT$SDL_PutAudioStreamData;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamData;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamAvailable;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioStreamQueued;
    public final @Nullable MemorySegment SEGMENT$SDL_FlushAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_ClearAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_PauseAudioStreamDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_ResumeAudioStreamDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_AudioStreamDevicePaused;
    public final @Nullable MemorySegment SEGMENT$SDL_LockAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamGetCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioStreamPutCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyAudioStream;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenAudioDeviceStream;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAudioPostmixCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadWAV_IO;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadWAV;
    public final @Nullable MemorySegment SEGMENT$SDL_MixAudio;
    public final @Nullable MemorySegment SEGMENT$SDL_ConvertAudioSamples;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAudioFormatName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSilenceValueForFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_ComposeCustomBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumCameraDrivers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentCameraDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameras;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraSupportedFormats;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraPosition;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenCamera;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraPermissionState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCameraFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_AcquireCameraFrame;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseCameraFrame;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseCamera;
    public final @Nullable MemorySegment SEGMENT$SDL_SetClipboardText;
    public final @Nullable MemorySegment SEGMENT$SDL_GetClipboardText;
    public final @Nullable MemorySegment SEGMENT$SDL_HasClipboardText;
    public final @Nullable MemorySegment SEGMENT$SDL_SetPrimarySelectionText;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPrimarySelectionText;
    public final @Nullable MemorySegment SEGMENT$SDL_HasPrimarySelectionText;
    public final @Nullable MemorySegment SEGMENT$SDL_SetClipboardData;
    public final @Nullable MemorySegment SEGMENT$SDL_ClearClipboardData;
    public final @Nullable MemorySegment SEGMENT$SDL_GetClipboardData;
    public final @Nullable MemorySegment SEGMENT$SDL_HasClipboardData;
    public final @Nullable MemorySegment SEGMENT$SDL_GetClipboardMimeTypes;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumLogicalCPUCores;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCPUCacheLineSize;
    public final @Nullable MemorySegment SEGMENT$SDL_HasAltiVec;
    public final @Nullable MemorySegment SEGMENT$SDL_HasMMX;
    public final @Nullable MemorySegment SEGMENT$SDL_HasSSE;
    public final @Nullable MemorySegment SEGMENT$SDL_HasSSE2;
    public final @Nullable MemorySegment SEGMENT$SDL_HasSSE3;
    public final @Nullable MemorySegment SEGMENT$SDL_HasSSE41;
    public final @Nullable MemorySegment SEGMENT$SDL_HasSSE42;
    public final @Nullable MemorySegment SEGMENT$SDL_HasAVX;
    public final @Nullable MemorySegment SEGMENT$SDL_HasAVX2;
    public final @Nullable MemorySegment SEGMENT$SDL_HasAVX512F;
    public final @Nullable MemorySegment SEGMENT$SDL_HasARMSIMD;
    public final @Nullable MemorySegment SEGMENT$SDL_HasNEON;
    public final @Nullable MemorySegment SEGMENT$SDL_HasLSX;
    public final @Nullable MemorySegment SEGMENT$SDL_HasLASX;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSystemRAM;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSIMDAlignment;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowOpenFileDialog;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowSaveFileDialog;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowOpenFolderDialog;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowFileDialogWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_OutOfMemory;
    public final @Nullable MemorySegment SEGMENT$SDL_GetError;
    public final @Nullable MemorySegment SEGMENT$SDL_ClearError;
    public final @Nullable MemorySegment SEGMENT$SDL_PumpEvents;
    public final @Nullable MemorySegment SEGMENT$SDL_PeepEvents;
    public final @Nullable MemorySegment SEGMENT$SDL_HasEvent;
    public final @Nullable MemorySegment SEGMENT$SDL_HasEvents;
    public final @Nullable MemorySegment SEGMENT$SDL_FlushEvent;
    public final @Nullable MemorySegment SEGMENT$SDL_FlushEvents;
    public final @Nullable MemorySegment SEGMENT$SDL_PollEvent;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitEvent;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitEventTimeout;
    public final @Nullable MemorySegment SEGMENT$SDL_PushEvent;
    public final @Nullable MemorySegment SEGMENT$SDL_SetEventFilter;
    public final @Nullable MemorySegment SEGMENT$SDL_GetEventFilter;
    public final @Nullable MemorySegment SEGMENT$SDL_AddEventWatch;
    public final @Nullable MemorySegment SEGMENT$SDL_RemoveEventWatch;
    public final @Nullable MemorySegment SEGMENT$SDL_FilterEvents;
    public final @Nullable MemorySegment SEGMENT$SDL_SetEventEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_EventEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_RegisterEvents;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowFromEvent;
    public final @Nullable MemorySegment SEGMENT$SDL_GetBasePath;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPrefPath;
    public final @Nullable MemorySegment SEGMENT$SDL_GetUserFolder;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_EnumerateDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_RemovePath;
    public final @Nullable MemorySegment SEGMENT$SDL_RenamePath;
    public final @Nullable MemorySegment SEGMENT$SDL_CopyFile;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPathInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_GlobDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_AddGamepadMapping;
    public final @Nullable MemorySegment SEGMENT$SDL_AddGamepadMappingsFromIO;
    public final @Nullable MemorySegment SEGMENT$SDL_AddGamepadMappingsFromFile;
    public final @Nullable MemorySegment SEGMENT$SDL_ReloadGamepadMappings;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadMappings;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadMappingForGUID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadMapping;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGamepadMapping;
    public final @Nullable MemorySegment SEGMENT$SDL_HasGamepad;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepads;
    public final @Nullable MemorySegment SEGMENT$SDL_IsGamepad;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadNameForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadPathForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadPlayerIndexForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadGUIDForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadVendorForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadProductForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadProductVersionForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadTypeForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRealGamepadTypeForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadMappingForID;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenGamepad;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadFromID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadFromPlayerIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadPath;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRealGamepadType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadPlayerIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGamepadPlayerIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadVendor;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadProduct;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadProductVersion;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadFirmwareVersion;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadSerial;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadSteamHandle;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadConnectionState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadPowerInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_GamepadConnected;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGamepadEventsEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_GamepadEventsEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadBindings;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateGamepads;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadTypeFromString;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadStringForType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadAxisFromString;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadStringForAxis;
    public final @Nullable MemorySegment SEGMENT$SDL_GamepadHasAxis;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadAxis;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadButtonFromString;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadStringForButton;
    public final @Nullable MemorySegment SEGMENT$SDL_GamepadHasButton;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadButton;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadButtonLabelForType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadButtonLabel;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumGamepadTouchpads;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumGamepadTouchpadFingers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadTouchpadFinger;
    public final @Nullable MemorySegment SEGMENT$SDL_GamepadHasSensor;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGamepadSensorEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_GamepadSensorEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadSensorDataRate;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadSensorData;
    public final @Nullable MemorySegment SEGMENT$SDL_RumbleGamepad;
    public final @Nullable MemorySegment SEGMENT$SDL_RumbleGamepadTriggers;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGamepadLED;
    public final @Nullable MemorySegment SEGMENT$SDL_SendGamepadEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseGamepad;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadAppleSFSymbolsNameForButton;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGamepadAppleSFSymbolsNameForAxis;
    public final @Nullable MemorySegment SEGMENT$SDL_GPUSupportsShaderFormats;
    public final @Nullable MemorySegment SEGMENT$SDL_GPUSupportsProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUDeviceWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyGPUDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumGPUDrivers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGPUDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGPUDeviceDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGPUShaderFormats;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUComputePipeline;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUGraphicsPipeline;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUSampler;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUShader;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateGPUTransferBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUBufferName;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUTextureName;
    public final @Nullable MemorySegment SEGMENT$SDL_InsertGPUDebugLabel;
    public final @Nullable MemorySegment SEGMENT$SDL_PushGPUDebugGroup;
    public final @Nullable MemorySegment SEGMENT$SDL_PopGPUDebugGroup;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUSampler;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUTransferBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUComputePipeline;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUShader;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUGraphicsPipeline;
    public final @Nullable MemorySegment SEGMENT$SDL_AcquireGPUCommandBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_PushGPUVertexUniformData;
    public final @Nullable MemorySegment SEGMENT$SDL_PushGPUFragmentUniformData;
    public final @Nullable MemorySegment SEGMENT$SDL_PushGPUComputeUniformData;
    public final @Nullable MemorySegment SEGMENT$SDL_BeginGPURenderPass;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUGraphicsPipeline;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUViewport;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUScissor;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUBlendConstants;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUStencilReference;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUVertexBuffers;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUIndexBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUVertexSamplers;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUVertexStorageTextures;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUVertexStorageBuffers;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUFragmentSamplers;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUFragmentStorageTextures;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUFragmentStorageBuffers;
    public final @Nullable MemorySegment SEGMENT$SDL_DrawGPUIndexedPrimitives;
    public final @Nullable MemorySegment SEGMENT$SDL_DrawGPUPrimitives;
    public final @Nullable MemorySegment SEGMENT$SDL_DrawGPUPrimitivesIndirect;
    public final @Nullable MemorySegment SEGMENT$SDL_DrawGPUIndexedPrimitivesIndirect;
    public final @Nullable MemorySegment SEGMENT$SDL_EndGPURenderPass;
    public final @Nullable MemorySegment SEGMENT$SDL_BeginGPUComputePass;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUComputePipeline;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUComputeSamplers;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUComputeStorageTextures;
    public final @Nullable MemorySegment SEGMENT$SDL_BindGPUComputeStorageBuffers;
    public final @Nullable MemorySegment SEGMENT$SDL_DispatchGPUCompute;
    public final @Nullable MemorySegment SEGMENT$SDL_DispatchGPUComputeIndirect;
    public final @Nullable MemorySegment SEGMENT$SDL_EndGPUComputePass;
    public final @Nullable MemorySegment SEGMENT$SDL_MapGPUTransferBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_UnmapGPUTransferBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_BeginGPUCopyPass;
    public final @Nullable MemorySegment SEGMENT$SDL_UploadToGPUTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_UploadToGPUBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_CopyGPUTextureToTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_CopyGPUBufferToBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_DownloadFromGPUTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_DownloadFromGPUBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_EndGPUCopyPass;
    public final @Nullable MemorySegment SEGMENT$SDL_GenerateMipmapsForGPUTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitGPUTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_WindowSupportsGPUSwapchainComposition;
    public final @Nullable MemorySegment SEGMENT$SDL_WindowSupportsGPUPresentMode;
    public final @Nullable MemorySegment SEGMENT$SDL_ClaimWindowForGPUDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseWindowFromGPUDevice;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUSwapchainParameters;
    public final @Nullable MemorySegment SEGMENT$SDL_SetGPUAllowedFramesInFlight;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGPUSwapchainTextureFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_AcquireGPUSwapchainTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitForGPUSwapchain;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitAndAcquireGPUSwapchainTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_SubmitGPUCommandBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_SubmitGPUCommandBufferAndAcquireFence;
    public final @Nullable MemorySegment SEGMENT$SDL_CancelGPUCommandBuffer;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitForGPUIdle;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitForGPUFences;
    public final @Nullable MemorySegment SEGMENT$SDL_QueryGPUFence;
    public final @Nullable MemorySegment SEGMENT$SDL_ReleaseGPUFence;
    public final @Nullable MemorySegment SEGMENT$SDL_GPUTextureFormatTexelBlockSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GPUTextureSupportsFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_GPUTextureSupportsSampleCount;
    public final @Nullable MemorySegment SEGMENT$SDL_CalculateGPUTextureFormatSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GDKSuspendGPU;
    public final @Nullable MemorySegment SEGMENT$SDL_GDKResumeGPU;
    public final @Nullable MemorySegment SEGMENT$SDL_GUIDToString;
    public final @Nullable MemorySegment SEGMENT$SDL_StringToGUID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHaptics;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHapticNameForID;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenHaptic;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHapticFromID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHapticID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHapticName;
    public final @Nullable MemorySegment SEGMENT$SDL_IsMouseHaptic;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenHapticFromMouse;
    public final @Nullable MemorySegment SEGMENT$SDL_IsJoystickHaptic;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenHapticFromJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseHaptic;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMaxHapticEffects;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMaxHapticEffectsPlaying;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHapticFeatures;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumHapticAxes;
    public final @Nullable MemorySegment SEGMENT$SDL_HapticEffectSupported;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateHapticEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateHapticEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_RunHapticEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_StopHapticEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyHapticEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHapticEffectStatus;
    public final @Nullable MemorySegment SEGMENT$SDL_SetHapticGain;
    public final @Nullable MemorySegment SEGMENT$SDL_SetHapticAutocenter;
    public final @Nullable MemorySegment SEGMENT$SDL_PauseHaptic;
    public final @Nullable MemorySegment SEGMENT$SDL_ResumeHaptic;
    public final @Nullable MemorySegment SEGMENT$SDL_StopHapticEffects;
    public final @Nullable MemorySegment SEGMENT$SDL_HapticRumbleSupported;
    public final @Nullable MemorySegment SEGMENT$SDL_InitHapticRumble;
    public final @Nullable MemorySegment SEGMENT$SDL_PlayHapticRumble;
    public final @Nullable MemorySegment SEGMENT$SDL_StopHapticRumble;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_init;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_exit;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_device_change_count;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_enumerate;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_free_enumeration;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_open;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_open_path;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_write;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_read_timeout;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_read;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_set_nonblocking;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_send_feature_report;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_feature_report;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_input_report;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_close;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_manufacturer_string;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_product_string;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_serial_number_string;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_indexed_string;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_device_info;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_get_report_descriptor;
    public final @Nullable MemorySegment SEGMENT$SDL_hid_ble_scan;
    public final @Nullable MemorySegment SEGMENT$SDL_SetHintWithPriority;
    public final @Nullable MemorySegment SEGMENT$SDL_SetHint;
    public final @Nullable MemorySegment SEGMENT$SDL_ResetHint;
    public final @Nullable MemorySegment SEGMENT$SDL_ResetHints;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHint;
    public final @Nullable MemorySegment SEGMENT$SDL_GetHintBoolean;
    public final @Nullable MemorySegment SEGMENT$SDL_AddHintCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_RemoveHintCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_Init;
    public final @Nullable MemorySegment SEGMENT$SDL_InitSubSystem;
    public final @Nullable MemorySegment SEGMENT$SDL_QuitSubSystem;
    public final @Nullable MemorySegment SEGMENT$SDL_WasInit;
    public final @Nullable MemorySegment SEGMENT$SDL_Quit;
    public final @Nullable MemorySegment SEGMENT$SDL_IsMainThread;
    public final @Nullable MemorySegment SEGMENT$SDL_RunOnMainThread;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAppMetadata;
    public final @Nullable MemorySegment SEGMENT$SDL_SetAppMetadataProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAppMetadataProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_IOFromFile;
    public final @Nullable MemorySegment SEGMENT$SDL_IOFromMem;
    public final @Nullable MemorySegment SEGMENT$SDL_IOFromConstMem;
    public final @Nullable MemorySegment SEGMENT$SDL_IOFromDynamicMem;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenIO;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseIO;
    public final @Nullable MemorySegment SEGMENT$SDL_GetIOProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetIOStatus;
    public final @Nullable MemorySegment SEGMENT$SDL_GetIOSize;
    public final @Nullable MemorySegment SEGMENT$SDL_SeekIO;
    public final @Nullable MemorySegment SEGMENT$SDL_TellIO;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadIO;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteIO;
    public final @Nullable MemorySegment SEGMENT$SDL_FlushIO;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadFile_IO;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadFile;
    public final @Nullable MemorySegment SEGMENT$SDL_SaveFile_IO;
    public final @Nullable MemorySegment SEGMENT$SDL_SaveFile;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU8;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS8;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU16LE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS16LE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU16BE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS16BE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU32LE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS32LE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU32BE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS32BE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU64LE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS64LE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadU64BE;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadS64BE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU8;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS8;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU16LE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS16LE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU16BE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS16BE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU32LE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS32LE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU32BE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS32BE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU64LE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS64LE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteU64BE;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteS64BE;
    public final @Nullable MemorySegment SEGMENT$SDL_LockJoysticks;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockJoysticks;
    public final @Nullable MemorySegment SEGMENT$SDL_HasJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoysticks;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickNameForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickPathForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickPlayerIndexForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickGUIDForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickVendorForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickProductForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickProductVersionForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickTypeForID;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickFromID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickFromPlayerIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_AttachVirtualJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_DetachVirtualJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_IsJoystickVirtual;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickVirtualAxis;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickVirtualBall;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickVirtualButton;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickVirtualHat;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickVirtualTouchpad;
    public final @Nullable MemorySegment SEGMENT$SDL_SendJoystickVirtualSensorData;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickPath;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickPlayerIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickPlayerIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickGUID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickVendor;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickProduct;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickProductVersion;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickFirmwareVersion;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickSerial;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickGUIDInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_JoystickConnected;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumJoystickAxes;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumJoystickBalls;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumJoystickHats;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumJoystickButtons;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickEventsEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_JoystickEventsEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateJoysticks;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickAxis;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickAxisInitialState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickBall;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickHat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickButton;
    public final @Nullable MemorySegment SEGMENT$SDL_RumbleJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_RumbleJoystickTriggers;
    public final @Nullable MemorySegment SEGMENT$SDL_SetJoystickLED;
    public final @Nullable MemorySegment SEGMENT$SDL_SendJoystickEffect;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseJoystick;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickConnectionState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetJoystickPowerInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_HasKeyboard;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyboards;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyboardNameForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyboardFocus;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyboardState;
    public final @Nullable MemorySegment SEGMENT$SDL_ResetKeyboard;
    public final @Nullable MemorySegment SEGMENT$SDL_GetModState;
    public final @Nullable MemorySegment SEGMENT$SDL_SetModState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyFromScancode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetScancodeFromKey;
    public final @Nullable MemorySegment SEGMENT$SDL_SetScancodeName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetScancodeName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetScancodeFromName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetKeyFromName;
    public final @Nullable MemorySegment SEGMENT$SDL_StartTextInput;
    public final @Nullable MemorySegment SEGMENT$SDL_StartTextInputWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_TextInputActive;
    public final @Nullable MemorySegment SEGMENT$SDL_StopTextInput;
    public final @Nullable MemorySegment SEGMENT$SDL_ClearComposition;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextInputArea;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextInputArea;
    public final @Nullable MemorySegment SEGMENT$SDL_HasScreenKeyboardSupport;
    public final @Nullable MemorySegment SEGMENT$SDL_ScreenKeyboardShown;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadObject;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadFunction;
    public final @Nullable MemorySegment SEGMENT$SDL_UnloadObject;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPreferredLocales;
    public final @Nullable MemorySegment SEGMENT$SDL_SetLogPriorities;
    public final @Nullable MemorySegment SEGMENT$SDL_SetLogPriority;
    public final @Nullable MemorySegment SEGMENT$SDL_GetLogPriority;
    public final @Nullable MemorySegment SEGMENT$SDL_ResetLogPriorities;
    public final @Nullable MemorySegment SEGMENT$SDL_SetLogPriorityPrefix;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDefaultLogOutputFunction;
    public final @Nullable MemorySegment SEGMENT$SDL_GetLogOutputFunction;
    public final @Nullable MemorySegment SEGMENT$SDL_SetLogOutputFunction;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowMessageBox;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowSimpleMessageBox;
    public final @Nullable MemorySegment SEGMENT$SDL_Metal_CreateView;
    public final @Nullable MemorySegment SEGMENT$SDL_Metal_DestroyView;
    public final @Nullable MemorySegment SEGMENT$SDL_Metal_GetLayer;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenURL;
    public final @Nullable MemorySegment SEGMENT$SDL_HasMouse;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMice;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMouseNameForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMouseFocus;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMouseState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGlobalMouseState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRelativeMouseState;
    public final @Nullable MemorySegment SEGMENT$SDL_WarpMouseInWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_WarpMouseGlobal;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowRelativeMouseMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowRelativeMouseMode;
    public final @Nullable MemorySegment SEGMENT$SDL_CaptureMouse;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateColorCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateSystemCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_SetCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDefaultCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_HideCursor;
    public final @Nullable MemorySegment SEGMENT$SDL_CursorVisible;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateMutex;
    public final @Nullable MemorySegment SEGMENT$SDL_LockMutex;
    public final @Nullable MemorySegment SEGMENT$SDL_TryLockMutex;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockMutex;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyMutex;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateRWLock;
    public final @Nullable MemorySegment SEGMENT$SDL_LockRWLockForReading;
    public final @Nullable MemorySegment SEGMENT$SDL_LockRWLockForWriting;
    public final @Nullable MemorySegment SEGMENT$SDL_TryLockRWLockForReading;
    public final @Nullable MemorySegment SEGMENT$SDL_TryLockRWLockForWriting;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockRWLock;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyRWLock;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateSemaphore;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroySemaphore;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitSemaphore;
    public final @Nullable MemorySegment SEGMENT$SDL_TryWaitSemaphore;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitSemaphoreTimeout;
    public final @Nullable MemorySegment SEGMENT$SDL_SignalSemaphore;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSemaphoreValue;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateCondition;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyCondition;
    public final @Nullable MemorySegment SEGMENT$SDL_SignalCondition;
    public final @Nullable MemorySegment SEGMENT$SDL_BroadcastCondition;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitCondition;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitConditionTimeout;
    public final @Nullable MemorySegment SEGMENT$SDL_ShouldInit;
    public final @Nullable MemorySegment SEGMENT$SDL_ShouldQuit;
    public final @Nullable MemorySegment SEGMENT$SDL_SetInitialized;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPixelFormatName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetMasksForPixelFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPixelFormatForMasks;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPixelFormatDetails;
    public final @Nullable MemorySegment SEGMENT$SDL_CreatePalette;
    public final @Nullable MemorySegment SEGMENT$SDL_SetPaletteColors;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyPalette;
    public final @Nullable MemorySegment SEGMENT$SDL_MapRGB;
    public final @Nullable MemorySegment SEGMENT$SDL_MapRGBA;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRGB;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRGBA;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPlatform;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPowerInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateProcess;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateProcessWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetProcessProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadProcess;
    public final @Nullable MemorySegment SEGMENT$SDL_GetProcessInput;
    public final @Nullable MemorySegment SEGMENT$SDL_GetProcessOutput;
    public final @Nullable MemorySegment SEGMENT$SDL_KillProcess;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitProcess;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyProcess;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGlobalProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_CopyProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_LockProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_SetPointerPropertyWithCleanup;
    public final @Nullable MemorySegment SEGMENT$SDL_SetPointerProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_SetStringProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_SetNumberProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_SetFloatProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_SetBooleanProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_HasProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPropertyType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPointerProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_GetStringProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumberProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_GetFloatProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_GetBooleanProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_ClearProperty;
    public final @Nullable MemorySegment SEGMENT$SDL_EnumerateProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_HasRectIntersection;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectIntersection;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectUnion;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectEnclosingPoints;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectAndLineIntersection;
    public final @Nullable MemorySegment SEGMENT$SDL_HasRectIntersectionFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectIntersectionFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectUnionFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectEnclosingPointsFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRectAndLineIntersectionFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumRenderDrivers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateWindowAndRenderer;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateRenderer;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateRendererWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateSoftwareRenderer;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderer;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRendererName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRendererProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderOutputSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentRenderOutputSize;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateTextureFromSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateTextureWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRendererFromTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureSize;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextureColorMod;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextureColorModFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureColorMod;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureColorModFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextureAlphaMod;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextureAlphaModFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureAlphaMod;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureAlphaModFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextureBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTextureScaleMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTextureScaleMode;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateYUVTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateNVTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_LockTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_LockTextureToSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderTarget;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderTarget;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderLogicalPresentation;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderLogicalPresentation;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderLogicalPresentationRect;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderCoordinatesFromWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderCoordinatesToWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_ConvertEventToRenderCoordinates;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderViewport;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderViewport;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderViewportSet;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderSafeArea;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderClipRect;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderClipRect;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderClipEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderScale;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderScale;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderDrawColor;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderDrawColorFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderDrawColor;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderDrawColorFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderColorScale;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderColorScale;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderDrawBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderDrawBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderClear;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderPoint;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderPoints;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderLine;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderLines;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderRect;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderRects;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderFillRect;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderFillRects;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderTextureRotated;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderTextureAffine;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderTextureTiled;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderTexture9Grid;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderGeometry;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderGeometryRaw;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderReadPixels;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderPresent;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyTexture;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyRenderer;
    public final @Nullable MemorySegment SEGMENT$SDL_FlushRenderer;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderMetalLayer;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderMetalCommandEncoder;
    public final @Nullable MemorySegment SEGMENT$SDL_AddVulkanRenderSemaphores;
    public final @Nullable MemorySegment SEGMENT$SDL_SetRenderVSync;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRenderVSync;
    public final @Nullable MemorySegment SEGMENT$SDL_RenderDebugText;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensors;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorNameForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorTypeForID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorNonPortableTypeForID;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenSensor;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorFromID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorNonPortableType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSensorData;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseSensor;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateSensors;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenTitleStorage;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenUserStorage;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenFileStorage;
    public final @Nullable MemorySegment SEGMENT$SDL_OpenStorage;
    public final @Nullable MemorySegment SEGMENT$SDL_CloseStorage;
    public final @Nullable MemorySegment SEGMENT$SDL_StorageReady;
    public final @Nullable MemorySegment SEGMENT$SDL_GetStorageFileSize;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadStorageFile;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteStorageFile;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateStorageDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_EnumerateStorageDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_RemoveStoragePath;
    public final @Nullable MemorySegment SEGMENT$SDL_RenameStoragePath;
    public final @Nullable MemorySegment SEGMENT$SDL_CopyStorageFile;
    public final @Nullable MemorySegment SEGMENT$SDL_GetStoragePathInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_GetStorageSpaceRemaining;
    public final @Nullable MemorySegment SEGMENT$SDL_GlobStorageDirectory;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateSurfaceFrom;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroySurface;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceColorspace;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceColorspace;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateSurfacePalette;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfacePalette;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfacePalette;
    public final @Nullable MemorySegment SEGMENT$SDL_AddSurfaceAlternateImage;
    public final @Nullable MemorySegment SEGMENT$SDL_SurfaceHasAlternateImages;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceImages;
    public final @Nullable MemorySegment SEGMENT$SDL_RemoveSurfaceAlternateImages;
    public final @Nullable MemorySegment SEGMENT$SDL_LockSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_UnlockSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadBMP_IO;
    public final @Nullable MemorySegment SEGMENT$SDL_LoadBMP;
    public final @Nullable MemorySegment SEGMENT$SDL_SaveBMP_IO;
    public final @Nullable MemorySegment SEGMENT$SDL_SaveBMP;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceRLE;
    public final @Nullable MemorySegment SEGMENT$SDL_SurfaceHasRLE;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceColorKey;
    public final @Nullable MemorySegment SEGMENT$SDL_SurfaceHasColorKey;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceColorKey;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceColorMod;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceColorMod;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceAlphaMod;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceAlphaMod;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceBlendMode;
    public final @Nullable MemorySegment SEGMENT$SDL_SetSurfaceClipRect;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSurfaceClipRect;
    public final @Nullable MemorySegment SEGMENT$SDL_FlipSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_DuplicateSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_ScaleSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_ConvertSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_ConvertSurfaceAndColorspace;
    public final @Nullable MemorySegment SEGMENT$SDL_ConvertPixels;
    public final @Nullable MemorySegment SEGMENT$SDL_ConvertPixelsAndColorspace;
    public final @Nullable MemorySegment SEGMENT$SDL_PremultiplyAlpha;
    public final @Nullable MemorySegment SEGMENT$SDL_PremultiplySurfaceAlpha;
    public final @Nullable MemorySegment SEGMENT$SDL_ClearSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_FillSurfaceRect;
    public final @Nullable MemorySegment SEGMENT$SDL_FillSurfaceRects;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurfaceUnchecked;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurfaceScaled;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurfaceUncheckedScaled;
    public final @Nullable MemorySegment SEGMENT$SDL_StretchSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurfaceTiled;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurfaceTiledWithScale;
    public final @Nullable MemorySegment SEGMENT$SDL_BlitSurface9Grid;
    public final @Nullable MemorySegment SEGMENT$SDL_MapSurfaceRGB;
    public final @Nullable MemorySegment SEGMENT$SDL_MapSurfaceRGBA;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadSurfacePixel;
    public final @Nullable MemorySegment SEGMENT$SDL_ReadSurfacePixelFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteSurfacePixel;
    public final @Nullable MemorySegment SEGMENT$SDL_WriteSurfacePixelFloat;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowsMessageHook;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDirect3D9AdapterIndex;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDXGIOutputInfo;
    public final @Nullable MemorySegment SEGMENT$SDL_SetX11EventHook;
    public final @Nullable MemorySegment SEGMENT$SDL_SetLinuxThreadPriority;
    public final @Nullable MemorySegment SEGMENT$SDL_SetLinuxThreadPriorityAndPolicy;
    public final @Nullable MemorySegment SEGMENT$SDL_SetiOSAnimationCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_SetiOSEventPump;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidJNIEnv;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidActivity;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidSDKVersion;
    public final @Nullable MemorySegment SEGMENT$SDL_IsChromebook;
    public final @Nullable MemorySegment SEGMENT$SDL_IsDeXMode;
    public final @Nullable MemorySegment SEGMENT$SDL_SendAndroidBackButton;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidInternalStoragePath;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidExternalStorageState;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidExternalStoragePath;
    public final @Nullable MemorySegment SEGMENT$SDL_GetAndroidCachePath;
    public final @Nullable MemorySegment SEGMENT$SDL_RequestAndroidPermission;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowAndroidToast;
    public final @Nullable MemorySegment SEGMENT$SDL_SendAndroidMessage;
    public final @Nullable MemorySegment SEGMENT$SDL_IsTablet;
    public final @Nullable MemorySegment SEGMENT$SDL_IsTV;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSandbox;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationWillTerminate;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationDidReceiveMemoryWarning;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationWillEnterBackground;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationDidEnterBackground;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationWillEnterForeground;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationDidEnterForeground;
    public final @Nullable MemorySegment SEGMENT$SDL_OnApplicationDidChangeStatusBarOrientation;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGDKTaskQueue;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGDKDefaultUser;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateThread;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateThreadWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateThreadRuntime;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateThreadWithPropertiesRuntime;
    public final @Nullable MemorySegment SEGMENT$SDL_GetThreadName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentThreadID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetThreadID;
    public final @Nullable MemorySegment SEGMENT$SDL_SetCurrentThreadPriority;
    public final @Nullable MemorySegment SEGMENT$SDL_WaitThread;
    public final @Nullable MemorySegment SEGMENT$SDL_GetThreadState;
    public final @Nullable MemorySegment SEGMENT$SDL_DetachThread;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTLS;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTLS;
    public final @Nullable MemorySegment SEGMENT$SDL_CleanupTLS;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDateTimeLocalePreferences;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentTime;
    public final @Nullable MemorySegment SEGMENT$SDL_TimeToDateTime;
    public final @Nullable MemorySegment SEGMENT$SDL_DateTimeToTime;
    public final @Nullable MemorySegment SEGMENT$SDL_TimeToWindows;
    public final @Nullable MemorySegment SEGMENT$SDL_TimeFromWindows;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDaysInMonth;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDayOfYear;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDayOfWeek;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTicks;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTicksNS;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPerformanceCounter;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPerformanceFrequency;
    public final @Nullable MemorySegment SEGMENT$SDL_Delay;
    public final @Nullable MemorySegment SEGMENT$SDL_DelayNS;
    public final @Nullable MemorySegment SEGMENT$SDL_DelayPrecise;
    public final @Nullable MemorySegment SEGMENT$SDL_AddTimer;
    public final @Nullable MemorySegment SEGMENT$SDL_AddTimerNS;
    public final @Nullable MemorySegment SEGMENT$SDL_RemoveTimer;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateTray;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTrayIcon;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTrayTooltip;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateTrayMenu;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateTraySubmenu;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayMenu;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTraySubmenu;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayEntries;
    public final @Nullable MemorySegment SEGMENT$SDL_RemoveTrayEntry;
    public final @Nullable MemorySegment SEGMENT$SDL_InsertTrayEntryAt;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTrayEntryLabel;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayEntryLabel;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTrayEntryChecked;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayEntryChecked;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTrayEntryEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayEntryEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_SetTrayEntryCallback;
    public final @Nullable MemorySegment SEGMENT$SDL_ClickTrayEntry;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyTray;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayEntryParent;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayMenuParentEntry;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTrayMenuParentTray;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateTrays;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTouchDevices;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTouchDeviceName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTouchDeviceType;
    public final @Nullable MemorySegment SEGMENT$SDL_GetTouchFingers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetVersion;
    public final @Nullable MemorySegment SEGMENT$SDL_GetRevision;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNumVideoDrivers;
    public final @Nullable MemorySegment SEGMENT$SDL_GetVideoDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentVideoDriver;
    public final @Nullable MemorySegment SEGMENT$SDL_GetSystemTheme;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplays;
    public final @Nullable MemorySegment SEGMENT$SDL_GetPrimaryDisplay;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayName;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayBounds;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayUsableBounds;
    public final @Nullable MemorySegment SEGMENT$SDL_GetNaturalDisplayOrientation;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentDisplayOrientation;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayContentScale;
    public final @Nullable MemorySegment SEGMENT$SDL_GetFullscreenDisplayModes;
    public final @Nullable MemorySegment SEGMENT$SDL_GetClosestFullscreenDisplayMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDesktopDisplayMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetCurrentDisplayMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayForPoint;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayForRect;
    public final @Nullable MemorySegment SEGMENT$SDL_GetDisplayForWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowPixelDensity;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowDisplayScale;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowFullscreenMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowFullscreenMode;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowICCProfile;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowPixelFormat;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindows;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_CreatePopupWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_CreateWindowWithProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowFromID;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowParent;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowProperties;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowFlags;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowTitle;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowTitle;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowIcon;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowPosition;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowPosition;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowSafeArea;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowAspectRatio;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowAspectRatio;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowBordersSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowSizeInPixels;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowMinimumSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowMinimumSize;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowMaximumSize;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowMaximumSize;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowBordered;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowResizable;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowAlwaysOnTop;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_HideWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_RaiseWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_MaximizeWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_MinimizeWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_RestoreWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowFullscreen;
    public final @Nullable MemorySegment SEGMENT$SDL_SyncWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_WindowHasSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowSurfaceVSync;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowSurfaceVSync;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateWindowSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_UpdateWindowSurfaceRects;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyWindowSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowKeyboardGrab;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowMouseGrab;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowKeyboardGrab;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowMouseGrab;
    public final @Nullable MemorySegment SEGMENT$SDL_GetGrabbedWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowMouseRect;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowMouseRect;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowOpacity;
    public final @Nullable MemorySegment SEGMENT$SDL_GetWindowOpacity;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowParent;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowModal;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowFocusable;
    public final @Nullable MemorySegment SEGMENT$SDL_ShowWindowSystemMenu;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowHitTest;
    public final @Nullable MemorySegment SEGMENT$SDL_SetWindowShape;
    public final @Nullable MemorySegment SEGMENT$SDL_FlashWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_DestroyWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_ScreenSaverEnabled;
    public final @Nullable MemorySegment SEGMENT$SDL_EnableScreenSaver;
    public final @Nullable MemorySegment SEGMENT$SDL_DisableScreenSaver;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_LoadLibrary;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_GetProcAddress;
    public final @Nullable MemorySegment SEGMENT$SDL_EGL_GetProcAddress;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_UnloadLibrary;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_ExtensionSupported;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_ResetAttributes;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_SetAttribute;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_GetAttribute;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_CreateContext;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_MakeCurrent;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_GetCurrentWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_GetCurrentContext;
    public final @Nullable MemorySegment SEGMENT$SDL_EGL_GetCurrentDisplay;
    public final @Nullable MemorySegment SEGMENT$SDL_EGL_GetCurrentConfig;
    public final @Nullable MemorySegment SEGMENT$SDL_EGL_GetWindowSurface;
    public final @Nullable MemorySegment SEGMENT$SDL_EGL_SetAttributeCallbacks;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_SetSwapInterval;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_GetSwapInterval;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_SwapWindow;
    public final @Nullable MemorySegment SEGMENT$SDL_GL_DestroyContext;
    public final @Nullable MethodHandle HANDLE$SDL_malloc;
    public final @Nullable MethodHandle HANDLE$SDL_calloc;
    public final @Nullable MethodHandle HANDLE$SDL_realloc;
    public final @Nullable MethodHandle HANDLE$SDL_free;
    public final @Nullable MethodHandle HANDLE$SDL_GetOriginalMemoryFunctions;
    public final @Nullable MethodHandle HANDLE$SDL_GetMemoryFunctions;
    public final @Nullable MethodHandle HANDLE$SDL_SetMemoryFunctions;
    public final @Nullable MethodHandle HANDLE$SDL_aligned_alloc;
    public final @Nullable MethodHandle HANDLE$SDL_aligned_free;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumAllocations;
    public final @Nullable MethodHandle HANDLE$SDL_GetEnvironment;
    public final @Nullable MethodHandle HANDLE$SDL_CreateEnvironment;
    public final @Nullable MethodHandle HANDLE$SDL_GetEnvironmentVariable;
    public final @Nullable MethodHandle HANDLE$SDL_GetEnvironmentVariables;
    public final @Nullable MethodHandle HANDLE$SDL_SetEnvironmentVariable;
    public final @Nullable MethodHandle HANDLE$SDL_UnsetEnvironmentVariable;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyEnvironment;
    public final @Nullable MethodHandle HANDLE$SDL_getenv;
    public final @Nullable MethodHandle HANDLE$SDL_getenv_unsafe;
    public final @Nullable MethodHandle HANDLE$SDL_setenv_unsafe;
    public final @Nullable MethodHandle HANDLE$SDL_unsetenv_unsafe;
    public final @Nullable MethodHandle HANDLE$SDL_qsort;
    public final @Nullable MethodHandle HANDLE$SDL_bsearch;
    public final @Nullable MethodHandle HANDLE$SDL_qsort_r;
    public final @Nullable MethodHandle HANDLE$SDL_bsearch_r;
    public final @Nullable MethodHandle HANDLE$SDL_abs;
    public final @Nullable MethodHandle HANDLE$SDL_isalpha;
    public final @Nullable MethodHandle HANDLE$SDL_isalnum;
    public final @Nullable MethodHandle HANDLE$SDL_isblank;
    public final @Nullable MethodHandle HANDLE$SDL_iscntrl;
    public final @Nullable MethodHandle HANDLE$SDL_isdigit;
    public final @Nullable MethodHandle HANDLE$SDL_isxdigit;
    public final @Nullable MethodHandle HANDLE$SDL_ispunct;
    public final @Nullable MethodHandle HANDLE$SDL_isspace;
    public final @Nullable MethodHandle HANDLE$SDL_isupper;
    public final @Nullable MethodHandle HANDLE$SDL_islower;
    public final @Nullable MethodHandle HANDLE$SDL_isprint;
    public final @Nullable MethodHandle HANDLE$SDL_isgraph;
    public final @Nullable MethodHandle HANDLE$SDL_toupper;
    public final @Nullable MethodHandle HANDLE$SDL_tolower;
    public final @Nullable MethodHandle HANDLE$SDL_crc16;
    public final @Nullable MethodHandle HANDLE$SDL_crc32;
    public final @Nullable MethodHandle HANDLE$SDL_murmur3_32;
    public final @Nullable MethodHandle HANDLE$SDL_memcpy;
    public final @Nullable MethodHandle HANDLE$SDL_memmove;
    public final @Nullable MethodHandle HANDLE$SDL_memset;
    public final @Nullable MethodHandle HANDLE$SDL_memset4;
    public final @Nullable MethodHandle HANDLE$SDL_memcmp;
    public final @Nullable MethodHandle HANDLE$SDL_wcslen;
    public final @Nullable MethodHandle HANDLE$SDL_wcsnlen;
    public final @Nullable MethodHandle HANDLE$SDL_wcslcpy;
    public final @Nullable MethodHandle HANDLE$SDL_wcslcat;
    public final @Nullable MethodHandle HANDLE$SDL_wcsdup;
    public final @Nullable MethodHandle HANDLE$SDL_wcsstr;
    public final @Nullable MethodHandle HANDLE$SDL_wcsnstr;
    public final @Nullable MethodHandle HANDLE$SDL_wcscmp;
    public final @Nullable MethodHandle HANDLE$SDL_wcsncmp;
    public final @Nullable MethodHandle HANDLE$SDL_wcscasecmp;
    public final @Nullable MethodHandle HANDLE$SDL_wcsncasecmp;
    public final @Nullable MethodHandle HANDLE$SDL_wcstol;
    public final @Nullable MethodHandle HANDLE$SDL_strlen;
    public final @Nullable MethodHandle HANDLE$SDL_strnlen;
    public final @Nullable MethodHandle HANDLE$SDL_strlcpy;
    public final @Nullable MethodHandle HANDLE$SDL_utf8strlcpy;
    public final @Nullable MethodHandle HANDLE$SDL_strlcat;
    public final @Nullable MethodHandle HANDLE$SDL_strdup;
    public final @Nullable MethodHandle HANDLE$SDL_strndup;
    public final @Nullable MethodHandle HANDLE$SDL_strrev;
    public final @Nullable MethodHandle HANDLE$SDL_strupr;
    public final @Nullable MethodHandle HANDLE$SDL_strlwr;
    public final @Nullable MethodHandle HANDLE$SDL_strchr;
    public final @Nullable MethodHandle HANDLE$SDL_strrchr;
    public final @Nullable MethodHandle HANDLE$SDL_strstr;
    public final @Nullable MethodHandle HANDLE$SDL_strnstr;
    public final @Nullable MethodHandle HANDLE$SDL_strcasestr;
    public final @Nullable MethodHandle HANDLE$SDL_strtok_r;
    public final @Nullable MethodHandle HANDLE$SDL_utf8strlen;
    public final @Nullable MethodHandle HANDLE$SDL_utf8strnlen;
    public final @Nullable MethodHandle HANDLE$SDL_itoa;
    public final @Nullable MethodHandle HANDLE$SDL_uitoa;
    public final @Nullable MethodHandle HANDLE$SDL_ltoa;
    public final @Nullable MethodHandle HANDLE$SDL_ultoa;
    public final @Nullable MethodHandle HANDLE$SDL_lltoa;
    public final @Nullable MethodHandle HANDLE$SDL_ulltoa;
    public final @Nullable MethodHandle HANDLE$SDL_atoi;
    public final @Nullable MethodHandle HANDLE$SDL_atof;
    public final @Nullable MethodHandle HANDLE$SDL_strtol;
    public final @Nullable MethodHandle HANDLE$SDL_strtoul;
    public final @Nullable MethodHandle HANDLE$SDL_strtoll;
    public final @Nullable MethodHandle HANDLE$SDL_strtoull;
    public final @Nullable MethodHandle HANDLE$SDL_strtod;
    public final @Nullable MethodHandle HANDLE$SDL_strcmp;
    public final @Nullable MethodHandle HANDLE$SDL_strncmp;
    public final @Nullable MethodHandle HANDLE$SDL_strcasecmp;
    public final @Nullable MethodHandle HANDLE$SDL_strncasecmp;
    public final @Nullable MethodHandle HANDLE$SDL_strpbrk;
    public final @Nullable MethodHandle HANDLE$SDL_StepUTF8;
    public final @Nullable MethodHandle HANDLE$SDL_StepBackUTF8;
    public final @Nullable MethodHandle HANDLE$SDL_UCS4ToUTF8;
    public final @Nullable MethodHandle HANDLE$SDL_srand;
    public final @Nullable MethodHandle HANDLE$SDL_rand;
    public final @Nullable MethodHandle HANDLE$SDL_randf;
    public final @Nullable MethodHandle HANDLE$SDL_rand_bits;
    public final @Nullable MethodHandle HANDLE$SDL_rand_r;
    public final @Nullable MethodHandle HANDLE$SDL_randf_r;
    public final @Nullable MethodHandle HANDLE$SDL_rand_bits_r;
    public final @Nullable MethodHandle HANDLE$SDL_acos;
    public final @Nullable MethodHandle HANDLE$SDL_acosf;
    public final @Nullable MethodHandle HANDLE$SDL_asin;
    public final @Nullable MethodHandle HANDLE$SDL_asinf;
    public final @Nullable MethodHandle HANDLE$SDL_atan;
    public final @Nullable MethodHandle HANDLE$SDL_atanf;
    public final @Nullable MethodHandle HANDLE$SDL_atan2;
    public final @Nullable MethodHandle HANDLE$SDL_atan2f;
    public final @Nullable MethodHandle HANDLE$SDL_ceil;
    public final @Nullable MethodHandle HANDLE$SDL_ceilf;
    public final @Nullable MethodHandle HANDLE$SDL_copysign;
    public final @Nullable MethodHandle HANDLE$SDL_copysignf;
    public final @Nullable MethodHandle HANDLE$SDL_cos;
    public final @Nullable MethodHandle HANDLE$SDL_cosf;
    public final @Nullable MethodHandle HANDLE$SDL_exp;
    public final @Nullable MethodHandle HANDLE$SDL_expf;
    public final @Nullable MethodHandle HANDLE$SDL_fabs;
    public final @Nullable MethodHandle HANDLE$SDL_fabsf;
    public final @Nullable MethodHandle HANDLE$SDL_floor;
    public final @Nullable MethodHandle HANDLE$SDL_floorf;
    public final @Nullable MethodHandle HANDLE$SDL_trunc;
    public final @Nullable MethodHandle HANDLE$SDL_truncf;
    public final @Nullable MethodHandle HANDLE$SDL_fmod;
    public final @Nullable MethodHandle HANDLE$SDL_fmodf;
    public final @Nullable MethodHandle HANDLE$SDL_isinf;
    public final @Nullable MethodHandle HANDLE$SDL_isinff;
    public final @Nullable MethodHandle HANDLE$SDL_isnan;
    public final @Nullable MethodHandle HANDLE$SDL_isnanf;
    public final @Nullable MethodHandle HANDLE$SDL_log;
    public final @Nullable MethodHandle HANDLE$SDL_logf;
    public final @Nullable MethodHandle HANDLE$SDL_log10;
    public final @Nullable MethodHandle HANDLE$SDL_log10f;
    public final @Nullable MethodHandle HANDLE$SDL_modf;
    public final @Nullable MethodHandle HANDLE$SDL_modff;
    public final @Nullable MethodHandle HANDLE$SDL_pow;
    public final @Nullable MethodHandle HANDLE$SDL_powf;
    public final @Nullable MethodHandle HANDLE$SDL_round;
    public final @Nullable MethodHandle HANDLE$SDL_roundf;
    public final @Nullable MethodHandle HANDLE$SDL_lround;
    public final @Nullable MethodHandle HANDLE$SDL_lroundf;
    public final @Nullable MethodHandle HANDLE$SDL_scalbn;
    public final @Nullable MethodHandle HANDLE$SDL_scalbnf;
    public final @Nullable MethodHandle HANDLE$SDL_sin;
    public final @Nullable MethodHandle HANDLE$SDL_sinf;
    public final @Nullable MethodHandle HANDLE$SDL_sqrt;
    public final @Nullable MethodHandle HANDLE$SDL_sqrtf;
    public final @Nullable MethodHandle HANDLE$SDL_tan;
    public final @Nullable MethodHandle HANDLE$SDL_tanf;
    public final @Nullable MethodHandle HANDLE$SDL_iconv_open;
    public final @Nullable MethodHandle HANDLE$SDL_iconv_close;
    public final @Nullable MethodHandle HANDLE$SDL_iconv;
    public final @Nullable MethodHandle HANDLE$SDL_iconv_string;
    public final @Nullable MethodHandle HANDLE$SDL_AsyncIOFromFile;
    public final @Nullable MethodHandle HANDLE$SDL_GetAsyncIOSize;
    public final @Nullable MethodHandle HANDLE$SDL_ReadAsyncIO;
    public final @Nullable MethodHandle HANDLE$SDL_WriteAsyncIO;
    public final @Nullable MethodHandle HANDLE$SDL_CloseAsyncIO;
    public final @Nullable MethodHandle HANDLE$SDL_CreateAsyncIOQueue;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyAsyncIOQueue;
    public final @Nullable MethodHandle HANDLE$SDL_GetAsyncIOResult;
    public final @Nullable MethodHandle HANDLE$SDL_WaitAsyncIOResult;
    public final @Nullable MethodHandle HANDLE$SDL_SignalAsyncIOQueue;
    public final @Nullable MethodHandle HANDLE$SDL_LoadFileAsync;
    public final @Nullable MethodHandle HANDLE$SDL_TryLockSpinlock;
    public final @Nullable MethodHandle HANDLE$SDL_LockSpinlock;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockSpinlock;
    public final @Nullable MethodHandle HANDLE$SDL_MemoryBarrierReleaseFunction;
    public final @Nullable MethodHandle HANDLE$SDL_MemoryBarrierAcquireFunction;
    public final @Nullable MethodHandle HANDLE$SDL_CompareAndSwapAtomicInt;
    public final @Nullable MethodHandle HANDLE$SDL_SetAtomicInt;
    public final @Nullable MethodHandle HANDLE$SDL_GetAtomicInt;
    public final @Nullable MethodHandle HANDLE$SDL_AddAtomicInt;
    public final @Nullable MethodHandle HANDLE$SDL_CompareAndSwapAtomicU32;
    public final @Nullable MethodHandle HANDLE$SDL_SetAtomicU32;
    public final @Nullable MethodHandle HANDLE$SDL_GetAtomicU32;
    public final @Nullable MethodHandle HANDLE$SDL_CompareAndSwapAtomicPointer;
    public final @Nullable MethodHandle HANDLE$SDL_SetAtomicPointer;
    public final @Nullable MethodHandle HANDLE$SDL_GetAtomicPointer;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumAudioDrivers;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentAudioDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioPlaybackDevices;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioRecordingDevices;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioDeviceName;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioDeviceFormat;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioDeviceChannelMap;
    public final @Nullable MethodHandle HANDLE$SDL_OpenAudioDevice;
    public final @Nullable MethodHandle HANDLE$SDL_IsAudioDevicePhysical;
    public final @Nullable MethodHandle HANDLE$SDL_IsAudioDevicePlayback;
    public final @Nullable MethodHandle HANDLE$SDL_PauseAudioDevice;
    public final @Nullable MethodHandle HANDLE$SDL_ResumeAudioDevice;
    public final @Nullable MethodHandle HANDLE$SDL_AudioDevicePaused;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioDeviceGain;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioDeviceGain;
    public final @Nullable MethodHandle HANDLE$SDL_CloseAudioDevice;
    public final @Nullable MethodHandle HANDLE$SDL_BindAudioStreams;
    public final @Nullable MethodHandle HANDLE$SDL_BindAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_UnbindAudioStreams;
    public final @Nullable MethodHandle HANDLE$SDL_UnbindAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamDevice;
    public final @Nullable MethodHandle HANDLE$SDL_CreateAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamFormat;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamFormat;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamFrequencyRatio;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamFrequencyRatio;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamGain;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamGain;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamInputChannelMap;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamOutputChannelMap;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamInputChannelMap;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamOutputChannelMap;
    public final @Nullable MethodHandle HANDLE$SDL_PutAudioStreamData;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamData;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamAvailable;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioStreamQueued;
    public final @Nullable MethodHandle HANDLE$SDL_FlushAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_ClearAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_PauseAudioStreamDevice;
    public final @Nullable MethodHandle HANDLE$SDL_ResumeAudioStreamDevice;
    public final @Nullable MethodHandle HANDLE$SDL_AudioStreamDevicePaused;
    public final @Nullable MethodHandle HANDLE$SDL_LockAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamGetCallback;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioStreamPutCallback;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyAudioStream;
    public final @Nullable MethodHandle HANDLE$SDL_OpenAudioDeviceStream;
    public final @Nullable MethodHandle HANDLE$SDL_SetAudioPostmixCallback;
    public final @Nullable MethodHandle HANDLE$SDL_LoadWAV_IO;
    public final @Nullable MethodHandle HANDLE$SDL_LoadWAV;
    public final @Nullable MethodHandle HANDLE$SDL_MixAudio;
    public final @Nullable MethodHandle HANDLE$SDL_ConvertAudioSamples;
    public final @Nullable MethodHandle HANDLE$SDL_GetAudioFormatName;
    public final @Nullable MethodHandle HANDLE$SDL_GetSilenceValueForFormat;
    public final @Nullable MethodHandle HANDLE$SDL_ComposeCustomBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumCameraDrivers;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentCameraDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameras;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraSupportedFormats;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraName;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraPosition;
    public final @Nullable MethodHandle HANDLE$SDL_OpenCamera;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraPermissionState;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraID;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetCameraFormat;
    public final @Nullable MethodHandle HANDLE$SDL_AcquireCameraFrame;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseCameraFrame;
    public final @Nullable MethodHandle HANDLE$SDL_CloseCamera;
    public final @Nullable MethodHandle HANDLE$SDL_SetClipboardText;
    public final @Nullable MethodHandle HANDLE$SDL_GetClipboardText;
    public final @Nullable MethodHandle HANDLE$SDL_HasClipboardText;
    public final @Nullable MethodHandle HANDLE$SDL_SetPrimarySelectionText;
    public final @Nullable MethodHandle HANDLE$SDL_GetPrimarySelectionText;
    public final @Nullable MethodHandle HANDLE$SDL_HasPrimarySelectionText;
    public final @Nullable MethodHandle HANDLE$SDL_SetClipboardData;
    public final @Nullable MethodHandle HANDLE$SDL_ClearClipboardData;
    public final @Nullable MethodHandle HANDLE$SDL_GetClipboardData;
    public final @Nullable MethodHandle HANDLE$SDL_HasClipboardData;
    public final @Nullable MethodHandle HANDLE$SDL_GetClipboardMimeTypes;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumLogicalCPUCores;
    public final @Nullable MethodHandle HANDLE$SDL_GetCPUCacheLineSize;
    public final @Nullable MethodHandle HANDLE$SDL_HasAltiVec;
    public final @Nullable MethodHandle HANDLE$SDL_HasMMX;
    public final @Nullable MethodHandle HANDLE$SDL_HasSSE;
    public final @Nullable MethodHandle HANDLE$SDL_HasSSE2;
    public final @Nullable MethodHandle HANDLE$SDL_HasSSE3;
    public final @Nullable MethodHandle HANDLE$SDL_HasSSE41;
    public final @Nullable MethodHandle HANDLE$SDL_HasSSE42;
    public final @Nullable MethodHandle HANDLE$SDL_HasAVX;
    public final @Nullable MethodHandle HANDLE$SDL_HasAVX2;
    public final @Nullable MethodHandle HANDLE$SDL_HasAVX512F;
    public final @Nullable MethodHandle HANDLE$SDL_HasARMSIMD;
    public final @Nullable MethodHandle HANDLE$SDL_HasNEON;
    public final @Nullable MethodHandle HANDLE$SDL_HasLSX;
    public final @Nullable MethodHandle HANDLE$SDL_HasLASX;
    public final @Nullable MethodHandle HANDLE$SDL_GetSystemRAM;
    public final @Nullable MethodHandle HANDLE$SDL_GetSIMDAlignment;
    public final @Nullable MethodHandle HANDLE$SDL_ShowOpenFileDialog;
    public final @Nullable MethodHandle HANDLE$SDL_ShowSaveFileDialog;
    public final @Nullable MethodHandle HANDLE$SDL_ShowOpenFolderDialog;
    public final @Nullable MethodHandle HANDLE$SDL_ShowFileDialogWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_OutOfMemory;
    public final @Nullable MethodHandle HANDLE$SDL_GetError;
    public final @Nullable MethodHandle HANDLE$SDL_ClearError;
    public final @Nullable MethodHandle HANDLE$SDL_PumpEvents;
    public final @Nullable MethodHandle HANDLE$SDL_PeepEvents;
    public final @Nullable MethodHandle HANDLE$SDL_HasEvent;
    public final @Nullable MethodHandle HANDLE$SDL_HasEvents;
    public final @Nullable MethodHandle HANDLE$SDL_FlushEvent;
    public final @Nullable MethodHandle HANDLE$SDL_FlushEvents;
    public final @Nullable MethodHandle HANDLE$SDL_PollEvent;
    public final @Nullable MethodHandle HANDLE$SDL_WaitEvent;
    public final @Nullable MethodHandle HANDLE$SDL_WaitEventTimeout;
    public final @Nullable MethodHandle HANDLE$SDL_PushEvent;
    public final @Nullable MethodHandle HANDLE$SDL_SetEventFilter;
    public final @Nullable MethodHandle HANDLE$SDL_GetEventFilter;
    public final @Nullable MethodHandle HANDLE$SDL_AddEventWatch;
    public final @Nullable MethodHandle HANDLE$SDL_RemoveEventWatch;
    public final @Nullable MethodHandle HANDLE$SDL_FilterEvents;
    public final @Nullable MethodHandle HANDLE$SDL_SetEventEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_EventEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_RegisterEvents;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowFromEvent;
    public final @Nullable MethodHandle HANDLE$SDL_GetBasePath;
    public final @Nullable MethodHandle HANDLE$SDL_GetPrefPath;
    public final @Nullable MethodHandle HANDLE$SDL_GetUserFolder;
    public final @Nullable MethodHandle HANDLE$SDL_CreateDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_EnumerateDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_RemovePath;
    public final @Nullable MethodHandle HANDLE$SDL_RenamePath;
    public final @Nullable MethodHandle HANDLE$SDL_CopyFile;
    public final @Nullable MethodHandle HANDLE$SDL_GetPathInfo;
    public final @Nullable MethodHandle HANDLE$SDL_GlobDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_AddGamepadMapping;
    public final @Nullable MethodHandle HANDLE$SDL_AddGamepadMappingsFromIO;
    public final @Nullable MethodHandle HANDLE$SDL_AddGamepadMappingsFromFile;
    public final @Nullable MethodHandle HANDLE$SDL_ReloadGamepadMappings;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadMappings;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadMappingForGUID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadMapping;
    public final @Nullable MethodHandle HANDLE$SDL_SetGamepadMapping;
    public final @Nullable MethodHandle HANDLE$SDL_HasGamepad;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepads;
    public final @Nullable MethodHandle HANDLE$SDL_IsGamepad;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadNameForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadPathForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadPlayerIndexForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadGUIDForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadVendorForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadProductForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadProductVersionForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadTypeForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetRealGamepadTypeForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadMappingForID;
    public final @Nullable MethodHandle HANDLE$SDL_OpenGamepad;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadFromID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadFromPlayerIndex;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadID;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadName;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadPath;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadType;
    public final @Nullable MethodHandle HANDLE$SDL_GetRealGamepadType;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadPlayerIndex;
    public final @Nullable MethodHandle HANDLE$SDL_SetGamepadPlayerIndex;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadVendor;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadProduct;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadProductVersion;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadFirmwareVersion;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadSerial;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadSteamHandle;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadConnectionState;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadPowerInfo;
    public final @Nullable MethodHandle HANDLE$SDL_GamepadConnected;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_SetGamepadEventsEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_GamepadEventsEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadBindings;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateGamepads;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadTypeFromString;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadStringForType;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadAxisFromString;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadStringForAxis;
    public final @Nullable MethodHandle HANDLE$SDL_GamepadHasAxis;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadAxis;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadButtonFromString;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadStringForButton;
    public final @Nullable MethodHandle HANDLE$SDL_GamepadHasButton;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadButton;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadButtonLabelForType;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadButtonLabel;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumGamepadTouchpads;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumGamepadTouchpadFingers;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadTouchpadFinger;
    public final @Nullable MethodHandle HANDLE$SDL_GamepadHasSensor;
    public final @Nullable MethodHandle HANDLE$SDL_SetGamepadSensorEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_GamepadSensorEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadSensorDataRate;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadSensorData;
    public final @Nullable MethodHandle HANDLE$SDL_RumbleGamepad;
    public final @Nullable MethodHandle HANDLE$SDL_RumbleGamepadTriggers;
    public final @Nullable MethodHandle HANDLE$SDL_SetGamepadLED;
    public final @Nullable MethodHandle HANDLE$SDL_SendGamepadEffect;
    public final @Nullable MethodHandle HANDLE$SDL_CloseGamepad;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadAppleSFSymbolsNameForButton;
    public final @Nullable MethodHandle HANDLE$SDL_GetGamepadAppleSFSymbolsNameForAxis;
    public final @Nullable MethodHandle HANDLE$SDL_GPUSupportsShaderFormats;
    public final @Nullable MethodHandle HANDLE$SDL_GPUSupportsProperties;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUDevice;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUDeviceWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyGPUDevice;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumGPUDrivers;
    public final @Nullable MethodHandle HANDLE$SDL_GetGPUDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetGPUDeviceDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetGPUShaderFormats;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUComputePipeline;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUGraphicsPipeline;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUSampler;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUShader;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUTexture;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_CreateGPUTransferBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUBufferName;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUTextureName;
    public final @Nullable MethodHandle HANDLE$SDL_InsertGPUDebugLabel;
    public final @Nullable MethodHandle HANDLE$SDL_PushGPUDebugGroup;
    public final @Nullable MethodHandle HANDLE$SDL_PopGPUDebugGroup;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUTexture;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUSampler;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUTransferBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUComputePipeline;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUShader;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUGraphicsPipeline;
    public final @Nullable MethodHandle HANDLE$SDL_AcquireGPUCommandBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_PushGPUVertexUniformData;
    public final @Nullable MethodHandle HANDLE$SDL_PushGPUFragmentUniformData;
    public final @Nullable MethodHandle HANDLE$SDL_PushGPUComputeUniformData;
    public final @Nullable MethodHandle HANDLE$SDL_BeginGPURenderPass;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUGraphicsPipeline;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUViewport;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUScissor;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUBlendConstants;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUStencilReference;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUVertexBuffers;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUIndexBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUVertexSamplers;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUVertexStorageTextures;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUVertexStorageBuffers;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUFragmentSamplers;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUFragmentStorageTextures;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUFragmentStorageBuffers;
    public final @Nullable MethodHandle HANDLE$SDL_DrawGPUIndexedPrimitives;
    public final @Nullable MethodHandle HANDLE$SDL_DrawGPUPrimitives;
    public final @Nullable MethodHandle HANDLE$SDL_DrawGPUPrimitivesIndirect;
    public final @Nullable MethodHandle HANDLE$SDL_DrawGPUIndexedPrimitivesIndirect;
    public final @Nullable MethodHandle HANDLE$SDL_EndGPURenderPass;
    public final @Nullable MethodHandle HANDLE$SDL_BeginGPUComputePass;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUComputePipeline;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUComputeSamplers;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUComputeStorageTextures;
    public final @Nullable MethodHandle HANDLE$SDL_BindGPUComputeStorageBuffers;
    public final @Nullable MethodHandle HANDLE$SDL_DispatchGPUCompute;
    public final @Nullable MethodHandle HANDLE$SDL_DispatchGPUComputeIndirect;
    public final @Nullable MethodHandle HANDLE$SDL_EndGPUComputePass;
    public final @Nullable MethodHandle HANDLE$SDL_MapGPUTransferBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_UnmapGPUTransferBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_BeginGPUCopyPass;
    public final @Nullable MethodHandle HANDLE$SDL_UploadToGPUTexture;
    public final @Nullable MethodHandle HANDLE$SDL_UploadToGPUBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_CopyGPUTextureToTexture;
    public final @Nullable MethodHandle HANDLE$SDL_CopyGPUBufferToBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_DownloadFromGPUTexture;
    public final @Nullable MethodHandle HANDLE$SDL_DownloadFromGPUBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_EndGPUCopyPass;
    public final @Nullable MethodHandle HANDLE$SDL_GenerateMipmapsForGPUTexture;
    public final @Nullable MethodHandle HANDLE$SDL_BlitGPUTexture;
    public final @Nullable MethodHandle HANDLE$SDL_WindowSupportsGPUSwapchainComposition;
    public final @Nullable MethodHandle HANDLE$SDL_WindowSupportsGPUPresentMode;
    public final @Nullable MethodHandle HANDLE$SDL_ClaimWindowForGPUDevice;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseWindowFromGPUDevice;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUSwapchainParameters;
    public final @Nullable MethodHandle HANDLE$SDL_SetGPUAllowedFramesInFlight;
    public final @Nullable MethodHandle HANDLE$SDL_GetGPUSwapchainTextureFormat;
    public final @Nullable MethodHandle HANDLE$SDL_AcquireGPUSwapchainTexture;
    public final @Nullable MethodHandle HANDLE$SDL_WaitForGPUSwapchain;
    public final @Nullable MethodHandle HANDLE$SDL_WaitAndAcquireGPUSwapchainTexture;
    public final @Nullable MethodHandle HANDLE$SDL_SubmitGPUCommandBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_SubmitGPUCommandBufferAndAcquireFence;
    public final @Nullable MethodHandle HANDLE$SDL_CancelGPUCommandBuffer;
    public final @Nullable MethodHandle HANDLE$SDL_WaitForGPUIdle;
    public final @Nullable MethodHandle HANDLE$SDL_WaitForGPUFences;
    public final @Nullable MethodHandle HANDLE$SDL_QueryGPUFence;
    public final @Nullable MethodHandle HANDLE$SDL_ReleaseGPUFence;
    public final @Nullable MethodHandle HANDLE$SDL_GPUTextureFormatTexelBlockSize;
    public final @Nullable MethodHandle HANDLE$SDL_GPUTextureSupportsFormat;
    public final @Nullable MethodHandle HANDLE$SDL_GPUTextureSupportsSampleCount;
    public final @Nullable MethodHandle HANDLE$SDL_CalculateGPUTextureFormatSize;
    public final @Nullable MethodHandle HANDLE$SDL_GDKSuspendGPU;
    public final @Nullable MethodHandle HANDLE$SDL_GDKResumeGPU;
    public final @Nullable MethodHandle HANDLE$SDL_GUIDToString;
    public final @Nullable MethodHandle HANDLE$SDL_StringToGUID;
    public final @Nullable MethodHandle HANDLE$SDL_GetHaptics;
    public final @Nullable MethodHandle HANDLE$SDL_GetHapticNameForID;
    public final @Nullable MethodHandle HANDLE$SDL_OpenHaptic;
    public final @Nullable MethodHandle HANDLE$SDL_GetHapticFromID;
    public final @Nullable MethodHandle HANDLE$SDL_GetHapticID;
    public final @Nullable MethodHandle HANDLE$SDL_GetHapticName;
    public final @Nullable MethodHandle HANDLE$SDL_IsMouseHaptic;
    public final @Nullable MethodHandle HANDLE$SDL_OpenHapticFromMouse;
    public final @Nullable MethodHandle HANDLE$SDL_IsJoystickHaptic;
    public final @Nullable MethodHandle HANDLE$SDL_OpenHapticFromJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_CloseHaptic;
    public final @Nullable MethodHandle HANDLE$SDL_GetMaxHapticEffects;
    public final @Nullable MethodHandle HANDLE$SDL_GetMaxHapticEffectsPlaying;
    public final @Nullable MethodHandle HANDLE$SDL_GetHapticFeatures;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumHapticAxes;
    public final @Nullable MethodHandle HANDLE$SDL_HapticEffectSupported;
    public final @Nullable MethodHandle HANDLE$SDL_CreateHapticEffect;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateHapticEffect;
    public final @Nullable MethodHandle HANDLE$SDL_RunHapticEffect;
    public final @Nullable MethodHandle HANDLE$SDL_StopHapticEffect;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyHapticEffect;
    public final @Nullable MethodHandle HANDLE$SDL_GetHapticEffectStatus;
    public final @Nullable MethodHandle HANDLE$SDL_SetHapticGain;
    public final @Nullable MethodHandle HANDLE$SDL_SetHapticAutocenter;
    public final @Nullable MethodHandle HANDLE$SDL_PauseHaptic;
    public final @Nullable MethodHandle HANDLE$SDL_ResumeHaptic;
    public final @Nullable MethodHandle HANDLE$SDL_StopHapticEffects;
    public final @Nullable MethodHandle HANDLE$SDL_HapticRumbleSupported;
    public final @Nullable MethodHandle HANDLE$SDL_InitHapticRumble;
    public final @Nullable MethodHandle HANDLE$SDL_PlayHapticRumble;
    public final @Nullable MethodHandle HANDLE$SDL_StopHapticRumble;
    public final @Nullable MethodHandle HANDLE$SDL_hid_init;
    public final @Nullable MethodHandle HANDLE$SDL_hid_exit;
    public final @Nullable MethodHandle HANDLE$SDL_hid_device_change_count;
    public final @Nullable MethodHandle HANDLE$SDL_hid_enumerate;
    public final @Nullable MethodHandle HANDLE$SDL_hid_free_enumeration;
    public final @Nullable MethodHandle HANDLE$SDL_hid_open;
    public final @Nullable MethodHandle HANDLE$SDL_hid_open_path;
    public final @Nullable MethodHandle HANDLE$SDL_hid_write;
    public final @Nullable MethodHandle HANDLE$SDL_hid_read_timeout;
    public final @Nullable MethodHandle HANDLE$SDL_hid_read;
    public final @Nullable MethodHandle HANDLE$SDL_hid_set_nonblocking;
    public final @Nullable MethodHandle HANDLE$SDL_hid_send_feature_report;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_feature_report;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_input_report;
    public final @Nullable MethodHandle HANDLE$SDL_hid_close;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_manufacturer_string;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_product_string;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_serial_number_string;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_indexed_string;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_device_info;
    public final @Nullable MethodHandle HANDLE$SDL_hid_get_report_descriptor;
    public final @Nullable MethodHandle HANDLE$SDL_hid_ble_scan;
    public final @Nullable MethodHandle HANDLE$SDL_SetHintWithPriority;
    public final @Nullable MethodHandle HANDLE$SDL_SetHint;
    public final @Nullable MethodHandle HANDLE$SDL_ResetHint;
    public final @Nullable MethodHandle HANDLE$SDL_ResetHints;
    public final @Nullable MethodHandle HANDLE$SDL_GetHint;
    public final @Nullable MethodHandle HANDLE$SDL_GetHintBoolean;
    public final @Nullable MethodHandle HANDLE$SDL_AddHintCallback;
    public final @Nullable MethodHandle HANDLE$SDL_RemoveHintCallback;
    public final @Nullable MethodHandle HANDLE$SDL_Init;
    public final @Nullable MethodHandle HANDLE$SDL_InitSubSystem;
    public final @Nullable MethodHandle HANDLE$SDL_QuitSubSystem;
    public final @Nullable MethodHandle HANDLE$SDL_WasInit;
    public final @Nullable MethodHandle HANDLE$SDL_Quit;
    public final @Nullable MethodHandle HANDLE$SDL_IsMainThread;
    public final @Nullable MethodHandle HANDLE$SDL_RunOnMainThread;
    public final @Nullable MethodHandle HANDLE$SDL_SetAppMetadata;
    public final @Nullable MethodHandle HANDLE$SDL_SetAppMetadataProperty;
    public final @Nullable MethodHandle HANDLE$SDL_GetAppMetadataProperty;
    public final @Nullable MethodHandle HANDLE$SDL_IOFromFile;
    public final @Nullable MethodHandle HANDLE$SDL_IOFromMem;
    public final @Nullable MethodHandle HANDLE$SDL_IOFromConstMem;
    public final @Nullable MethodHandle HANDLE$SDL_IOFromDynamicMem;
    public final @Nullable MethodHandle HANDLE$SDL_OpenIO;
    public final @Nullable MethodHandle HANDLE$SDL_CloseIO;
    public final @Nullable MethodHandle HANDLE$SDL_GetIOProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetIOStatus;
    public final @Nullable MethodHandle HANDLE$SDL_GetIOSize;
    public final @Nullable MethodHandle HANDLE$SDL_SeekIO;
    public final @Nullable MethodHandle HANDLE$SDL_TellIO;
    public final @Nullable MethodHandle HANDLE$SDL_ReadIO;
    public final @Nullable MethodHandle HANDLE$SDL_WriteIO;
    public final @Nullable MethodHandle HANDLE$SDL_FlushIO;
    public final @Nullable MethodHandle HANDLE$SDL_LoadFile_IO;
    public final @Nullable MethodHandle HANDLE$SDL_LoadFile;
    public final @Nullable MethodHandle HANDLE$SDL_SaveFile_IO;
    public final @Nullable MethodHandle HANDLE$SDL_SaveFile;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU8;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS8;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU16LE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS16LE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU16BE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS16BE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU32LE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS32LE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU32BE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS32BE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU64LE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS64LE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadU64BE;
    public final @Nullable MethodHandle HANDLE$SDL_ReadS64BE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU8;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS8;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU16LE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS16LE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU16BE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS16BE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU32LE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS32LE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU32BE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS32BE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU64LE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS64LE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteU64BE;
    public final @Nullable MethodHandle HANDLE$SDL_WriteS64BE;
    public final @Nullable MethodHandle HANDLE$SDL_LockJoysticks;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockJoysticks;
    public final @Nullable MethodHandle HANDLE$SDL_HasJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoysticks;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickNameForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickPathForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickPlayerIndexForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickGUIDForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickVendorForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickProductForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickProductVersionForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickTypeForID;
    public final @Nullable MethodHandle HANDLE$SDL_OpenJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickFromID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickFromPlayerIndex;
    public final @Nullable MethodHandle HANDLE$SDL_AttachVirtualJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_DetachVirtualJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_IsJoystickVirtual;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickVirtualAxis;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickVirtualBall;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickVirtualButton;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickVirtualHat;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickVirtualTouchpad;
    public final @Nullable MethodHandle HANDLE$SDL_SendJoystickVirtualSensorData;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickName;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickPath;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickPlayerIndex;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickPlayerIndex;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickGUID;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickVendor;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickProduct;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickProductVersion;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickFirmwareVersion;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickSerial;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickType;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickGUIDInfo;
    public final @Nullable MethodHandle HANDLE$SDL_JoystickConnected;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickID;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumJoystickAxes;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumJoystickBalls;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumJoystickHats;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumJoystickButtons;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickEventsEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_JoystickEventsEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateJoysticks;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickAxis;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickAxisInitialState;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickBall;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickHat;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickButton;
    public final @Nullable MethodHandle HANDLE$SDL_RumbleJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_RumbleJoystickTriggers;
    public final @Nullable MethodHandle HANDLE$SDL_SetJoystickLED;
    public final @Nullable MethodHandle HANDLE$SDL_SendJoystickEffect;
    public final @Nullable MethodHandle HANDLE$SDL_CloseJoystick;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickConnectionState;
    public final @Nullable MethodHandle HANDLE$SDL_GetJoystickPowerInfo;
    public final @Nullable MethodHandle HANDLE$SDL_HasKeyboard;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyboards;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyboardNameForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyboardFocus;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyboardState;
    public final @Nullable MethodHandle HANDLE$SDL_ResetKeyboard;
    public final @Nullable MethodHandle HANDLE$SDL_GetModState;
    public final @Nullable MethodHandle HANDLE$SDL_SetModState;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyFromScancode;
    public final @Nullable MethodHandle HANDLE$SDL_GetScancodeFromKey;
    public final @Nullable MethodHandle HANDLE$SDL_SetScancodeName;
    public final @Nullable MethodHandle HANDLE$SDL_GetScancodeName;
    public final @Nullable MethodHandle HANDLE$SDL_GetScancodeFromName;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyName;
    public final @Nullable MethodHandle HANDLE$SDL_GetKeyFromName;
    public final @Nullable MethodHandle HANDLE$SDL_StartTextInput;
    public final @Nullable MethodHandle HANDLE$SDL_StartTextInputWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_TextInputActive;
    public final @Nullable MethodHandle HANDLE$SDL_StopTextInput;
    public final @Nullable MethodHandle HANDLE$SDL_ClearComposition;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextInputArea;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextInputArea;
    public final @Nullable MethodHandle HANDLE$SDL_HasScreenKeyboardSupport;
    public final @Nullable MethodHandle HANDLE$SDL_ScreenKeyboardShown;
    public final @Nullable MethodHandle HANDLE$SDL_LoadObject;
    public final @Nullable MethodHandle HANDLE$SDL_LoadFunction;
    public final @Nullable MethodHandle HANDLE$SDL_UnloadObject;
    public final @Nullable MethodHandle HANDLE$SDL_GetPreferredLocales;
    public final @Nullable MethodHandle HANDLE$SDL_SetLogPriorities;
    public final @Nullable MethodHandle HANDLE$SDL_SetLogPriority;
    public final @Nullable MethodHandle HANDLE$SDL_GetLogPriority;
    public final @Nullable MethodHandle HANDLE$SDL_ResetLogPriorities;
    public final @Nullable MethodHandle HANDLE$SDL_SetLogPriorityPrefix;
    public final @Nullable MethodHandle HANDLE$SDL_GetDefaultLogOutputFunction;
    public final @Nullable MethodHandle HANDLE$SDL_GetLogOutputFunction;
    public final @Nullable MethodHandle HANDLE$SDL_SetLogOutputFunction;
    public final @Nullable MethodHandle HANDLE$SDL_ShowMessageBox;
    public final @Nullable MethodHandle HANDLE$SDL_ShowSimpleMessageBox;
    public final @Nullable MethodHandle HANDLE$SDL_Metal_CreateView;
    public final @Nullable MethodHandle HANDLE$SDL_Metal_DestroyView;
    public final @Nullable MethodHandle HANDLE$SDL_Metal_GetLayer;
    public final @Nullable MethodHandle HANDLE$SDL_OpenURL;
    public final @Nullable MethodHandle HANDLE$SDL_HasMouse;
    public final @Nullable MethodHandle HANDLE$SDL_GetMice;
    public final @Nullable MethodHandle HANDLE$SDL_GetMouseNameForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetMouseFocus;
    public final @Nullable MethodHandle HANDLE$SDL_GetMouseState;
    public final @Nullable MethodHandle HANDLE$SDL_GetGlobalMouseState;
    public final @Nullable MethodHandle HANDLE$SDL_GetRelativeMouseState;
    public final @Nullable MethodHandle HANDLE$SDL_WarpMouseInWindow;
    public final @Nullable MethodHandle HANDLE$SDL_WarpMouseGlobal;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowRelativeMouseMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowRelativeMouseMode;
    public final @Nullable MethodHandle HANDLE$SDL_CaptureMouse;
    public final @Nullable MethodHandle HANDLE$SDL_CreateCursor;
    public final @Nullable MethodHandle HANDLE$SDL_CreateColorCursor;
    public final @Nullable MethodHandle HANDLE$SDL_CreateSystemCursor;
    public final @Nullable MethodHandle HANDLE$SDL_SetCursor;
    public final @Nullable MethodHandle HANDLE$SDL_GetCursor;
    public final @Nullable MethodHandle HANDLE$SDL_GetDefaultCursor;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyCursor;
    public final @Nullable MethodHandle HANDLE$SDL_ShowCursor;
    public final @Nullable MethodHandle HANDLE$SDL_HideCursor;
    public final @Nullable MethodHandle HANDLE$SDL_CursorVisible;
    public final @Nullable MethodHandle HANDLE$SDL_CreateMutex;
    public final @Nullable MethodHandle HANDLE$SDL_LockMutex;
    public final @Nullable MethodHandle HANDLE$SDL_TryLockMutex;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockMutex;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyMutex;
    public final @Nullable MethodHandle HANDLE$SDL_CreateRWLock;
    public final @Nullable MethodHandle HANDLE$SDL_LockRWLockForReading;
    public final @Nullable MethodHandle HANDLE$SDL_LockRWLockForWriting;
    public final @Nullable MethodHandle HANDLE$SDL_TryLockRWLockForReading;
    public final @Nullable MethodHandle HANDLE$SDL_TryLockRWLockForWriting;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockRWLock;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyRWLock;
    public final @Nullable MethodHandle HANDLE$SDL_CreateSemaphore;
    public final @Nullable MethodHandle HANDLE$SDL_DestroySemaphore;
    public final @Nullable MethodHandle HANDLE$SDL_WaitSemaphore;
    public final @Nullable MethodHandle HANDLE$SDL_TryWaitSemaphore;
    public final @Nullable MethodHandle HANDLE$SDL_WaitSemaphoreTimeout;
    public final @Nullable MethodHandle HANDLE$SDL_SignalSemaphore;
    public final @Nullable MethodHandle HANDLE$SDL_GetSemaphoreValue;
    public final @Nullable MethodHandle HANDLE$SDL_CreateCondition;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyCondition;
    public final @Nullable MethodHandle HANDLE$SDL_SignalCondition;
    public final @Nullable MethodHandle HANDLE$SDL_BroadcastCondition;
    public final @Nullable MethodHandle HANDLE$SDL_WaitCondition;
    public final @Nullable MethodHandle HANDLE$SDL_WaitConditionTimeout;
    public final @Nullable MethodHandle HANDLE$SDL_ShouldInit;
    public final @Nullable MethodHandle HANDLE$SDL_ShouldQuit;
    public final @Nullable MethodHandle HANDLE$SDL_SetInitialized;
    public final @Nullable MethodHandle HANDLE$SDL_GetPixelFormatName;
    public final @Nullable MethodHandle HANDLE$SDL_GetMasksForPixelFormat;
    public final @Nullable MethodHandle HANDLE$SDL_GetPixelFormatForMasks;
    public final @Nullable MethodHandle HANDLE$SDL_GetPixelFormatDetails;
    public final @Nullable MethodHandle HANDLE$SDL_CreatePalette;
    public final @Nullable MethodHandle HANDLE$SDL_SetPaletteColors;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyPalette;
    public final @Nullable MethodHandle HANDLE$SDL_MapRGB;
    public final @Nullable MethodHandle HANDLE$SDL_MapRGBA;
    public final @Nullable MethodHandle HANDLE$SDL_GetRGB;
    public final @Nullable MethodHandle HANDLE$SDL_GetRGBA;
    public final @Nullable MethodHandle HANDLE$SDL_GetPlatform;
    public final @Nullable MethodHandle HANDLE$SDL_GetPowerInfo;
    public final @Nullable MethodHandle HANDLE$SDL_CreateProcess;
    public final @Nullable MethodHandle HANDLE$SDL_CreateProcessWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetProcessProperties;
    public final @Nullable MethodHandle HANDLE$SDL_ReadProcess;
    public final @Nullable MethodHandle HANDLE$SDL_GetProcessInput;
    public final @Nullable MethodHandle HANDLE$SDL_GetProcessOutput;
    public final @Nullable MethodHandle HANDLE$SDL_KillProcess;
    public final @Nullable MethodHandle HANDLE$SDL_WaitProcess;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyProcess;
    public final @Nullable MethodHandle HANDLE$SDL_GetGlobalProperties;
    public final @Nullable MethodHandle HANDLE$SDL_CreateProperties;
    public final @Nullable MethodHandle HANDLE$SDL_CopyProperties;
    public final @Nullable MethodHandle HANDLE$SDL_LockProperties;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockProperties;
    public final @Nullable MethodHandle HANDLE$SDL_SetPointerPropertyWithCleanup;
    public final @Nullable MethodHandle HANDLE$SDL_SetPointerProperty;
    public final @Nullable MethodHandle HANDLE$SDL_SetStringProperty;
    public final @Nullable MethodHandle HANDLE$SDL_SetNumberProperty;
    public final @Nullable MethodHandle HANDLE$SDL_SetFloatProperty;
    public final @Nullable MethodHandle HANDLE$SDL_SetBooleanProperty;
    public final @Nullable MethodHandle HANDLE$SDL_HasProperty;
    public final @Nullable MethodHandle HANDLE$SDL_GetPropertyType;
    public final @Nullable MethodHandle HANDLE$SDL_GetPointerProperty;
    public final @Nullable MethodHandle HANDLE$SDL_GetStringProperty;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumberProperty;
    public final @Nullable MethodHandle HANDLE$SDL_GetFloatProperty;
    public final @Nullable MethodHandle HANDLE$SDL_GetBooleanProperty;
    public final @Nullable MethodHandle HANDLE$SDL_ClearProperty;
    public final @Nullable MethodHandle HANDLE$SDL_EnumerateProperties;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyProperties;
    public final @Nullable MethodHandle HANDLE$SDL_HasRectIntersection;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectIntersection;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectUnion;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectEnclosingPoints;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectAndLineIntersection;
    public final @Nullable MethodHandle HANDLE$SDL_HasRectIntersectionFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectIntersectionFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectUnionFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectEnclosingPointsFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetRectAndLineIntersectionFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumRenderDrivers;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderDriver;
    public final @Nullable MethodHandle HANDLE$SDL_CreateWindowAndRenderer;
    public final @Nullable MethodHandle HANDLE$SDL_CreateRenderer;
    public final @Nullable MethodHandle HANDLE$SDL_CreateRendererWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_CreateSoftwareRenderer;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderer;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderWindow;
    public final @Nullable MethodHandle HANDLE$SDL_GetRendererName;
    public final @Nullable MethodHandle HANDLE$SDL_GetRendererProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderOutputSize;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentRenderOutputSize;
    public final @Nullable MethodHandle HANDLE$SDL_CreateTexture;
    public final @Nullable MethodHandle HANDLE$SDL_CreateTextureFromSurface;
    public final @Nullable MethodHandle HANDLE$SDL_CreateTextureWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetRendererFromTexture;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureSize;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextureColorMod;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextureColorModFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureColorMod;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureColorModFloat;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextureAlphaMod;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextureAlphaModFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureAlphaMod;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureAlphaModFloat;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextureBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_SetTextureScaleMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetTextureScaleMode;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateTexture;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateYUVTexture;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateNVTexture;
    public final @Nullable MethodHandle HANDLE$SDL_LockTexture;
    public final @Nullable MethodHandle HANDLE$SDL_LockTextureToSurface;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockTexture;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderTarget;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderTarget;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderLogicalPresentation;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderLogicalPresentation;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderLogicalPresentationRect;
    public final @Nullable MethodHandle HANDLE$SDL_RenderCoordinatesFromWindow;
    public final @Nullable MethodHandle HANDLE$SDL_RenderCoordinatesToWindow;
    public final @Nullable MethodHandle HANDLE$SDL_ConvertEventToRenderCoordinates;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderViewport;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderViewport;
    public final @Nullable MethodHandle HANDLE$SDL_RenderViewportSet;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderSafeArea;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderClipRect;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderClipRect;
    public final @Nullable MethodHandle HANDLE$SDL_RenderClipEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderScale;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderScale;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderDrawColor;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderDrawColorFloat;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderDrawColor;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderDrawColorFloat;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderColorScale;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderColorScale;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderDrawBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderDrawBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_RenderClear;
    public final @Nullable MethodHandle HANDLE$SDL_RenderPoint;
    public final @Nullable MethodHandle HANDLE$SDL_RenderPoints;
    public final @Nullable MethodHandle HANDLE$SDL_RenderLine;
    public final @Nullable MethodHandle HANDLE$SDL_RenderLines;
    public final @Nullable MethodHandle HANDLE$SDL_RenderRect;
    public final @Nullable MethodHandle HANDLE$SDL_RenderRects;
    public final @Nullable MethodHandle HANDLE$SDL_RenderFillRect;
    public final @Nullable MethodHandle HANDLE$SDL_RenderFillRects;
    public final @Nullable MethodHandle HANDLE$SDL_RenderTexture;
    public final @Nullable MethodHandle HANDLE$SDL_RenderTextureRotated;
    public final @Nullable MethodHandle HANDLE$SDL_RenderTextureAffine;
    public final @Nullable MethodHandle HANDLE$SDL_RenderTextureTiled;
    public final @Nullable MethodHandle HANDLE$SDL_RenderTexture9Grid;
    public final @Nullable MethodHandle HANDLE$SDL_RenderGeometry;
    public final @Nullable MethodHandle HANDLE$SDL_RenderGeometryRaw;
    public final @Nullable MethodHandle HANDLE$SDL_RenderReadPixels;
    public final @Nullable MethodHandle HANDLE$SDL_RenderPresent;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyTexture;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyRenderer;
    public final @Nullable MethodHandle HANDLE$SDL_FlushRenderer;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderMetalLayer;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderMetalCommandEncoder;
    public final @Nullable MethodHandle HANDLE$SDL_AddVulkanRenderSemaphores;
    public final @Nullable MethodHandle HANDLE$SDL_SetRenderVSync;
    public final @Nullable MethodHandle HANDLE$SDL_GetRenderVSync;
    public final @Nullable MethodHandle HANDLE$SDL_RenderDebugText;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensors;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorNameForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorTypeForID;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorNonPortableTypeForID;
    public final @Nullable MethodHandle HANDLE$SDL_OpenSensor;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorFromID;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorName;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorType;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorNonPortableType;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorID;
    public final @Nullable MethodHandle HANDLE$SDL_GetSensorData;
    public final @Nullable MethodHandle HANDLE$SDL_CloseSensor;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateSensors;
    public final @Nullable MethodHandle HANDLE$SDL_OpenTitleStorage;
    public final @Nullable MethodHandle HANDLE$SDL_OpenUserStorage;
    public final @Nullable MethodHandle HANDLE$SDL_OpenFileStorage;
    public final @Nullable MethodHandle HANDLE$SDL_OpenStorage;
    public final @Nullable MethodHandle HANDLE$SDL_CloseStorage;
    public final @Nullable MethodHandle HANDLE$SDL_StorageReady;
    public final @Nullable MethodHandle HANDLE$SDL_GetStorageFileSize;
    public final @Nullable MethodHandle HANDLE$SDL_ReadStorageFile;
    public final @Nullable MethodHandle HANDLE$SDL_WriteStorageFile;
    public final @Nullable MethodHandle HANDLE$SDL_CreateStorageDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_EnumerateStorageDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_RemoveStoragePath;
    public final @Nullable MethodHandle HANDLE$SDL_RenameStoragePath;
    public final @Nullable MethodHandle HANDLE$SDL_CopyStorageFile;
    public final @Nullable MethodHandle HANDLE$SDL_GetStoragePathInfo;
    public final @Nullable MethodHandle HANDLE$SDL_GetStorageSpaceRemaining;
    public final @Nullable MethodHandle HANDLE$SDL_GlobStorageDirectory;
    public final @Nullable MethodHandle HANDLE$SDL_CreateSurface;
    public final @Nullable MethodHandle HANDLE$SDL_CreateSurfaceFrom;
    public final @Nullable MethodHandle HANDLE$SDL_DestroySurface;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceProperties;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceColorspace;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceColorspace;
    public final @Nullable MethodHandle HANDLE$SDL_CreateSurfacePalette;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfacePalette;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfacePalette;
    public final @Nullable MethodHandle HANDLE$SDL_AddSurfaceAlternateImage;
    public final @Nullable MethodHandle HANDLE$SDL_SurfaceHasAlternateImages;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceImages;
    public final @Nullable MethodHandle HANDLE$SDL_RemoveSurfaceAlternateImages;
    public final @Nullable MethodHandle HANDLE$SDL_LockSurface;
    public final @Nullable MethodHandle HANDLE$SDL_UnlockSurface;
    public final @Nullable MethodHandle HANDLE$SDL_LoadBMP_IO;
    public final @Nullable MethodHandle HANDLE$SDL_LoadBMP;
    public final @Nullable MethodHandle HANDLE$SDL_SaveBMP_IO;
    public final @Nullable MethodHandle HANDLE$SDL_SaveBMP;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceRLE;
    public final @Nullable MethodHandle HANDLE$SDL_SurfaceHasRLE;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceColorKey;
    public final @Nullable MethodHandle HANDLE$SDL_SurfaceHasColorKey;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceColorKey;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceColorMod;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceColorMod;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceAlphaMod;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceAlphaMod;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceBlendMode;
    public final @Nullable MethodHandle HANDLE$SDL_SetSurfaceClipRect;
    public final @Nullable MethodHandle HANDLE$SDL_GetSurfaceClipRect;
    public final @Nullable MethodHandle HANDLE$SDL_FlipSurface;
    public final @Nullable MethodHandle HANDLE$SDL_DuplicateSurface;
    public final @Nullable MethodHandle HANDLE$SDL_ScaleSurface;
    public final @Nullable MethodHandle HANDLE$SDL_ConvertSurface;
    public final @Nullable MethodHandle HANDLE$SDL_ConvertSurfaceAndColorspace;
    public final @Nullable MethodHandle HANDLE$SDL_ConvertPixels;
    public final @Nullable MethodHandle HANDLE$SDL_ConvertPixelsAndColorspace;
    public final @Nullable MethodHandle HANDLE$SDL_PremultiplyAlpha;
    public final @Nullable MethodHandle HANDLE$SDL_PremultiplySurfaceAlpha;
    public final @Nullable MethodHandle HANDLE$SDL_ClearSurface;
    public final @Nullable MethodHandle HANDLE$SDL_FillSurfaceRect;
    public final @Nullable MethodHandle HANDLE$SDL_FillSurfaceRects;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurface;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurfaceUnchecked;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurfaceScaled;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurfaceUncheckedScaled;
    public final @Nullable MethodHandle HANDLE$SDL_StretchSurface;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurfaceTiled;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurfaceTiledWithScale;
    public final @Nullable MethodHandle HANDLE$SDL_BlitSurface9Grid;
    public final @Nullable MethodHandle HANDLE$SDL_MapSurfaceRGB;
    public final @Nullable MethodHandle HANDLE$SDL_MapSurfaceRGBA;
    public final @Nullable MethodHandle HANDLE$SDL_ReadSurfacePixel;
    public final @Nullable MethodHandle HANDLE$SDL_ReadSurfacePixelFloat;
    public final @Nullable MethodHandle HANDLE$SDL_WriteSurfacePixel;
    public final @Nullable MethodHandle HANDLE$SDL_WriteSurfacePixelFloat;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowsMessageHook;
    public final @Nullable MethodHandle HANDLE$SDL_GetDirect3D9AdapterIndex;
    public final @Nullable MethodHandle HANDLE$SDL_GetDXGIOutputInfo;
    public final @Nullable MethodHandle HANDLE$SDL_SetX11EventHook;
    public final @Nullable MethodHandle HANDLE$SDL_SetLinuxThreadPriority;
    public final @Nullable MethodHandle HANDLE$SDL_SetLinuxThreadPriorityAndPolicy;
    public final @Nullable MethodHandle HANDLE$SDL_SetiOSAnimationCallback;
    public final @Nullable MethodHandle HANDLE$SDL_SetiOSEventPump;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidJNIEnv;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidActivity;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidSDKVersion;
    public final @Nullable MethodHandle HANDLE$SDL_IsChromebook;
    public final @Nullable MethodHandle HANDLE$SDL_IsDeXMode;
    public final @Nullable MethodHandle HANDLE$SDL_SendAndroidBackButton;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidInternalStoragePath;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidExternalStorageState;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidExternalStoragePath;
    public final @Nullable MethodHandle HANDLE$SDL_GetAndroidCachePath;
    public final @Nullable MethodHandle HANDLE$SDL_RequestAndroidPermission;
    public final @Nullable MethodHandle HANDLE$SDL_ShowAndroidToast;
    public final @Nullable MethodHandle HANDLE$SDL_SendAndroidMessage;
    public final @Nullable MethodHandle HANDLE$SDL_IsTablet;
    public final @Nullable MethodHandle HANDLE$SDL_IsTV;
    public final @Nullable MethodHandle HANDLE$SDL_GetSandbox;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationWillTerminate;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationDidReceiveMemoryWarning;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationWillEnterBackground;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationDidEnterBackground;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationWillEnterForeground;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationDidEnterForeground;
    public final @Nullable MethodHandle HANDLE$SDL_OnApplicationDidChangeStatusBarOrientation;
    public final @Nullable MethodHandle HANDLE$SDL_GetGDKTaskQueue;
    public final @Nullable MethodHandle HANDLE$SDL_GetGDKDefaultUser;
    public final @Nullable MethodHandle HANDLE$SDL_CreateThread;
    public final @Nullable MethodHandle HANDLE$SDL_CreateThreadWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_CreateThreadRuntime;
    public final @Nullable MethodHandle HANDLE$SDL_CreateThreadWithPropertiesRuntime;
    public final @Nullable MethodHandle HANDLE$SDL_GetThreadName;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentThreadID;
    public final @Nullable MethodHandle HANDLE$SDL_GetThreadID;
    public final @Nullable MethodHandle HANDLE$SDL_SetCurrentThreadPriority;
    public final @Nullable MethodHandle HANDLE$SDL_WaitThread;
    public final @Nullable MethodHandle HANDLE$SDL_GetThreadState;
    public final @Nullable MethodHandle HANDLE$SDL_DetachThread;
    public final @Nullable MethodHandle HANDLE$SDL_GetTLS;
    public final @Nullable MethodHandle HANDLE$SDL_SetTLS;
    public final @Nullable MethodHandle HANDLE$SDL_CleanupTLS;
    public final @Nullable MethodHandle HANDLE$SDL_GetDateTimeLocalePreferences;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentTime;
    public final @Nullable MethodHandle HANDLE$SDL_TimeToDateTime;
    public final @Nullable MethodHandle HANDLE$SDL_DateTimeToTime;
    public final @Nullable MethodHandle HANDLE$SDL_TimeToWindows;
    public final @Nullable MethodHandle HANDLE$SDL_TimeFromWindows;
    public final @Nullable MethodHandle HANDLE$SDL_GetDaysInMonth;
    public final @Nullable MethodHandle HANDLE$SDL_GetDayOfYear;
    public final @Nullable MethodHandle HANDLE$SDL_GetDayOfWeek;
    public final @Nullable MethodHandle HANDLE$SDL_GetTicks;
    public final @Nullable MethodHandle HANDLE$SDL_GetTicksNS;
    public final @Nullable MethodHandle HANDLE$SDL_GetPerformanceCounter;
    public final @Nullable MethodHandle HANDLE$SDL_GetPerformanceFrequency;
    public final @Nullable MethodHandle HANDLE$SDL_Delay;
    public final @Nullable MethodHandle HANDLE$SDL_DelayNS;
    public final @Nullable MethodHandle HANDLE$SDL_DelayPrecise;
    public final @Nullable MethodHandle HANDLE$SDL_AddTimer;
    public final @Nullable MethodHandle HANDLE$SDL_AddTimerNS;
    public final @Nullable MethodHandle HANDLE$SDL_RemoveTimer;
    public final @Nullable MethodHandle HANDLE$SDL_CreateTray;
    public final @Nullable MethodHandle HANDLE$SDL_SetTrayIcon;
    public final @Nullable MethodHandle HANDLE$SDL_SetTrayTooltip;
    public final @Nullable MethodHandle HANDLE$SDL_CreateTrayMenu;
    public final @Nullable MethodHandle HANDLE$SDL_CreateTraySubmenu;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayMenu;
    public final @Nullable MethodHandle HANDLE$SDL_GetTraySubmenu;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayEntries;
    public final @Nullable MethodHandle HANDLE$SDL_RemoveTrayEntry;
    public final @Nullable MethodHandle HANDLE$SDL_InsertTrayEntryAt;
    public final @Nullable MethodHandle HANDLE$SDL_SetTrayEntryLabel;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayEntryLabel;
    public final @Nullable MethodHandle HANDLE$SDL_SetTrayEntryChecked;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayEntryChecked;
    public final @Nullable MethodHandle HANDLE$SDL_SetTrayEntryEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayEntryEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_SetTrayEntryCallback;
    public final @Nullable MethodHandle HANDLE$SDL_ClickTrayEntry;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyTray;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayEntryParent;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayMenuParentEntry;
    public final @Nullable MethodHandle HANDLE$SDL_GetTrayMenuParentTray;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateTrays;
    public final @Nullable MethodHandle HANDLE$SDL_GetTouchDevices;
    public final @Nullable MethodHandle HANDLE$SDL_GetTouchDeviceName;
    public final @Nullable MethodHandle HANDLE$SDL_GetTouchDeviceType;
    public final @Nullable MethodHandle HANDLE$SDL_GetTouchFingers;
    public final @Nullable MethodHandle HANDLE$SDL_GetVersion;
    public final @Nullable MethodHandle HANDLE$SDL_GetRevision;
    public final @Nullable MethodHandle HANDLE$SDL_GetNumVideoDrivers;
    public final @Nullable MethodHandle HANDLE$SDL_GetVideoDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentVideoDriver;
    public final @Nullable MethodHandle HANDLE$SDL_GetSystemTheme;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplays;
    public final @Nullable MethodHandle HANDLE$SDL_GetPrimaryDisplay;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayName;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayBounds;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayUsableBounds;
    public final @Nullable MethodHandle HANDLE$SDL_GetNaturalDisplayOrientation;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentDisplayOrientation;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayContentScale;
    public final @Nullable MethodHandle HANDLE$SDL_GetFullscreenDisplayModes;
    public final @Nullable MethodHandle HANDLE$SDL_GetClosestFullscreenDisplayMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetDesktopDisplayMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetCurrentDisplayMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayForPoint;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayForRect;
    public final @Nullable MethodHandle HANDLE$SDL_GetDisplayForWindow;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowPixelDensity;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowDisplayScale;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowFullscreenMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowFullscreenMode;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowICCProfile;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowPixelFormat;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindows;
    public final @Nullable MethodHandle HANDLE$SDL_CreateWindow;
    public final @Nullable MethodHandle HANDLE$SDL_CreatePopupWindow;
    public final @Nullable MethodHandle HANDLE$SDL_CreateWindowWithProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowID;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowFromID;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowParent;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowProperties;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowFlags;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowTitle;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowTitle;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowIcon;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowPosition;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowPosition;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowSize;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowSize;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowSafeArea;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowAspectRatio;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowAspectRatio;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowBordersSize;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowSizeInPixels;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowMinimumSize;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowMinimumSize;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowMaximumSize;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowMaximumSize;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowBordered;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowResizable;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowAlwaysOnTop;
    public final @Nullable MethodHandle HANDLE$SDL_ShowWindow;
    public final @Nullable MethodHandle HANDLE$SDL_HideWindow;
    public final @Nullable MethodHandle HANDLE$SDL_RaiseWindow;
    public final @Nullable MethodHandle HANDLE$SDL_MaximizeWindow;
    public final @Nullable MethodHandle HANDLE$SDL_MinimizeWindow;
    public final @Nullable MethodHandle HANDLE$SDL_RestoreWindow;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowFullscreen;
    public final @Nullable MethodHandle HANDLE$SDL_SyncWindow;
    public final @Nullable MethodHandle HANDLE$SDL_WindowHasSurface;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowSurface;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowSurfaceVSync;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowSurfaceVSync;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateWindowSurface;
    public final @Nullable MethodHandle HANDLE$SDL_UpdateWindowSurfaceRects;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyWindowSurface;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowKeyboardGrab;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowMouseGrab;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowKeyboardGrab;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowMouseGrab;
    public final @Nullable MethodHandle HANDLE$SDL_GetGrabbedWindow;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowMouseRect;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowMouseRect;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowOpacity;
    public final @Nullable MethodHandle HANDLE$SDL_GetWindowOpacity;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowParent;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowModal;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowFocusable;
    public final @Nullable MethodHandle HANDLE$SDL_ShowWindowSystemMenu;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowHitTest;
    public final @Nullable MethodHandle HANDLE$SDL_SetWindowShape;
    public final @Nullable MethodHandle HANDLE$SDL_FlashWindow;
    public final @Nullable MethodHandle HANDLE$SDL_DestroyWindow;
    public final @Nullable MethodHandle HANDLE$SDL_ScreenSaverEnabled;
    public final @Nullable MethodHandle HANDLE$SDL_EnableScreenSaver;
    public final @Nullable MethodHandle HANDLE$SDL_DisableScreenSaver;
    public final @Nullable MethodHandle HANDLE$SDL_GL_LoadLibrary;
    public final @Nullable MethodHandle HANDLE$SDL_GL_GetProcAddress;
    public final @Nullable MethodHandle HANDLE$SDL_EGL_GetProcAddress;
    public final @Nullable MethodHandle HANDLE$SDL_GL_UnloadLibrary;
    public final @Nullable MethodHandle HANDLE$SDL_GL_ExtensionSupported;
    public final @Nullable MethodHandle HANDLE$SDL_GL_ResetAttributes;
    public final @Nullable MethodHandle HANDLE$SDL_GL_SetAttribute;
    public final @Nullable MethodHandle HANDLE$SDL_GL_GetAttribute;
    public final @Nullable MethodHandle HANDLE$SDL_GL_CreateContext;
    public final @Nullable MethodHandle HANDLE$SDL_GL_MakeCurrent;
    public final @Nullable MethodHandle HANDLE$SDL_GL_GetCurrentWindow;
    public final @Nullable MethodHandle HANDLE$SDL_GL_GetCurrentContext;
    public final @Nullable MethodHandle HANDLE$SDL_EGL_GetCurrentDisplay;
    public final @Nullable MethodHandle HANDLE$SDL_EGL_GetCurrentConfig;
    public final @Nullable MethodHandle HANDLE$SDL_EGL_GetWindowSurface;
    public final @Nullable MethodHandle HANDLE$SDL_EGL_SetAttributeCallbacks;
    public final @Nullable MethodHandle HANDLE$SDL_GL_SetSwapInterval;
    public final @Nullable MethodHandle HANDLE$SDL_GL_GetSwapInterval;
    public final @Nullable MethodHandle HANDLE$SDL_GL_SwapWindow;
    public final @Nullable MethodHandle HANDLE$SDL_GL_DestroyContext;
    // endregion

    public static final class Descriptors {
        public static final FunctionDescriptor DESCRIPTOR$SDL_malloc = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_calloc = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_realloc = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_free = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetOriginalMemoryFunctions = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMemoryFunctions = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetMemoryFunctions = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_aligned_alloc = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_aligned_free = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumAllocations = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetEnvironment = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateEnvironment = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetEnvironmentVariable = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetEnvironmentVariables = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetEnvironmentVariable = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnsetEnvironmentVariable = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyEnvironment = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_getenv = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_getenv_unsafe = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_setenv_unsafe = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_unsetenv_unsafe = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_qsort = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_bsearch = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_qsort_r = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_bsearch_r = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_abs = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isalpha = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isalnum = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isblank = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_iscntrl = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isdigit = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isxdigit = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ispunct = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isspace = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isupper = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_islower = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isprint = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isgraph = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_toupper = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_tolower = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_crc16 = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_crc32 = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_murmur3_32 = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_memcpy = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_memmove = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_memset = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_memset4 = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_memcmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcslen = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcsnlen = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcslcpy = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcslcat = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcsdup = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcsstr = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcsnstr = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcscmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcsncmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcscasecmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcsncasecmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_wcstol = FunctionDescriptor.of(
            NativeLayout.C_LONG,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strlen = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strnlen = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strlcpy = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_utf8strlcpy = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strlcat = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strdup = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strndup = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strrev = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strupr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strlwr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strchr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strrchr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strstr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strnstr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strcasestr = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strtok_r = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE))
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_utf8strlen = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_utf8strnlen = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_itoa = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_uitoa = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ltoa = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ultoa = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_lltoa = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ulltoa = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_atoi = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_atof = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strtol = FunctionDescriptor.of(
            NativeLayout.C_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strtoul = FunctionDescriptor.of(
            NativeLayout.C_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strtoll = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strtoull = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strtod = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE))
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strcmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strncmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strcasecmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strncasecmp = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_strpbrk = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StepUTF8 = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StepBackUTF8 = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE))
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UCS4ToUTF8 = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_srand = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_rand = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_randf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_rand_bits = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_rand_r = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_randf_r = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_rand_bits_r = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_acos = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_acosf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_asin = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_asinf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_atan = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_atanf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_atan2 = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_atan2f = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ceil = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ceilf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_copysign = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_copysignf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_cos = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_cosf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_exp = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_expf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_fabs = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_fabsf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_floor = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_floorf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_trunc = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_truncf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_fmod = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_fmodf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isinf = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isinff = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isnan = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_isnanf = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_log = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_logf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_log10 = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_log10f = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_modf = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_DOUBLE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_modff = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_pow = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_powf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_round = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_roundf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_lround = FunctionDescriptor.of(
            NativeLayout.C_LONG,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_lroundf = FunctionDescriptor.of(
            NativeLayout.C_LONG,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_scalbn = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_scalbnf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_sin = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_sinf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_sqrt = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_sqrtf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_tan = FunctionDescriptor.of(
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.JAVA_DOUBLE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_tanf = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_iconv_open = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_iconv_close = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_iconv = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_iconv_string = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AsyncIOFromFile = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAsyncIOSize = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadAsyncIO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteAsyncIO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseAsyncIO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateAsyncIOQueue = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyAsyncIOQueue = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAsyncIOResult = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AsyncIOOutcome.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitAsyncIOResult = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AsyncIOOutcome.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SignalAsyncIOQueue = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadFileAsync = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TryLockSpinlock = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockSpinlock = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockSpinlock = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MemoryBarrierReleaseFunction = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MemoryBarrierAcquireFunction = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CompareAndSwapAtomicInt = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicInt.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAtomicInt = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicInt.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAtomicInt = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicInt.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddAtomicInt = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicInt.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CompareAndSwapAtomicU32 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicU32.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAtomicU32 = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicU32.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAtomicU32 = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicU32.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CompareAndSwapAtomicPointer = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAtomicPointer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAtomicPointer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumAudioDrivers = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentAudioDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioPlaybackDevices = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioRecordingDevices = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioDeviceName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioDeviceFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioDeviceChannelMap = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenAudioDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsAudioDevicePhysical = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsAudioDevicePlayback = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PauseAudioDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResumeAudioDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AudioDevicePaused = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioDeviceGain = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioDeviceGain = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseAudioDevice = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindAudioStreams = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindAudioStream = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnbindAudioStreams = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnbindAudioStream = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateAudioStream = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamFrequencyRatio = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamFrequencyRatio = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamGain = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamGain = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamInputChannelMap = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamOutputChannelMap = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamInputChannelMap = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamOutputChannelMap = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PutAudioStreamData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamData = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamAvailable = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioStreamQueued = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlushAudioStream = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClearAudioStream = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PauseAudioStreamDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResumeAudioStreamDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AudioStreamDevicePaused = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockAudioStream = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockAudioStream = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamGetCallback = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioStreamPutCallback = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyAudioStream = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenAudioDeviceStream = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAudioPostmixCallback = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadWAV_IO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadWAV = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MixAudio = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ConvertAudioSamples = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AudioSpec.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAudioFormatName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSilenceValueForFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ComposeCustomBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumCameraDrivers = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentCameraDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameras = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraSupportedFormats = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(SDL_CameraSpec.LAYOUT)),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraPosition = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenCamera = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_CameraSpec.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraPermissionState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCameraFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_CameraSpec.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AcquireCameraFrame = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseCameraFrame = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseCamera = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetClipboardText = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetClipboardText = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasClipboardText = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetPrimarySelectionText = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPrimarySelectionText = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasPrimarySelectionText = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetClipboardData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClearClipboardData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetClipboardData = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasClipboardData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetClipboardMimeTypes = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumLogicalCPUCores = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCPUCacheLineSize = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasAltiVec = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasMMX = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasSSE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasSSE2 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasSSE3 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasSSE41 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasSSE42 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasAVX = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasAVX2 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasAVX512F = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasARMSIMD = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasNEON = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasLSX = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasLASX = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSystemRAM = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSIMDAlignment = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowOpenFileDialog = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_DialogFileFilter.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowSaveFileDialog = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_DialogFileFilter.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowOpenFolderDialog = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowFileDialogWithProperties = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OutOfMemory = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetError = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClearError = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PumpEvents = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PeepEvents = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasEvent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasEvents = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlushEvent = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlushEvents = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PollEvent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitEvent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitEventTimeout = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PushEvent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetEventFilter = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetEventFilter = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddEventWatch = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemoveEventWatch = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FilterEvents = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetEventEnabled = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EventEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RegisterEvents = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowFromEvent = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetBasePath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPrefPath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetUserFolder = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateDirectory = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EnumerateDirectory = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemovePath = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenamePath = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CopyFile = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPathInfo = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(SDL_PathInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GlobDirectory = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentDirectory = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddGamepadMapping = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddGamepadMappingsFromIO = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddGamepadMappingsFromFile = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReloadGamepadMappings = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadMappings = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadMappingForGUID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            SDL_GUID.LAYOUT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadMapping = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGamepadMapping = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasGamepad = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepads = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsGamepad = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadNameForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadPathForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadPlayerIndexForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadGUIDForID = FunctionDescriptor.of(
            SDL_GUID.LAYOUT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadVendorForID = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadProductForID = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadProductVersionForID = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadTypeForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRealGamepadTypeForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadMappingForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenGamepad = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadFromID = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadFromPlayerIndex = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadPath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRealGamepadType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadPlayerIndex = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGamepadPlayerIndex = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadVendor = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadProduct = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadProductVersion = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadFirmwareVersion = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadSerial = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadSteamHandle = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadConnectionState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadPowerInfo = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GamepadConnected = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadJoystick = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGamepadEventsEnabled = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GamepadEventsEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadBindings = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(SDL_GamepadBinding.LAYOUT)),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateGamepads = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadTypeFromString = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadStringForType = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadAxisFromString = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadStringForAxis = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GamepadHasAxis = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadAxis = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadButtonFromString = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadStringForButton = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GamepadHasButton = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadButton = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadButtonLabelForType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadButtonLabel = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumGamepadTouchpads = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumGamepadTouchpadFingers = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadTouchpadFinger = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BOOLEAN),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GamepadHasSensor = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGamepadSensorEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GamepadSensorEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadSensorDataRate = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadSensorData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RumbleGamepad = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RumbleGamepadTriggers = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGamepadLED = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SendGamepadEffect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseGamepad = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadAppleSFSymbolsNameForButton = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGamepadAppleSFSymbolsNameForAxis = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GPUSupportsShaderFormats = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GPUSupportsProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUDevice = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUDeviceWithProperties = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyGPUDevice = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumGPUDrivers = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGPUDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGPUDeviceDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGPUShaderFormats = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUComputePipeline = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUComputePipelineCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUGraphicsPipeline = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUGraphicsPipelineCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUSampler = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUSamplerCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUShader = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUShaderCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUTexture = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUBuffer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateGPUTransferBuffer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTransferBufferCreateInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUBufferName = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUTextureName = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_InsertGPUDebugLabel = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PushGPUDebugGroup = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PopGPUDebugGroup = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUSampler = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUTransferBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUComputePipeline = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUShader = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUGraphicsPipeline = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AcquireGPUCommandBuffer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PushGPUVertexUniformData = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PushGPUFragmentUniformData = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PushGPUComputeUniformData = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BeginGPURenderPass = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUColorTargetInfo.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUDepthStencilTargetInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUGraphicsPipeline = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUViewport = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUViewport.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUScissor = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUBlendConstants = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            SDL_FColor.LAYOUT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUStencilReference = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUVertexBuffers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferBinding.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUIndexBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferBinding.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUVertexSamplers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureSamplerBinding.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUVertexStorageTextures = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUVertexStorageBuffers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUFragmentSamplers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureSamplerBinding.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUFragmentStorageTextures = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUFragmentStorageBuffers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DrawGPUIndexedPrimitives = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DrawGPUPrimitives = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DrawGPUPrimitivesIndirect = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DrawGPUIndexedPrimitivesIndirect = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EndGPURenderPass = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BeginGPUComputePass = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUStorageTextureReadWriteBinding.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUStorageBufferReadWriteBinding.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUComputePipeline = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUComputeSamplers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureSamplerBinding.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUComputeStorageTextures = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BindGPUComputeStorageBuffers = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DispatchGPUCompute = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DispatchGPUComputeIndirect = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EndGPUComputePass = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MapGPUTransferBuffer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnmapGPUTransferBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BeginGPUCopyPass = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UploadToGPUTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureTransferInfo.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureRegion.LAYOUT),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UploadToGPUBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTransferBufferLocation.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferRegion.LAYOUT),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CopyGPUTextureToTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureLocation.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureLocation.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CopyGPUBufferToBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferLocation.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferLocation.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DownloadFromGPUTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureRegion.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTextureTransferInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DownloadFromGPUBuffer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBufferRegion.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUTransferBufferLocation.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EndGPUCopyPass = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GenerateMipmapsForGPUTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitGPUTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_GPUBlitInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WindowSupportsGPUSwapchainComposition = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WindowSupportsGPUPresentMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClaimWindowForGPUDevice = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseWindowFromGPUDevice = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUSwapchainParameters = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetGPUAllowedFramesInFlight = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGPUSwapchainTextureFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AcquireGPUSwapchainTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitForGPUSwapchain = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitAndAcquireGPUSwapchainTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SubmitGPUCommandBuffer = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SubmitGPUCommandBufferAndAcquireFence = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CancelGPUCommandBuffer = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitForGPUIdle = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitForGPUFences = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_QueryGPUFence = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReleaseGPUFence = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GPUTextureFormatTexelBlockSize = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GPUTextureSupportsFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GPUTextureSupportsSampleCount = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CalculateGPUTextureFormatSize = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GDKSuspendGPU = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GDKResumeGPU = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GUIDToString = FunctionDescriptor.ofVoid(
            SDL_GUID.LAYOUT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StringToGUID = FunctionDescriptor.of(
            SDL_GUID.LAYOUT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHaptics = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHapticNameForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenHaptic = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHapticFromID = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHapticID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHapticName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsMouseHaptic = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenHapticFromMouse = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsJoystickHaptic = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenHapticFromJoystick = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseHaptic = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMaxHapticEffects = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMaxHapticEffectsPlaying = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHapticFeatures = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumHapticAxes = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HapticEffectSupported = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_HapticEffect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateHapticEffect = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_HapticEffect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateHapticEffect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_HapticEffect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RunHapticEffect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StopHapticEffect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyHapticEffect = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHapticEffectStatus = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetHapticGain = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetHapticAutocenter = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PauseHaptic = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResumeHaptic = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StopHapticEffects = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HapticRumbleSupported = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_InitHapticRumble = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PlayHapticRumble = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StopHapticRumble = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_init = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_exit = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_device_change_count = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_enumerate = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_hid_device_info.LAYOUT),
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_free_enumeration = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(SDL_hid_device_info.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_open = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_open_path = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_write = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_read_timeout = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_read = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_set_nonblocking = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_send_feature_report = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_feature_report = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_input_report = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_close = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_manufacturer_string = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_product_string = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_serial_number_string = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_indexed_string = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_device_info = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_hid_device_info.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_get_report_descriptor = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_hid_ble_scan = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetHintWithPriority = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetHint = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResetHint = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResetHints = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHint = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetHintBoolean = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddHintCallback = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemoveHintCallback = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_Init = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_InitSubSystem = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_QuitSubSystem = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WasInit = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_Quit = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsMainThread = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RunOnMainThread = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAppMetadata = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetAppMetadataProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAppMetadataProperty = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IOFromFile = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IOFromMem = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IOFromConstMem = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IOFromDynamicMem = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenIO = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_IOStreamInterface.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseIO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetIOProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetIOStatus = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetIOSize = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SeekIO = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TellIO = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadIO = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteIO = FunctionDescriptor.of(
            NativeLayout.C_SIZE_T,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlushIO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadFile_IO = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadFile = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SaveFile_IO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SaveFile = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            NativeLayout.C_SIZE_T
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU8 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS8 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU16LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS16LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU16BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS16BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU32LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS32LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU32BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS32BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU64LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS64LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadU64BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadS64BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU8 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS8 = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU16LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS16LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU16BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS16BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU32LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS32LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU32BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS32BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU64LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS64LE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteU64BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteS64BE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockJoysticks = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockJoysticks = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasJoystick = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoysticks = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickNameForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickPathForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickPlayerIndexForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickGUIDForID = FunctionDescriptor.of(
            SDL_GUID.LAYOUT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickVendorForID = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickProductForID = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickProductVersionForID = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickTypeForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenJoystick = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickFromID = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickFromPlayerIndex = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AttachVirtualJoystick = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_VirtualJoystickDesc.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DetachVirtualJoystick = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsJoystickVirtual = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickVirtualAxis = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickVirtualBall = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickVirtualButton = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickVirtualHat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickVirtualTouchpad = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SendJoystickVirtualSensorData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickPath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickPlayerIndex = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickPlayerIndex = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickGUID = FunctionDescriptor.of(
            SDL_GUID.LAYOUT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickVendor = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickProduct = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickProductVersion = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickFirmwareVersion = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickSerial = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickGUIDInfo = FunctionDescriptor.ofVoid(
            SDL_GUID.LAYOUT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_JoystickConnected = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumJoystickAxes = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumJoystickBalls = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumJoystickHats = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumJoystickButtons = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickEventsEnabled = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_JoystickEventsEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateJoysticks = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickAxis = FunctionDescriptor.of(
            ValueLayout.JAVA_SHORT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickAxisInitialState = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_SHORT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickBall = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickHat = FunctionDescriptor.of(
            ValueLayout.JAVA_BYTE,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickButton = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RumbleJoystick = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RumbleJoystickTriggers = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_SHORT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetJoystickLED = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SendJoystickEffect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseJoystick = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickConnectionState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetJoystickPowerInfo = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasKeyboard = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyboards = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyboardNameForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyboardFocus = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyboardState = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BOOLEAN),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResetKeyboard = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetModState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetModState = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyFromScancode = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetScancodeFromKey = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetScancodeName = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetScancodeName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetScancodeFromName = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetKeyFromName = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StartTextInput = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StartTextInputWithProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TextInputActive = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StopTextInput = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClearComposition = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextInputArea = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextInputArea = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasScreenKeyboardSupport = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ScreenKeyboardShown = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadObject = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadFunction = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnloadObject = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPreferredLocales = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(SDL_Locale.LAYOUT)),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetLogPriorities = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetLogPriority = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetLogPriority = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ResetLogPriorities = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetLogPriorityPrefix = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDefaultLogOutputFunction = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetLogOutputFunction = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetLogOutputFunction = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowMessageBox = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_MessageBoxData.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowSimpleMessageBox = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_Metal_CreateView = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_Metal_DestroyView = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_Metal_GetLayer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenURL = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasMouse = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMice = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMouseNameForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMouseFocus = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMouseState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGlobalMouseState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRelativeMouseState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WarpMouseInWindow = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WarpMouseGlobal = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowRelativeMouseMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowRelativeMouseMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CaptureMouse = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateCursor = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateColorCursor = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateSystemCursor = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetCursor = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCursor = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDefaultCursor = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyCursor = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowCursor = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HideCursor = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CursorVisible = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateMutex = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockMutex = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TryLockMutex = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockMutex = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyMutex = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateRWLock = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockRWLockForReading = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockRWLockForWriting = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TryLockRWLockForReading = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TryLockRWLockForWriting = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockRWLock = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyRWLock = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateSemaphore = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroySemaphore = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitSemaphore = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TryWaitSemaphore = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitSemaphoreTimeout = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SignalSemaphore = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSemaphoreValue = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateCondition = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyCondition = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SignalCondition = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BroadcastCondition = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitCondition = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitConditionTimeout = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShouldInit = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_InitState.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShouldQuit = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_InitState.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetInitialized = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(SDL_InitState.LAYOUT),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPixelFormatName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetMasksForPixelFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPixelFormatForMasks = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPixelFormatDetails = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_PixelFormatDetails.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreatePalette = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetPaletteColors = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Color.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyPalette = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MapRGB = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_PixelFormatDetails.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MapRGBA = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_PixelFormatDetails.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRGB = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_PixelFormatDetails.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRGBA = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_PixelFormatDetails.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPlatform = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPowerInfo = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateProcess = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateProcessWithProperties = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetProcessProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadProcess = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetProcessInput = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetProcessOutput = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_KillProcess = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitProcess = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyProcess = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGlobalProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CopyProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockProperties = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetPointerPropertyWithCleanup = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetPointerProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetStringProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetNumberProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetFloatProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetBooleanProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPropertyType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPointerProperty = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetStringProperty = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumberProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetFloatProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetBooleanProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClearProperty = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EnumerateProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyProperties = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasRectIntersection = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectIntersection = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectUnion = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectEnclosingPoints = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Point.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectAndLineIntersection = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HasRectIntersectionFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectIntersectionFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectUnionFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectEnclosingPointsFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRectAndLineIntersectionFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumRenderDrivers = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateWindowAndRenderer = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateRenderer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateRendererWithProperties = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateSoftwareRenderer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderWindow = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRendererName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRendererProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderOutputSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentRenderOutputSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateTexture = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateTextureFromSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateTextureWithProperties = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRendererFromTexture = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextureColorMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextureColorModFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureColorMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureColorModFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextureAlphaMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextureAlphaModFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureAlphaMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureAlphaModFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextureBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTextureScaleMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTextureScaleMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateYUVTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateNVTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockTextureToSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderTarget = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderTarget = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderLogicalPresentation = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderLogicalPresentation = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderLogicalPresentationRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderCoordinatesFromWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderCoordinatesToWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ConvertEventToRenderCoordinates = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Event.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderViewport = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderViewport = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderViewportSet = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderSafeArea = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderClipRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderClipRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderClipEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderScale = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderScale = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderDrawColor = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderDrawColorFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderDrawColor = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderDrawColorFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderColorScale = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderColorScale = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderDrawBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderDrawBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderClear = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderPoint = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderPoints = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderLine = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderLines = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderRects = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderFillRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderFillRects = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderTexture = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderTextureRotated = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.JAVA_DOUBLE,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderTextureAffine = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(SDL_FPoint.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderTextureTiled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderTexture9Grid = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT),
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FRect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderGeometry = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Vertex.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderGeometryRaw = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_FColor.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderReadPixels = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderPresent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyTexture = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyRenderer = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlushRenderer = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderMetalLayer = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderMetalCommandEncoder = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddVulkanRenderSemaphores = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetRenderVSync = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRenderVSync = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenderDebugText = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensors = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorNameForID = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorTypeForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorNonPortableTypeForID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenSensor = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorFromID = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorNonPortableType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSensorData = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseSensor = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateSensors = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenTitleStorage = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenUserStorage = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenFileStorage = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OpenStorage = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_StorageInterface.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CloseStorage = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StorageReady = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetStorageFileSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadStorageFile = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteStorageFile = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateStorageDirectory = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EnumerateStorageDirectory = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemoveStoragePath = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RenameStoragePath = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CopyStorageFile = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetStoragePathInfo = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(SDL_PathInfo.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetStorageSpaceRemaining = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GlobStorageDirectory = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateSurfaceFrom = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroySurface = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceColorspace = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceColorspace = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateSurfacePalette = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfacePalette = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfacePalette = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddSurfaceAlternateImage = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SurfaceHasAlternateImages = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceImages = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemoveSurfaceAlternateImages = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LockSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UnlockSurface = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadBMP_IO = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_LoadBMP = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SaveBMP_IO = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SaveBMP = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceRLE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SurfaceHasRLE = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceColorKey = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SurfaceHasColorKey = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceColorKey = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceColorMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceColorMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceAlphaMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceAlphaMod = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceBlendMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetSurfaceClipRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSurfaceClipRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlipSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DuplicateSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ScaleSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ConvertSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ConvertSurfaceAndColorspace = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Palette.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ConvertPixels = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ConvertPixelsAndColorspace = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PremultiplyAlpha = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_PremultiplySurfaceAlpha = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClearSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FillSurfaceRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FillSurfaceRects = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurfaceUnchecked = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurfaceScaled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurfaceUncheckedScaled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_StretchSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurfaceTiled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurfaceTiledWithScale = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_BlitSurface9Grid = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MapSurfaceRGB = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MapSurfaceRGBA = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadSurfacePixel = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ReadSurfacePixelFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteSurfacePixel = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE,
            ValueLayout.JAVA_BYTE
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WriteSurfacePixelFloat = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowsMessageHook = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDirect3D9AdapterIndex = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDXGIOutputInfo = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetX11EventHook = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetLinuxThreadPriority = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetLinuxThreadPriorityAndPolicy = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetiOSAnimationCallback = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetiOSEventPump = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidJNIEnv = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidActivity = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidSDKVersion = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsChromebook = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsDeXMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SendAndroidBackButton = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidInternalStoragePath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidExternalStorageState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidExternalStoragePath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetAndroidCachePath = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RequestAndroidPermission = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowAndroidToast = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SendAndroidMessage = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsTablet = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_IsTV = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSandbox = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationWillTerminate = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationDidReceiveMemoryWarning = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationWillEnterBackground = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationDidEnterBackground = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationWillEnterForeground = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationDidEnterForeground = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_OnApplicationDidChangeStatusBarOrientation = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGDKTaskQueue = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGDKDefaultUser = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateThread = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateThreadWithProperties = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateThreadRuntime = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateThreadWithPropertiesRuntime = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetThreadName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentThreadID = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetThreadID = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetCurrentThreadPriority = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WaitThread = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetThreadState = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DetachThread = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTLS = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicInt.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTLS = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_AtomicInt.LAYOUT),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CleanupTLS = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDateTimeLocalePreferences = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentTime = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TimeToDateTime = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(SDL_DateTime.LAYOUT),
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DateTimeToTime = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_DateTime.LAYOUT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TimeToWindows = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_TimeFromWindows = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDaysInMonth = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDayOfYear = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDayOfWeek = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTicks = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTicksNS = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPerformanceCounter = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPerformanceFrequency = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_Delay = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DelayNS = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DelayPrecise = FunctionDescriptor.ofVoid(
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddTimer = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_AddTimerNS = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemoveTimer = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateTray = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTrayIcon = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTrayTooltip = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateTrayMenu = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateTraySubmenu = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayMenu = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTraySubmenu = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayEntries = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RemoveTrayEntry = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_InsertTrayEntryAt = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTrayEntryLabel = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayEntryLabel = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTrayEntryChecked = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayEntryChecked = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTrayEntryEnabled = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayEntryEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetTrayEntryCallback = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ClickTrayEntry = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyTray = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayEntryParent = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayMenuParentEntry = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTrayMenuParentTray = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateTrays = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTouchDevices = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_LONG),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTouchDeviceName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTouchDeviceType = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetTouchFingers = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(SDL_Finger.LAYOUT)),
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetVersion = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetRevision = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNumVideoDrivers = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetVideoDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentVideoDriver = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetSystemTheme = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplays = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetPrimaryDisplay = FunctionDescriptor.of(
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayName = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayBounds = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayUsableBounds = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetNaturalDisplayOrientation = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentDisplayOrientation = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayContentScale = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetFullscreenDisplayModes = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS.withTargetLayout(SDL_DisplayMode.LAYOUT)),
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetClosestFullscreenDisplayMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(SDL_DisplayMode.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDesktopDisplayMode = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_DisplayMode.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetCurrentDisplayMode = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_DisplayMode.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayForPoint = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Point.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayForRect = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetDisplayForWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowPixelDensity = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowDisplayScale = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowFullscreenMode = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_DisplayMode.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowFullscreenMode = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_DisplayMode.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowICCProfile = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(NativeLayout.C_SIZE_T)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowPixelFormat = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindows = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.ADDRESS),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateWindow = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreatePopupWindow = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_LONG
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_CreateWindowWithProperties = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowID = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowFromID = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowParent = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowProperties = FunctionDescriptor.of(
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowFlags = FunctionDescriptor.of(
            ValueLayout.JAVA_LONG,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowTitle = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowTitle = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowIcon = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowPosition = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowPosition = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowSafeArea = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowAspectRatio = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowAspectRatio = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_FLOAT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowBordersSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowSizeInPixels = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowMinimumSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowMinimumSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowMaximumSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowMaximumSize = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT),
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowBordered = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowResizable = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowAlwaysOnTop = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_HideWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RaiseWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MaximizeWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_MinimizeWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_RestoreWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowFullscreen = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SyncWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_WindowHasSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowSurfaceVSync = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowSurfaceVSync = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateWindowSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_UpdateWindowSurfaceRects = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyWindowSurface = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowKeyboardGrab = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowMouseGrab = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowKeyboardGrab = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowMouseGrab = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetGrabbedWindow = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowMouseRect = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowMouseRect = FunctionDescriptor.of(
            ValueLayout.ADDRESS.withTargetLayout(SDL_Rect.LAYOUT),
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowOpacity = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_FLOAT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GetWindowOpacity = FunctionDescriptor.of(
            ValueLayout.JAVA_FLOAT,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowParent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowModal = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowFocusable = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ShowWindowSystemMenu = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowHitTest = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_SetWindowShape = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_FlashWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DestroyWindow = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_ScreenSaverEnabled = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EnableScreenSaver = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_DisableScreenSaver = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_LoadLibrary = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_GetProcAddress = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EGL_GetProcAddress = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_UnloadLibrary = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_ExtensionSupported = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_ResetAttributes = FunctionDescriptor.ofVoid(
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_SetAttribute = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_GetAttribute = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_CreateContext = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_MakeCurrent = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_GetCurrentWindow = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_GetCurrentContext = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EGL_GetCurrentDisplay = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EGL_GetCurrentConfig = FunctionDescriptor.of(
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EGL_GetWindowSurface = FunctionDescriptor.of(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_EGL_SetAttributeCallbacks = FunctionDescriptor.ofVoid(
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_SetSwapInterval = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.JAVA_INT
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_GetSwapInterval = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_SwapWindow = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        public static final FunctionDescriptor DESCRIPTOR$SDL_GL_DestroyContext = FunctionDescriptor.of(
            ValueLayout.JAVA_BOOLEAN,
            ValueLayout.ADDRESS
        );

        /// Constructing this class is nonsense so the constructor is made private.
        private Descriptors() {}
    }
}
